<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Decade</title>
  
  <subtitle>你终究是一个过客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-17T14:45:16.287Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Decade</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MongoDB数据库</title>
    <link href="http://example.com/2020/11/07/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2020/11/07/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-11-07T05:06:43.000Z</published>
    <updated>2020-11-17T14:45:16.287Z</updated>
    
    
    <summary type="html">MongoDB数据库</summary>
    
    
    
    <category term="MongoDB数据库" scheme="http://example.com/categories/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MongoDB数据库" scheme="http://example.com/tags/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Gulp.js</title>
    <link href="http://example.com/2020/11/06/gulp/"/>
    <id>http://example.com/2020/11/06/gulp/</id>
    <published>2020-11-06T05:06:43.000Z</published>
    <updated>2020-11-16T13:28:00.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h1><p>基于node平台开发的前端构建工具<br>将机械化操作编写成任务, 想要执行机械化操作时执行一个命令行命令任务就能自动执行了<br>用机器代替手工，提高开发效率。</p><h2 id="Gulp能做什么"><a href="#Gulp能做什么" class="headerlink" title="Gulp能做什么"></a>Gulp能做什么</h2><ul><li>项目上线，HTML、CSS、JS文件压缩合并</li><li>语法转换（es6、less …）</li><li>公共文件抽离</li><li>修改文件浏览器自动刷新</li></ul><h2 id="Gulp使用"><a href="#Gulp使用" class="headerlink" title="Gulp使用"></a>Gulp使用</h2><ul><li>使用npm install gulp下载gulp库文件</li><li>在项目根目录下建立gulpfile.js文件</li><li>重构项目的文件夹结构 src目录放置源代码文件 dist目录放置构建后文件</li><li>在gulpfile.js文件中编写任务.</li><li>在命令行工具中执行gulp任务</li></ul><h3 id="下载gulp命令"><a href="#下载gulp命令" class="headerlink" title="下载gulp命令"></a>下载gulp命令</h3><p>npm install gulp-cli -g</p><h2 id="Gulp中提供的方法"><a href="#Gulp中提供的方法" class="headerlink" title="Gulp中提供的方法"></a>Gulp中提供的方法</h2><ul><li>gulp.src()：获取任务要处理的文件</li><li>gulp.dest()：输出文件</li><li>gulp.task()：建立gulp任务</li><li>gulp.watch()：监控文件的变化</li></ul><h2 id="Gulp插件"><a href="#Gulp插件" class="headerlink" title="Gulp插件"></a>Gulp插件</h2><ul><li>gulp-htmlmin ：html文件压缩</li><li>gulp-csso ：压缩css</li><li>gulp-babel ：JavaScript语法转化</li><li>gulp-less: less语法转化</li><li>gulp-uglify ：压缩混淆JavaScript</li><li>gulp-file-include 公共文件包含</li><li>browsersync 浏览器实时同步</li></ul><h3 id="把src下的base-css复制粘贴到dist-css里"><a href="#把src下的base-css复制粘贴到dist-css里" class="headerlink" title="把src下的base.css复制粘贴到dist/css里"></a>把src下的base.css复制粘贴到dist/css里</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用gulp模块</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="comment">//使用gulp.task建立任务</span></span><br><span class="line"><span class="comment">//1.任务的名称</span></span><br><span class="line"><span class="comment">//2.任务的回调函数</span></span><br><span class="line">gulp.task(<span class="string">&#x27;first&#x27;</span>,<span class="function">()=&gt;</span>&#123;<span class="comment">//命名方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gulp任务执行成功&#x27;</span>);</span><br><span class="line">    <span class="comment">//使用gulp.src获取要处理的文件</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/css/base.css&#x27;</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/css&#x27;</span>));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令： gulp first</p><hr><h3 id="把html代码压缩"><a href="#把html代码压缩" class="headerlink" title="把html代码压缩"></a>把html代码压缩</h3><p>下载插件： npm install gulp-htmlmin</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用gulp模块</span></span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlmin&#x27;</span>);</span><br><span class="line"><span class="comment">//1.html文件中代码的压缩代码</span></span><br><span class="line">gulp.task(<span class="string">&#x27;htmlmin&#x27;</span>,<span class="function">()=&gt;</span>&#123;<span class="comment">//命名方法</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/*.html&#x27;</span>) <span class="comment">//*.html 泛指所有的html文件</span></span><br><span class="line">    .pipe(htmlmin(&#123;<span class="attr">collapseWitespace</span>:ture)); <span class="comment">//压缩html代码</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist&#x27;</span>));<span class="comment">//把src文件所有的html压缩到dist文件夹里</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令： gulp htmlmin</p><hr><h3 id="抽取html公共代码"><a href="#抽取html公共代码" class="headerlink" title="抽取html公共代码"></a>抽取html公共代码</h3><p>下载插件： npm install gulp-file-include</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用模块</span></span><br><span class="line"><span class="keyword">const</span> fileinclude = <span class="built_in">require</span>(<span class="string">&#x27;gulp-file-include&#x27;</span>);</span><br><span class="line"><span class="comment">//1.新建common 公共文件夹 新建比如header.html</span></span><br><span class="line"><span class="comment">//2.把html公共的文件夹放到common的html里</span></span><br><span class="line"><span class="comment">//3.在旧的html写上  @@include(&#x27;./common/header.html&#x27;)</span></span><br><span class="line"><span class="comment">//4.执行任务gulp htmlmin</span></span><br><span class="line">gulp.task(<span class="string">&#x27;htmlrecude&#x27;</span>,<span class="function">()=&gt;</span>&#123;<span class="comment">//命名方法</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/*.html&#x27;</span>) <span class="comment">//*.html 泛指所有的html文件</span></span><br><span class="line">    .pipe(fileinclude());</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist&#x27;</span>));<span class="comment">//把src文件所有的html压缩到dist文件夹里</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令： gulp htmlrecude</p><h3 id="css里less语法转换"><a href="#css里less语法转换" class="headerlink" title="css里less语法转换"></a>css里less语法转换</h3><p>下载插件： npm install gulp-less</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">&#x27;gulp-less&#x27;</span>);</span><br><span class="line">gulp.task(<span class="string">&#x27;lesszcss&#x27;</span>,<span class="function">()=&gt;</span>&#123;<span class="comment">//命名方法</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/css/*.less&#x27;</span>) <span class="comment">//*.html 泛指所有的html文件</span></span><br><span class="line">    .pipe(less());</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/css&#x27;</span>));<span class="comment">//把src文件所有的html压缩到dist文件夹里</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令： gulp lesszcss</p><h3 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h3><p>下载插件： npm install gulp-csso</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> csso = <span class="built_in">require</span>(<span class="string">&#x27;gulp-csso&#x27;</span>);</span><br><span class="line">gulp.task(<span class="string">&#x27;cssrecude&#x27;</span>,<span class="function">()=&gt;</span>&#123;<span class="comment">//命名方法</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/css/*.css&#x27;</span>) <span class="comment">//*. 泛指所有文件</span></span><br><span class="line">    .pipe(csso());</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/css&#x27;</span>));<span class="comment">//把src文件所有的html压缩到dist文件夹里</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>命令： gulp cssrecude</p><h3 id="es6语法转换"><a href="#es6语法转换" class="headerlink" title="es6语法转换"></a>es6语法转换</h3><p>下载插件： npm install gulp-csso</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bable = <span class="built_in">require</span>(<span class="string">&#x27;gulp-bable&#x27;</span>);</span><br><span class="line">gulp.task(<span class="string">&#x27;es&#x27;</span>,<span class="function">()=&gt;</span>&#123;<span class="comment">//命名方法</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/js/*.js&#x27;</span>) <span class="comment">//*.泛指所有文件</span></span><br><span class="line">    .pipe(bable(&#123;</span><br><span class="line">        presets:[<span class="string">&#x27;@bable/env&#x27;</span>]<span class="comment">//他可以判断当前代码的运行环境 将代码转换为当前运行环境所支持的代码</span></span><br><span class="line">    &#125;));</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/js&#x27;</span>));<span class="comment">//把src文件所有的html压缩到dist文件夹里</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>命令： gulp es</p><h3 id="压缩js"><a href="#压缩js" class="headerlink" title="压缩js"></a>压缩js</h3><p>下载插件： npm install gulp-csso</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line">gulp.task(<span class="string">&#x27; jsmin&#x27;</span>,<span class="function">()=&gt;</span>&#123;<span class="comment">//命名方法</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/js/*.js&#x27;</span>) <span class="comment">//*.泛指所有文件</span></span><br><span class="line">    .pipe(bable(&#123;</span><br><span class="line">        presets:[<span class="string">&#x27;@bable/env&#x27;</span>]<span class="comment">//es6转换es5</span></span><br><span class="line">    &#125;));</span><br><span class="line">    .pipe(uglify()); <span class="comment">//压缩js</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/css&#x27;</span>));<span class="comment">//把src文件所有的html压缩到dist文件夹里</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>命令： gulp jsmin</p><h3 id="复制文件夹"><a href="#复制文件夹" class="headerlink" title="复制文件夹"></a>复制文件夹</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;copy&#x27;</span>,<span class="function">()=&gt;</span>&#123;<span class="comment">//命名方法</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/images/*&#x27;</span>);   <span class="comment">//*.泛指所有文件</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/images&#x27;</span>));</span><br><span class="line">    </span><br><span class="line">     gulp.src(<span class="string">&#x27;./src/lib/*&#x27;</span>);   <span class="comment">//*.泛指所有文件</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist/lib&#x27;</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>命令： gulp copy</p><h3 id="浏览器自动刷新"><a href="#浏览器自动刷新" class="headerlink" title="浏览器自动刷新"></a>浏览器自动刷新</h3><pre><code>  在搭建使用gulp-livereload实时自动刷新页面的过程中，需要注意的几点是：   1.使用 gulp-livereload 需要使用 chrome 浏览器，并且安装 gulp-livereload 插件；   2.在 gulpfile.js 中创建task， 旧版使用var server = livereload();已经失效，需要使用 livereload.listen(); ；   3.使用 gulp-livereload 需要使用到服务器，在服务器下进行访问，开启 gulp-livereload 插件；（当然也可以使用 npm 安装 http-server 来启动服务）</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>),</span><br><span class="line">    livereload = <span class="built_in">require</span>(<span class="string">&#x27;gulp-livereload&#x27;</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;watch&#x27;</span>,<span class="function">()=&gt;</span>&#123; <span class="comment">//这里的watch，是自定义的，携程live或者别的也行</span></span><br><span class="line">    livereload.listen();<span class="comment">//这里需要注意！旧版使用var server = livereload();已经失效  </span></span><br><span class="line">    <span class="comment">// app/**/*.* 的意思是 app 文件夹下的 任何文件夹 的 任何文件</span></span><br><span class="line">    gulp.watch(<span class="string">&#x27;app/**/*.*&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    livereload.changed(event.path);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp=<span class="built_in">require</span>(‘gulp’);<span class="comment">//引入gulp模块</span></span><br><span class="line"><span class="keyword">const</span> connect=<span class="built_in">require</span>(‘gulp-connect’);<span class="comment">//引入gulp-connect模块</span></span><br><span class="line"><span class="keyword">const</span> open=<span class="built_in">require</span>(‘open’);<span class="comment">//引入open模块，注意不是gulp-open</span></span><br><span class="line"><span class="comment">//我们可以定义一个根目录：</span></span><br><span class="line"><span class="keyword">const</span> rootPath=’./’;　　　<span class="comment">//根据实际情况定义</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;serve&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">　　connect.server(&#123;</span><br><span class="line">　　　　root:rootPath,　　<span class="comment">//使用前面定义的rootPath作为服务器运行的根目录</span></span><br><span class="line">　　　　livereload:<span class="literal">true</span>,　　<span class="comment">//是否自动监听，true表明自动监听</span></span><br><span class="line">　　　　port:<span class="number">3056</span>　　　　<span class="comment">//服务器的端口号，可以随便取一个</span></span><br><span class="line">　　&#125;);</span><br><span class="line">　open(‘http:<span class="comment">//localhost:3056’);　　//自动使用浏览器打开http://localhost:3056的页面</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="构建任务"><a href="#构建任务" class="headerlink" title="构建任务"></a>构建任务</h3><p>一次命令  多种任务同时做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>,[<span class="string">&#x27;htmlmin&#x27;</span>,<span class="string">&#x27;csso&#x27;</span>,<span class="string">&#x27;jsmin&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Gulp.js</summary>
    
    
    
    <category term="Gulp.js" scheme="http://example.com/categories/Gulp-js/"/>
    
    
    <category term="Gulp.js" scheme="http://example.com/tags/Gulp-js/"/>
    
  </entry>
  
  <entry>
    <title>Node.js</title>
    <link href="http://example.com/2020/11/05/node1/"/>
    <id>http://example.com/2020/11/05/node1/</id>
    <published>2020-11-05T05:06:43.000Z</published>
    <updated>2020-11-17T14:34:35.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="为什么选择Node？"><a href="#为什么选择Node？" class="headerlink" title="为什么选择Node？"></a>为什么选择Node？</h2><ul><li>使用JavaScript语法开发后端应用</li><li>一些公司要求前端工程师node开发</li><li>生态系统活跃，有大量的开源库可以使用</li><li>前端开发工具大多基于node开发</li></ul><h2 id="Node是什么？"><a href="#Node是什么？" class="headerlink" title="Node是什么？"></a>Node是什么？</h2><p>Node是一个基于Chrome V8引擎的JavaScript代码运行环境。</p><h2 id="运行环境。"><a href="#运行环境。" class="headerlink" title="运行环境。"></a>运行环境。</h2><ul><li>浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境</li><li>Node（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境</li></ul><h2 id="Node-js运行环境安装"><a href="#Node-js运行环境安装" class="headerlink" title="Node.js运行环境安装"></a>Node.js运行环境安装</h2><p>官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a><br><img src="https://s3.ax1x.com/2020/11/15/DFygzQ.png" alt="我是图片"></p><ul><li>LTS = Long Term Support 长期支持版 稳定版</li><li>Current 拥有最新特性 实验版</li></ul><h2 id="Node-js-的组成"><a href="#Node-js-的组成" class="headerlink" title="Node.js 的组成"></a>Node.js 的组成</h2><ul><li>JavaScript 由三部分组成，ECMAScript，DOM，BOM。</li><li>Node.js是由ECMAScript及Node 环境提供的一些附加API组成的，包括文件、网络、路径等等一些更加强大的 API。<br><img src="https://s3.ax1x.com/2020/11/15/DF61yj.png" alt="我是图片"></li></ul><h2 id="Node-js基础语法"><a href="#Node-js基础语法" class="headerlink" title="Node.js基础语法"></a>Node.js基础语法</h2><p>所有ECMAScript语法在Node环境中都可以使用。<br>在Node环境下执行代码，使用Node命令执行后缀为.js的文件即可<br><img src="https://s3.ax1x.com/2020/11/15/DF60l4.png" alt="我是图片"><br><img src="https://s3.ax1x.com/2020/11/15/DFcA9U.png" alt="我是图片"></p><h2 id="Node-js全局对象global"><a href="#Node-js全局对象global" class="headerlink" title="Node.js全局对象global"></a>Node.js全局对象global</h2><p>在浏览器中全局对象是window，在Node中全局对象是global。<br>Node中全局对象下有以下方法，可以在任何地方使用，global可以省略。</p><ul><li>console.log()     在控制台中输出</li><li>setTimeout()      设置超时定时器</li><li>clearTimeout()    清除超时时定时器</li><li>setInterval()      设置间歇定时器</li><li>clearInterval()    清除间歇定时器</li></ul><p><img src="https://s3.ax1x.com/2020/11/15/DFcI8U.png" alt="我是图片"></p><h1 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h1><h2 id="JavaScript开发弊端"><a href="#JavaScript开发弊端" class="headerlink" title="JavaScript开发弊端"></a>JavaScript开发弊端</h2><p>JavaScript在使用时存在两大问题，文件依赖和命名冲突。<br><img src="https://s3.ax1x.com/2020/11/15/DFgZPf.png" alt="我是图片"></p><h2 id="什么是模块化开发"><a href="#什么是模块化开发" class="headerlink" title="什么是模块化开发"></a>什么是模块化开发</h2><p>一个功能就是一个模块，多个模块可以组成完整应用，抽离一个模块不会影响其他功能的运行。</p><h2 id="Node-js中模块化开发规范"><a href="#Node-js中模块化开发规范" class="headerlink" title="Node.js中模块化开发规范"></a>Node.js中模块化开发规范</h2><p>Node.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到<br>模块内部可以使用exports对象进行成员导出， 使用require方法导入其他模块。<br><img src="https://s3.ax1x.com/2020/11/15/DFgJiV.png" alt="我是图片"></p><h2 id="模块成员的导入与导出"><a href="#模块成员的导入与导出" class="headerlink" title="模块成员的导入与导出"></a>模块成员的导入与导出</h2><h4 id="a-js-导出"><a href="#a-js-导出" class="headerlink" title="a.js 导出"></a>a.js 导出</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add=<span class="function">(<span class="params">n1,n2</span>)=&gt;</span>n1+n2;</span><br><span class="line"><span class="comment">//第一个add是导出的名字   第二个add是const声明的add</span></span><br><span class="line"><span class="built_in">exports</span> add=add;</span><br></pre></td></tr></table></figure><h4 id="b-js-导入"><a href="#b-js-导入" class="headerlink" title="b.js 导入"></a>b.js 导入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//require负责接收</span></span><br><span class="line"><span class="keyword">const</span> a= <span class="built_in">require</span>(<span class="string">&#x27;b.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.add(<span class="number">10</span>,<span class="number">20</span>));</span><br></pre></td></tr></table></figure><p><img src="https://s3.ax1x.com/2020/11/15/DFRE38.png" alt="我是图片"></p><h5 id="注：require-‘b-js’-的后缀名可以省略"><a href="#注：require-‘b-js’-的后缀名可以省略" class="headerlink" title="注：require(‘b.js’);的后缀名可以省略"></a>注：require(‘b.js’);的后缀名可以省略</h5><h2 id="模块成员导出的另一种方式"><a href="#模块成员导出的另一种方式" class="headerlink" title="模块成员导出的另一种方式"></a>模块成员导出的另一种方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.version = version;</span><br><span class="line"><span class="built_in">module</span>.exports.sayHi = sayHi;</span><br></pre></td></tr></table></figure><p>exports是module.exports的别名(地址引用关系)，当exports和module.exports对象指向的不是同一个对象时，导出对象最终以module.exports为准</p><h1 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h1><h2 id="什么是系统模块"><a href="#什么是系统模块" class="headerlink" title="什么是系统模块"></a>什么是系统模块</h2><p>Node运行环境提供的API. 因为这些API都是以模块化的方式进行开发的, 所以我们又称Node运行环境提供的API为系统模块<br><img src="https://s3.ax1x.com/2020/11/15/DFWJit.png" alt="我是图片"></p><h3 id="系统模块fs-文件操作"><a href="#系统模块fs-文件操作" class="headerlink" title="系统模块fs 文件操作"></a>系统模块fs 文件操作</h3><p>f：file 文件 ，s：system 系统，文件操作系统。</p><h4 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//callback 是回调函数</span></span><br><span class="line">fs.reaFile(<span class="string">&#x27;文件路径/文件名称&#x27;</span>[,<span class="string">&#x27;文件编码&#x27;</span>], callback);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取上级css目录下的base.css</span></span><br><span class="line">fs.reaFile(<span class="string">&#x27;../css/base.css&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//如果文件读取发生错误 参数err的值为错误对象 否则err的值为null</span></span><br><span class="line">    <span class="comment">//doc参数为文件内容</span></span><br><span class="line">   <span class="keyword">if</span> (err = <span class="literal">null</span>) &#123; </span><br><span class="line">       <span class="comment">//在控制台输出文件内容</span></span><br><span class="line">       <span class="built_in">console</span>.log(doc);</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h4 id="写入文件内容"><a href="#写入文件内容" class="headerlink" title="写入文件内容"></a>写入文件内容</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(<span class="string">&#x27;文件路径/文件名称&#x27;</span>, <span class="string">&#x27;数据&#x27;</span>, callback);</span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;&lt;h3&gt;正在使用fs.writeFile写入文件内容&lt;/h3&gt;&#x27;</span>;</span><br><span class="line"> fs.writeFile(<span class="string">&#x27;../index.html&#x27;</span>, content, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (err != <span class="literal">null</span>) &#123; </span><br><span class="line">       <span class="built_in">console</span>.log(err);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;文件写入成功&#x27;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="系统模块path-路径操作"><a href="#系统模块path-路径操作" class="headerlink" title="系统模块path 路径操作"></a>系统模块path 路径操作</h3><p> 为什么要进行路径拼接 </p><ul><li>不同操作系统的路径分隔符不统一</li><li>/public/uploads/avatar</li><li>Windows 上是 \   /</li><li>Linux 上是 /<h4 id="路径拼接语法"><a href="#路径拼接语法" class="headerlink" title="路径拼接语法"></a>路径拼接语法</h4></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">&#x27;路径&#x27;</span>, <span class="string">&#x27;路径&#x27;</span>, ...)</span><br><span class="line"><span class="comment">// 导入path模块</span></span><br><span class="line"> <span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line">  <span class="comment">// 路径拼接</span></span><br><span class="line"> <span class="keyword">let</span> finialPath = path.join(<span class="string">&#x27;itcast&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c.css&#x27;</span>);</span><br><span class="line">  <span class="comment">// 输出结果 itcast\a\b\c.css</span></span><br><span class="line"> <span class="built_in">console</span>.log(finialPath);</span><br></pre></td></tr></table></figure><h4 id="相对路径VS绝对路径"><a href="#相对路径VS绝对路径" class="headerlink" title="相对路径VS绝对路径"></a>相对路径VS绝对路径</h4><ul><li>大多数情况下使用绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录</li><li>在读取文件或者设置文件路径时都会选择绝对路径</li><li>使用__dirname获取当前文件所在的绝对路径</li></ul><h1 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h1><h2 id="什么是第三方模块"><a href="#什么是第三方模块" class="headerlink" title="什么是第三方模块"></a>什么是第三方模块</h2><p>别人写好的、具有特定功能的、我们能直接使用的模块即第三方模块，由于第三方模块通常都是由多个文件组成并且被放置在一个文件夹中，所以又名包。</p><h2 id="第三方模块有两种存在形式："><a href="#第三方模块有两种存在形式：" class="headerlink" title="第三方模块有两种存在形式："></a>第三方模块有两种存在形式：</h2><ul><li>以js文件的形式存在，提供实现项目具体功能的API接口。</li><li>以命令行工具形式存在，辅助项目开发</li></ul><h2 id="获取第三方模块"><a href="#获取第三方模块" class="headerlink" title="获取第三方模块"></a>获取第三方模块</h2><p><img src="https://s3.ax1x.com/2020/11/15/DFhjIA.png" alt="我是图片"><br>npmjs.com：第三方模块的存储和分发仓库</p><p>npm (node package manager) ： node的第三方模块管理工具</p><ul><li>下载：npm install 模块名称</li><li>卸载：npm unintall package 模块名称</li></ul><p>全局安装与本地安装</p><ul><li>命令行工具：全局安装</li><li>库文件：本地安装</li></ul><h2 id="第三方模块-nodemon"><a href="#第三方模块-nodemon" class="headerlink" title="第三方模块 nodemon"></a>第三方模块 nodemon</h2><p>nodemon是一个命令行工具，用以辅助项目开发。<br>在Node.js中，每次修改文件都要在命令行工具中重新执行该文件，非常繁琐。</p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li>使用npm install nodemon –g 下载它</li><li>在命令行工具中用nodemon命令替代node命令执行文件</li></ul><p><img src="https://s3.ax1x.com/2020/11/15/DF4qS0.png" alt="我是图片"></p><h2 id="第三方模块-nrm"><a href="#第三方模块-nrm" class="headerlink" title="第三方模块 nrm"></a>第三方模块 nrm</h2><p>nrm ( npm registry manager )：npm下载地址切换工具</p><p>npm默认的下载地址在国外，国内下载速度慢</p><h4 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li>使用npm install nrm –g 下载它</li><li>查询可用下载地址列表 nrm ls</li><li>切换npm下载地址 nrm use 下载地址名称<br><img src="https://s3.ax1x.com/2020/11/15/DF5nkd.png" alt="我是图片"></li></ul><h2 id="node-modules文件夹的问题"><a href="#node-modules文件夹的问题" class="headerlink" title="node_modules文件夹的问题"></a>node_modules文件夹的问题</h2><ul><li>文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候,，传输速度会很慢很慢. </li><li>复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错</li></ul><h2 id="package-json文件的作用"><a href="#package-json文件的作用" class="headerlink" title="package.json文件的作用"></a>package.json文件的作用</h2><p>项目描述文件，记录了当前项目信息<br>例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。<br>使用npm init -y命令生成。</p><h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;^3.3.1“</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"> &#125; </span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><ul><li>在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖</li><li>使用npm install 包名命令下载的文件会默认被添加到 package.json 文件的 dependencies 字段中</li></ul><h2 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;gulp&quot;</span>: <span class="string">&quot;^3.9.1“</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"> &#125; </span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><ul><li>在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖</li><li>使用npm install 包名 –save-dev命令将包添加到package.json文件的devDependencies字段中</li></ul><h2 id="package-lock-json文件的作用"><a href="#package-lock-json文件的作用" class="headerlink" title="package-lock.json文件的作用"></a>package-lock.json文件的作用</h2><ul><li>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</li><li>加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</li></ul><h2 id="模块查找规则-当模块拥有路径但没有后缀时"><a href="#模块查找规则-当模块拥有路径但没有后缀时" class="headerlink" title="模块查找规则-当模块拥有路径但没有后缀时"></a>模块查找规则-当模块拥有路径但没有后缀时</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./find.js&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./find&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>require方法根据模块路径查找模块，如果是完整路径，直接引入模块。</li><li>如果模块后缀省略，先找同名JS文件再找同名JS文件夹</li><li>如果找到了同名文件夹，找文件夹中的index.js</li><li>如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件</li><li>如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</li></ul><h2 id="模块查找规则-当模块没有路径且没有后缀时"><a href="#模块查找规则-当模块没有路径且没有后缀时" class="headerlink" title="模块查找规则-当模块没有路径且没有后缀时"></a>模块查找规则-当模块没有路径且没有后缀时</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./find&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>Node.js会假设它是系统模块</li><li>Node.js会去node_modules文件夹中</li><li>首先看是否有该名字的JS文件</li><li>再看是否有该名字的文件夹</li><li>如果是文件夹看里面是否有index.js</li><li>如果没有index.js查看该文件夹中的package.json中的main选项确定模块入口文件</li><li>否则找不到报错</li></ul><h2 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h2><p>访问    localhost:3000<br>执行命令 nodemon app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于创建网站服务器的模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// app对象就是网站服务器对象</span></span><br><span class="line"><span class="keyword">const</span> app = http.createServer();</span><br><span class="line"><span class="comment">// 当客户端有请求来的时候</span></span><br><span class="line">app.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">     res.end(<span class="string">&#x27;&lt;h2&gt;欢迎来到首页&lt;/h2&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;网站服务器启动成功&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><p>概念：超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）<br>规定了如何从网站服务器传输超文本到本地浏览器，它基于客户端服务器架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准。</p><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式。</p><p><img src="https://s3.ax1x.com/2020/11/17/DZyWEd.png"></p><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>1.请求方式 （Request Method）</p><ul><li>GET     请求数据</li><li>POST   发送数据</li></ul><p>method 里面是什么请求方式  请求之后就返回请求方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">method: 指定当前表单提交的方式</span></span><br><span class="line"><span class="comment">action: 指定当前表单提交的地址</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于创建网站服务器的模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// app对象就是网站服务器对象</span></span><br><span class="line"><span class="keyword">const</span> app = http.createServer();</span><br><span class="line"><span class="comment">// 当客户端有请求来的时候</span></span><br><span class="line">app.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (req.method == <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">res.end(<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.method == <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">res.end(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;网站服务器启动成功&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><p>2.请求地址 （Request URL</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">     req.headers  <span class="comment">// 获取请求报文</span></span><br><span class="line">     req.url      <span class="comment">// 获取请求地址</span></span><br><span class="line">     req.method   <span class="comment">// 获取请求方法</span></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于创建网站服务器的模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// app对象就是网站服务器对象</span></span><br><span class="line"><span class="keyword">const</span> app = http.createServer();</span><br><span class="line"><span class="comment">// 解决乱码</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line"><span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf8&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 当客户端有请求来的时候</span></span><br><span class="line"><span class="keyword">if</span> (req.url==<span class="string">&#x27;/index&#x27;</span>||req.url==<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果用户访问的是首页  返回</span></span><br><span class="line">res.end(<span class="string">&#x27;&lt;h2&gt;欢迎来到首页&lt;/h2&gt;&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pathname == <span class="string">&#x27;/list&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果用户访问的是list  返回</span></span><br><span class="line">res.end(<span class="string">&#x27;welcome to listpage&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果用户访问的是其他  返回</span></span><br><span class="line">res.end(<span class="string">&#x27;not found&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;网站服务器启动成功&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><ul><li>200 请求成功</li><li>404 请求的资源没有被找到</li><li>500 服务器端错误</li><li>400 客户端请求有语法错误</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 设置响应报文</span></span><br><span class="line">     res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf8‘</span></span><br><span class="line"><span class="string">     &#125;);</span></span><br><span class="line"><span class="string"> &#125;);</span></span><br></pre></td></tr></table></figure><h3 id="内容类型"><a href="#内容类型" class="headerlink" title="内容类型"></a>内容类型</h3><ul><li>text/html</li><li>text/css</li><li>application/javascript</li><li>image/jpeg</li><li>application/json</li></ul><h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><p>客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。</p><h3 id="GET请求参数"><a href="#GET请求参数" class="headerlink" title="GET请求参数"></a>GET请求参数</h3><ul><li>参数被放置在浏览器地址栏中，例如：<a href="http://localhost:3000/?name=zhangsan&amp;age=20">http://localhost:3000/?name=zhangsan&amp;age=20</a></li><li>参数获取需要借助系统模块url，url模块用来处理url地址<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于处理url地址</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(req.url);</span><br><span class="line"><span class="comment">// 1) 要解析的url地址</span></span><br><span class="line"><span class="comment">// 2) 将查询参数解析成对象形式</span></span><br><span class="line"><span class="keyword">let</span> &#123; query, pathname &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(query.name)</span><br><span class="line"><span class="built_in">console</span>.log(query.age)</span><br><span class="line"><span class="keyword">if</span> (pathname == <span class="string">&#x27;/index&#x27;</span> || pathname == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">res.end(<span class="string">&#x27;&lt;h2&gt;欢迎来到首页&lt;/h2&gt;&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pathname == <span class="string">&#x27;/list&#x27;</span>) &#123;</span><br><span class="line">res.end(<span class="string">&#x27;welcome to listpage&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">res.end(<span class="string">&#x27;not found&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>parse 方法可以处理url地址  可以把url处理成一个对象形式 在对象里保存了url里的各个部分 查询参数依旧是字符串类型的<br>加第二个参数true转换成对象类型<br>我们就可返的对象.上name和age去就可以获取到参数的值<br>query  查询参数</li></ul><h3 id="POST请求参数"><a href="#POST请求参数" class="headerlink" title="POST请求参数"></a>POST请求参数</h3><p>参数被放置在请求体中进行传输<br>获取POST参数需要使用data事件和end事件<br>使用querystring系统模块将参数转换为对象格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入系统模块querystring 用于将HTTP参数转换为对象格式</span></span><br><span class="line"> <span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> app.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 声明一个变量  接受post参数</span></span><br><span class="line">     <span class="keyword">let</span> postData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 监听参数传输事件  当触发date的时候和postData进行拼接 chunk就是传递过来值的参数</span></span><br><span class="line">     req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> postData += chunk;);</span><br><span class="line">     <span class="comment">// 监听参数传输完毕事件会出发end 我们用querystring.parse做了格式的处理 最后吧结果postData输出</span></span><br><span class="line">     req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">         <span class="built_in">console</span>.log(querystring.parse(postData)); </span><br><span class="line">     &#125;); </span><br><span class="line"> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul><li><a href="http://localhost:3000/index">http://localhost:3000/index</a></li><li><a href="http://localhost:3000/login">http://localhost:3000/login</a></li></ul><p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</p><p><img src="https://s3.ax1x.com/2020/11/17/DZITBt.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当客户端发来请求的时候</span></span><br><span class="line"> app.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 获取客户端的请求路径</span></span><br><span class="line">     <span class="keyword">let</span> &#123; pathname &#125; = url.parse(req.url);</span><br><span class="line">     <span class="keyword">if</span> (pathname == <span class="string">&#x27;/&#x27;</span> || pathname == <span class="string">&#x27;/index&#x27;</span>) &#123;</span><br><span class="line">         res.end(<span class="string">&#x27;欢迎来到首页&#x27;</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname == <span class="string">&#x27;/list&#x27;</span>) &#123;</span><br><span class="line">         res.end(<span class="string">&#x27;欢迎来到列表页页&#x27;</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">&#x27;抱歉, 您访问的页面出游了&#x27;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如CSS、JavaScript、image文件<br><a href="http://www.itcast.cn/images/logo.png">http://www.itcast.cn/images/logo.png</a><br><img src="https://s3.ax1x.com/2020/11/17/DZTzT0.png"></p><h2 id="动态资源"><a href="#动态资源" class="headerlink" title="动态资源"></a>动态资源</h2><p>相同的请求地址不同的响应资源，这种资源就是动态资源<br><a href="http://www.itcast.cn/article?id=1">http://www.itcast.cn/article?id=1</a><br><a href="http://www.itcast.cn/article?id=2">http://www.itcast.cn/article?id=2</a><br><img src="https://s3.ax1x.com/2020/11/17/DZTXOs.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">&#x27;mime&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = http.createServer();</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 获取用户的请求路径</span></span><br><span class="line"><span class="keyword">let</span> pathname = url.parse(req.url).pathname;</span><br><span class="line"></span><br><span class="line">pathname = pathname == <span class="string">&#x27;/&#x27;</span> ? <span class="string">&#x27;/default.html&#x27;</span> : pathname;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将用户的请求路径转换为实际的服务器硬盘路径</span></span><br><span class="line"><span class="keyword">let</span> realPath = path.join(__dirname, <span class="string">&#x27;public&#x27;</span> + pathname);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> type = mime.getType(realPath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line">fs.readFile(realPath, <span class="function">(<span class="params">error, result</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 如果文件读取失败</span></span><br><span class="line"><span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;</span><br><span class="line">res.writeHead(<span class="number">404</span>, &#123;</span><br><span class="line"><span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf8&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">res.end(<span class="string">&#x27;文件读取失败&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line"><span class="string">&#x27;content-type&#x27;</span>: type</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">res.end(result);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;服务器启动成功&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="客户端请求途径"><a href="#客户端请求途径" class="headerlink" title="客户端请求途径"></a>客户端请求途径</h2><h3 id="GET方式"><a href="#GET方式" class="headerlink" title="GET方式"></a>GET方式</h3><ul><li>浏览器地址栏</li><li>link标签的href属性</li><li>script标签的src属性</li><li>img标签的src属性</li><li>Form表单提交</li></ul><h3 id="POST方式"><a href="#POST方式" class="headerlink" title="POST方式"></a>POST方式</h3><ul><li>Form表单提交</li></ul><h1 id="Node-js异步编程"><a href="#Node-js异步编程" class="headerlink" title="Node.js异步编程"></a>Node.js异步编程</h1><h2 id="同步API-异步API"><a href="#同步API-异步API" class="headerlink" title="同步API, 异步API"></a>同步API, 异步API</h2><p>同步API：只有当前API执行完成后，才能继续执行下一个API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;before&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;after&#x27;</span>);</span><br></pre></td></tr></table></figure><p>异步API：当前API的执行不会阻塞后续代码的执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;before&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(</span><br><span class="line">   () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;last&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;after&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">callback(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;callback函数被调用了&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMsg</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">callback(&#123;</span><br><span class="line">msg: <span class="string">&#x27;hello node.js&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMsg(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="同步API-异步API的区别（代码执行顺序"><a href="#同步API-异步API的区别（代码执行顺序" class="headerlink" title="同步API, 异步API的区别（代码执行顺序"></a>同步API, 异步API的区别（代码执行顺序</h2><p>同步API从上到下依次执行，前面代码会阻塞后面代码的执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;for循环后面的代码&#x27;</span>);</span><br></pre></td></tr></table></figure><p>异步API不会等待API执行完成后再向下执行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码开始执行&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;2秒后执行的代码&#x27;</span>)&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;&quot;0秒&quot;后执行的代码&#x27;</span>)&#125;, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码结束执行&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s3.ax1x.com/2020/11/17/DZx3jK.png"></p><h2 id="Node-js中的异步API"><a href="#Node-js中的异步API" class="headerlink" title="Node.js中的异步API"></a>Node.js中的异步API</h2><p>依次读取A文件、B文件、C文件</p><p>回调嵌套回调  俗称回调地狱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, result1</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(result1)</span><br><span class="line">fs.readFile(<span class="string">&#x27;./2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, result2</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(result2)</span><br><span class="line">fs.readFile(<span class="string">&#x27;./3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, result3</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(result3)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise出现的目的是解决Node.js异步编程中回调地狱的问题。</p><p>使用Promise依次读取A文件、B文件、C文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">fs.readFile(<span class="string">&#x27;./1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, result</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">fs.readFile(<span class="string">&#x27;./2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, result</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">fs.readFile(<span class="string">&#x27;./3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, result</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().then(<span class="function">(<span class="params">r1</span>)=&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(r1);</span><br><span class="line"><span class="keyword">return</span> p2();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">r2</span>)=&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(r2);</span><br><span class="line"><span class="keyword">return</span> p3();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">r3</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(r3)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><p>异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="async关键字"><a href="#async关键字" class="headerlink" title="async关键字"></a>async关键字</h3><ol><li>普通函数定义前加async关键字 普通函数变成异步函数</li><li>异步函数默认返回promise对象</li><li>在异步函数内部使用return关键字进行结果返回 结果会被包裹的promise对象中 return关键字代替了resolve方法</li><li>在异步函数内部使用throw关键字抛出程序异常</li><li>调用异步函数再链式调用then方法获取异步函数执行结果</li><li>调用异步函数再链式调用catch方法获取异步函数执行的错误信息</li></ol><h3 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h3><ol><li>await关键字只能出现在异步函数中</li><li>await promise await后面只能写promise对象 写其他类型的API是不不可以的</li><li>await关键字可是暂停异步函数向下执行 直到promise返回结果</li></ol><p>使用异步函数解决依次读取A文件、B文件、C文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;p1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;p2&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;p3&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">await</span> p1()</span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">await</span> p2()</span><br><span class="line"><span class="keyword">let</span> r3 = <span class="keyword">await</span> p3()</span><br><span class="line"><span class="built_in">console</span>.log(r1)</span><br><span class="line"><span class="built_in">console</span>.log(r2)</span><br><span class="line"><span class="built_in">console</span>.log(r3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure><h2 id="异步函数在node-js中的使用"><a href="#异步函数在node-js中的使用" class="headerlink" title="异步函数在node.js中的使用"></a>异步函数在node.js中的使用</h2><p>在node.js中的使用使用异步函数解决依次读取A文件、B文件、C文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">// 改造现有异步函数api 让其返回promise对象 从而支持异步函数语法</span></span><br><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).promisify;</span><br><span class="line"><span class="comment">// 调用promisify方法改造现有异步API 让其返回promise对象</span></span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;./1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">await</span> readFile(<span class="string">&#x27;./2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> r3 = <span class="keyword">await</span> readFile(<span class="string">&#x27;./3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r1)</span><br><span class="line"><span class="built_in">console</span>.log(r2)</span><br><span class="line"><span class="built_in">console</span>.log(r3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Node.js</summary>
    
    
    
    <category term="Node.js" scheme="http://example.com/categories/Node-js/"/>
    
    
    <category term="Node.js" scheme="http://example.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之BOM</title>
    <link href="http://example.com/2020/11/03/%E7%BA%A2%E5%AE%9D%E4%B9%A614/"/>
    <id>http://example.com/2020/11/03/%E7%BA%A2%E5%AE%9D%E4%B9%A614/</id>
    <published>2020-11-03T05:06:43.000Z</published>
    <updated>2020-11-09T12:26:06.670Z</updated>
    
    
    <summary type="html">BOM</summary>
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="BOM" scheme="http://example.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之类与面向对象编程</title>
    <link href="http://example.com/2020/11/02/%E7%BA%A2%E5%AE%9D%E4%B9%A613/"/>
    <id>http://example.com/2020/11/02/%E7%BA%A2%E5%AE%9D%E4%B9%A613/</id>
    <published>2020-11-02T05:06:43.000Z</published>
    <updated>2020-11-09T12:26:28.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pn = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">pn.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">pn.age = <span class="number">29</span>;</span><br><span class="line">pn.job = <span class="string">&quot;web&quot;</span>;</span><br><span class="line">pn.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> pn = &#123;</span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> age: <span class="number">29</span>,</span><br><span class="line"> job: <span class="string">&quot;web&quot;</span>,</span><br><span class="line"> sayName() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h2><p>属性分两种：数据属性和访问器属性。</p><h3 id="1-数据属性"><a href="#1-数据属性" class="headerlink" title="1. 数据属性"></a>1. 数据属性</h3><p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4个特性描述它们的行为。</p><ul><li><p>[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。</p></li><li><p>[[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。</p></li><li><p>[[Writable]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。</p></li><li><p>[[Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为 undefined。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>一个名为 name 的属性，并给它赋予了一个值”Nicholas”。这意味着[[Value]]特性会被设置为”Nicholas”，之后对这个值的任何修改都会保存这个位置。</p><h4 id="要修改属性的默认特性，就必须使用-Object-defineProperty-方法。这个方法接收-3-个参数："><a href="#要修改属性的默认特性，就必须使用-Object-defineProperty-方法。这个方法接收-3-个参数：" class="headerlink" title="要修改属性的默认特性，就必须使用 Object.defineProperty()方法。这个方法接收 3 个参数："></a>要修改属性的默认特性，就必须使用 Object.defineProperty()方法。这个方法接收 3 个参数：</h4><p>要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包<br>含：configurable、enumerable、writable 和 value，跟相关特性的名称一一对应。根据要修改<br>的特性，可以设置其中一个或多个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line"> writable: <span class="literal">false</span>,</span><br><span class="line"> value: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line">person.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot; </span></span><br></pre></td></tr></table></figure><p>一个名为 name 的属性并给它赋予了一个只读的值”Nicholas”。这个属性的值就不能再修改了，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。</p><h4 id="在调用-Object-defineProperty-时，configurable、enumerable-和-writable-的值"><a href="#在调用-Object-defineProperty-时，configurable、enumerable-和-writable-的值" class="headerlink" title="在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值"></a>在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值</h4><p>如果不指定，则都默认为 false。多数情况下，可能都不需要 Object.defineProperty()提供的这些强大的设置，但要理解 JavaScript 对象，就要理解这些概念。</p><h3 id="2-访问器属性"><a href="#2-访问器属性" class="headerlink" title="2. 访问器属性"></a>2. 访问器属性</h3><p>访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。</p><ul><li><p>[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</p></li><li><p>[[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</p></li><li><p>[[Get]]：获取函数，在读取属性时调用。默认值为 undefined。</p></li><li><p>[[Set]]：设置函数，在写入属性时调用。默认值为 undefined。<br>访问器属性是不能直接定义的，必须使用 Object.defineProperty()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象，包含伪私有成员 year_和公共成员 edition</span></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line"> year_: <span class="number">2017</span>,</span><br><span class="line"> edition: <span class="number">1</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line"> get() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line"> &#125;,</span><br><span class="line"> set(newValue) &#123;</span><br><span class="line"> <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line"> <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line"> <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2018</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.edition); <span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><p>对象 book 有两个默认属性：year_和 edition。<br>year_中的下划线常用来表示该属性并不希望在对象方法的外部被访问。另一个属性 year 被定义为一个访问器属性，其中获取函数简单地返回 year_的值，而设置函数会做一些计算以决定正确的版本（edition）。因此，把 year 属性修改为 2018 会导致 year_变成 2018，edition 变成 2。这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。</p></li><li><p>ECMAScript 5以前，开发者会使用两个非标准的访问创建访问器属性：<strong>defineGetter</strong>()和<strong>defineSetter</strong>()。这两个方法最早是 Firefox 引入的，后来 Safari、Chrome 和 Opera 也实现了。</p></li></ul><h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>为此，ECMAScript 提供了 Object.defineProperties()方法。<br>这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line"> year_: &#123;</span><br><span class="line"> value: <span class="number">2017</span></span><br><span class="line"> &#125;,</span><br><span class="line"> edition: &#123;</span><br><span class="line"> value: <span class="number">1</span></span><br><span class="line"> &#125;,</span><br><span class="line"> year: &#123;</span><br><span class="line"> get() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line"> &#125;, </span><br><span class="line">set(newValue) &#123;</span><br><span class="line"> <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line"> <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line"> <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码在 book 对象上定义了两个数据属性 year_和 edition，还有一个访问器属性 year。最终的对象跟上一节示例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的configurable、enumerable 和 writable 特性值都是 false。</p><h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>Object.getOwnPropertyDescriptor()<br>这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable、enumerable、get 和 set 属性，对于数据属性包含 configurable、enumerable、writable 和 value 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line"> year_: &#123;</span><br><span class="line"> value: <span class="number">2017</span></span><br><span class="line"> &#125;,</span><br><span class="line"> edition: &#123;</span><br><span class="line"> value: <span class="number">1</span></span><br><span class="line"> &#125;,</span><br><span class="line"> year: &#123;</span><br><span class="line"> get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line"> &#125;,</span><br><span class="line"> set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line"> <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line"> <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year_&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// 2017</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get); <span class="comment">// &quot;function&quot; </span></span><br></pre></td></tr></table></figure><p>ECMAScript 2017 新增了 Object.getOwnPropertyDescriptors()静态方法。这个方法实际上会在每个自有属性上调用 Object.getOwnPropertyDescriptor()并在一个新对象中返回它们。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line"> year_: &#123;</span><br><span class="line"> value: <span class="number">2017</span></span><br><span class="line"> &#125;,</span><br><span class="line"> edition: &#123;</span><br><span class="line"> value: <span class="number">1</span></span><br><span class="line"> &#125;,</span><br><span class="line"> year: &#123;</span><br><span class="line"> get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line"> &#125;,</span><br><span class="line"> set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line"> <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line"> <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(book));</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// edition: &#123;</span></span><br><span class="line"><span class="comment">// configurable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// value: 1,</span></span><br><span class="line"><span class="comment">// writable: false</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"><span class="comment">// year: &#123;</span></span><br><span class="line"><span class="comment">// configurable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// get: f(),</span></span><br><span class="line"><span class="comment">// set: f(newValue),</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"><span class="comment">// year_: &#123;</span></span><br><span class="line"><span class="comment">// configurable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// value: 2017,</span></span><br><span class="line"><span class="comment">// writable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><h2 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h2><h3 id="ECMAScript-6-专门为合并对象提供了-Object-assign-方法。"><a href="#ECMAScript-6-专门为合并对象提供了-Object-assign-方法。" class="headerlink" title="ECMAScript 6 专门为合并对象提供了 Object.assign()方法。"></a>ECMAScript 6 专门为合并对象提供了 Object.assign()方法。</h3><p>这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true）和自有（Object.hasOwnProperty()返回 true）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123; <span class="attr">id</span>: <span class="string">&#x27;src&#x27;</span> &#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// Object.assign 修改目标对象</span></span><br><span class="line"><span class="comment">// 也会返回修改后的目标对象</span></span><br><span class="line"><span class="built_in">console</span>.log(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(dest !== src); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; id: src &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; id: src &#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; a: foo, b: bar &#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取函数与设置函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;</span><br><span class="line"> <span class="keyword">set</span> <span class="title">a</span>(<span class="params">val</span>) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`Invoked dest setter with param <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">src = &#123;</span><br><span class="line"> <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;Invoked src getter&#x27;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// 调用 src 的获取方法</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数&quot;foo&quot;</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作</span></span><br><span class="line"><span class="comment">// 所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; set a(val) &#123;...&#125; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 覆盖属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123; <span class="attr">id</span>: <span class="string">&#x27;dest&#x27;</span> &#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;src1&#x27;</span>, <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;src2&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// Object.assign 会覆盖重复的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; id: src2, a: foo, b: bar &#125;</span></span><br><span class="line"><span class="comment">// 可以通过目标对象上的设置函数观察到覆盖的过程：</span></span><br><span class="line">dest = &#123;</span><br><span class="line"> <span class="keyword">set</span> <span class="title">id</span>(<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(x);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;first&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;second&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;third&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123; <span class="attr">a</span>: &#123;&#125; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; a :&#123;&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(dest.a === src.a); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>如果赋值期间出错，则操作会中止并退出，同时抛出错误。Object.assign()没有“回滚”之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123;</span><br><span class="line"> a: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line"> <span class="keyword">get</span> <span class="title">b</span>() &#123;</span><br><span class="line"> <span class="comment">// Object.assign()在调用这个获取函数时会抛出错误</span></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"> &#125;, </span><br><span class="line"> c: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="comment">// Object.assign()没办法回滚已经完成的修改</span></span><br><span class="line"><span class="comment">// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; a: foo &#125; </span></span><br></pre></td></tr></table></figure><h2 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些是===符合预期的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> === <span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; === &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span> === <span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-0</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><h2 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h2><h3 id="1-属性值简写"><a href="#1-属性值简写" class="headerlink" title="1. 属性值简写"></a>1. 属性值简写</h3><p>在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: name</span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27; &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27; &#125; </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-可计算属性"><a href="#2-可计算属性" class="headerlink" title="2. 可计算属性"></a>2. 可计算属性</h3><p>在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&#x27;job&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[nameKey] = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">person[ageKey] = <span class="number">27</span>;</span><br><span class="line">person[jobKey] = <span class="string">&#x27;Software engineer&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#x27;Software engineer&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时<br>将其作为 JavaScript 表达式而不是字符串来求值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&#x27;job&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> [nameKey]: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> [ageKey]: <span class="number">27</span>,</span><br><span class="line"> [jobKey]: <span class="string">&#x27;Software engineer&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#x27;Software engineer&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>因为被当作 JavaScript 表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&#x27;job&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> uniqueToken = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueKey</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>_<span class="subst">$&#123;uniqueToken++&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> [getUniqueKey(nameKey)]: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> [getUniqueKey(ageKey)]: <span class="number">27</span>,</span><br><span class="line"> [getUniqueKey(jobKey)]: <span class="string">&#x27;Software engineer&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name_0: &#x27;Matt&#x27;, age_1: 27, job_2: &#x27;Software engineer&#x27; &#125; </span></span><br></pre></td></tr></table></figure><h3 id="3-简写方法名"><a href="#3-简写方法名" class="headerlink" title="3. 简写方法名"></a>3. 简写方法名</h3><p>在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> sayName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.sayName(<span class="string">&#x27;Matt&#x27;</span>); <span class="comment">// My name is Matt </span></span><br></pre></td></tr></table></figure><p>新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名（不过给作为方法的函数<br>命名通常没什么用）。相应地，这样也可以明显缩短方法声明。<br>以下代码和之前的代码在行为上是等价的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> sayName(name) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.sayName(<span class="string">&#x27;Matt&#x27;</span>); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure><p>简写方法名对获取函数和设置函数也是适用的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name_: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.name_;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="keyword">set</span> <span class="title">name</span>(<span class="params">name</span>) &#123;</span><br><span class="line"> <span class="built_in">this</span>.name_ = name;</span><br><span class="line"> &#125;,</span><br><span class="line"> sayName() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name_&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">person.sayName(); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure><p>简写方法名与可计算属性键相互兼容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methodKey = <span class="string">&#x27;sayName&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> [methodKey](name) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayName(<span class="string">&#x27;Matt&#x27;</span>); <span class="comment">// My name is Matt </span></span><br></pre></td></tr></table></figure><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构就是使用与对象匹配的结构来实现对象属性赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用对象解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> age: <span class="number">27</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> personName = person.name,</span><br><span class="line"> personAge = person.age;</span><br><span class="line"><span class="built_in">console</span>.log(personName); <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(personAge); <span class="comment">// 27</span></span><br><span class="line">然后，是使用对象解构的：</span><br><span class="line"><span class="comment">// 使用对象解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(personName); <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(personAge); <span class="comment">// 27 </span></span><br></pre></td></tr></table></figure><p>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 27 </span></span><br></pre></td></tr></table></figure><p>解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, job &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(job); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, job=<span class="string">&#x27;Software engineer&#x27;</span> &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(job); <span class="comment">// Software engineer </span></span><br></pre></td></tr></table></figure><p>解构在内部使用函数 ToObject()（不能在运行时环境中直接访问）把源数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据 ToObject()的定义），null和 undefined 不能被解构，否则会抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; length &#125; = <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(length); <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">constructor</span>: c &#125; = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line">解构并不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中：</span><br><span class="line">~~~JavaScript</span><br><span class="line"><span class="keyword">let</span> personName, personAge;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line">(&#123;<span class="attr">name</span>: personName, <span class="attr">age</span>: personAge&#125; = person);</span><br><span class="line"><span class="built_in">console</span>.log(personName, personAge); <span class="comment">// Matt, 27 </span></span><br></pre></td></tr></table></figure><h3 id="1-嵌套解构"><a href="#1-嵌套解构" class="headerlink" title="1. 嵌套解构"></a>1. 嵌套解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> age: <span class="number">27</span>,</span><br><span class="line"> job: &#123;</span><br><span class="line"> title: <span class="string">&#x27;Software engineer&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;;</span><br><span class="line">(&#123;</span><br><span class="line"> name: personCopy.name,</span><br><span class="line"> age: personCopy.age,</span><br><span class="line"> job: personCopy.job</span><br><span class="line">&#125; = person);</span><br><span class="line"><span class="comment">// 因为一个对象的引用被赋值给 personCopy，所以修改</span></span><br><span class="line"><span class="comment">// person.job 对象的属性也会影响 personCopy</span></span><br><span class="line">person.job.title = <span class="string">&#x27;Hacker&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(personCopy);</span><br><span class="line"><span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125; </span></span><br></pre></td></tr></table></figure><p>解构赋值可以使用嵌套结构，以匹配嵌套的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> age: <span class="number">27</span>,</span><br><span class="line"> job: &#123;</span><br><span class="line"> title: <span class="string">&#x27;Software engineer&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明 title 变量并将 person.job.title 的值赋给它</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">job</span>: &#123; title &#125; &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(title); <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure><p>在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> job: &#123;</span><br><span class="line"> title: <span class="string">&#x27;Software engineer&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;;</span><br><span class="line"><span class="comment">// foo 在源对象上是 undefined</span></span><br><span class="line">(&#123;</span><br><span class="line"> foo: &#123;</span><br><span class="line"> bar: personCopy.bar</span><br><span class="line"> &#125;</span><br><span class="line">&#125; = person);</span><br><span class="line"><span class="comment">// TypeError: Cannot destructure property &#x27;bar&#x27; of &#x27;undefined&#x27; or &#x27;null&#x27;.</span></span><br><span class="line"><span class="comment">// job 在目标对象上是 undefined</span></span><br><span class="line">(&#123;</span><br><span class="line"> job: &#123;</span><br><span class="line"> title: personCopy.job.title</span><br><span class="line"> &#125;</span><br><span class="line">&#125; = person);</span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;title&#x27; of undefined </span></span><br></pre></td></tr></table></figure><h3 id="2-部分解构"><a href="#2-部分解构" class="headerlink" title="2. 部分解构"></a>2. 部分解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personName, personBar, personAge;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// person.foo 是 undefined，因此会抛出错误</span></span><br><span class="line"> (&#123;<span class="attr">name</span>: personName, <span class="attr">foo</span>: &#123; <span class="attr">bar</span>: personBar &#125;, <span class="attr">age</span>: personAge&#125; = person);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(personName, personBar, personAge);</span><br><span class="line"><span class="comment">// Matt, undefined, undefined </span></span><br></pre></td></tr></table></figure><h3 id="3-参数上下文匹配"><a href="#3-参数上下文匹配" class="headerlink" title="3. 参数上下文匹配"></a>3. 参数上下文匹配</h3><p>在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响 arguments 对象，但可以在函数签名中声明在函数体内使用局部变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line"> age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson</span>(<span class="params">foo, &#123;name, age&#125;, bar</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson2</span>(<span class="params">foo, &#123;name: personName, age: personAge&#125;, bar</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(personName, personAge);</span><br><span class="line">&#125;</span><br><span class="line">printPerson(<span class="string">&#x27;1st&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>);</span><br><span class="line"><span class="comment">// [&#x27;1st&#x27;, &#123; name: &#x27;Matt&#x27;, age: 27 &#125;, &#x27;2nd&#x27;]</span></span><br><span class="line"><span class="comment">// &#x27;Matt&#x27;, 27</span></span><br><span class="line">printPerson2(<span class="string">&#x27;1st&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>);</span><br><span class="line"><span class="comment">// [&#x27;1st&#x27;, &#123; name: &#x27;Matt&#x27;, age: 27 &#125;, &#x27;2nd&#x27;]</span></span><br><span class="line"><span class="comment">// &#x27;Matt&#x27;, 27</span></span><br></pre></td></tr></table></figure><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>虽然使用 Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ECMAScript 6 开始正式支持类和继承。ES6 的类旨在完全涵盖之前规范设计的基于原型的继承模式。不过，无论从哪方面看，ES6 的类都仅仅是封装了 ES5.1 构造函数加原型继承的语法糖而已。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> o.name = name;</span><br><span class="line"> o.age = age;</span><br><span class="line"> o.job = job;</span><br><span class="line"> o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br></pre></td></tr></table></figure><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line"> <span class="built_in">this</span>.job = job;</span><br><span class="line"> <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line">person1.sayName(); <span class="comment">// Nicholas</span></span><br><span class="line">person2.sayName(); <span class="comment">// Greg </span></span><br></pre></td></tr></table></figure><h4 id="要创建对象的实例，应使用-new-操作符。"><a href="#要创建对象的实例，应使用-new-操作符。" class="headerlink" title="要创建对象的实例，应使用 new 操作符。"></a>要创建对象的实例，应使用 new 操作符。</h4><ul><li>在内存中创建一个新对象。</li><li>这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。</li><li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。<h3 id="1-构造函数也是函数"><a href="#1-构造函数也是函数" class="headerlink" title="1. 构造函数也是函数"></a>1. 构造函数也是函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为构造函数</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line">person.sayName(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="comment">// 作为函数调用</span></span><br><span class="line">Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); <span class="comment">// 添加到 window 对象</span></span><br><span class="line"><span class="built_in">window</span>.sayName(); <span class="comment">// &quot;Greg&quot;</span></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">&quot;Kristen&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Nurse&quot;</span>);</span><br><span class="line">o.sayName(); <span class="comment">// &quot;Kristen&quot; </span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-构造函数的问题"><a href="#2-构造函数的问题" class="headerlink" title="2. 构造函数的问题"></a>2. 构造函数的问题</h3><p>构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方法不是同一个 Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会初始化一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line"> <span class="built_in">this</span>.job = job;</span><br><span class="line"> <span class="built_in">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;console.log(this.name)&quot;</span>); <span class="comment">// 逻辑等价</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样理解这个构造函数可以更清楚地知道，每个 Person 实例都会有自己的 Function 实例用于显示 name 属性。当然了，以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新 Function实例的机制是一样的。因此不同实例上的函数虽然同名却不相等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>因为都是做一样的事，所以没必要定义两个不同的 Function 实例。况且，this 对象可以把函数与对象的绑定推迟到运行时。</p><p>要解决这个问题，可以把函数定义转移到构造函数外部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line"> <span class="built_in">this</span>.job = job;</span><br><span class="line"> <span class="built_in">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line">person1.sayName(); <span class="comment">// Nicholas</span></span><br><span class="line">person2.sayName(); <span class="comment">// Greg </span></span><br></pre></td></tr></table></figure><p>sayName()被定义在了构造函数外部。在构造函数内部，sayName 属性等于全局 sayName()函数。因为这一次 sayName 属性中包含的只是一个指向外部函数的指针，所以 person1 和 person2共享了定义在全局作用域上的 sayName()函数。这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>使用函数表达式也可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>所有属性和 sayName()方法都直接添加到了 Person 的 prototype 属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。因此 person1 和 person2 访问的都是相同的属性和相同的 sayName()函数。要理解这个过程，就必须理解 ECMAScript 中原型的本质。</p><h3 id="1-理解原型"><a href="#1-理解原型" class="headerlink" title="1. 理解原型"></a>1. 理解原型</h3><p>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。对前面的例子而言，Person.prototype.constructor 指向 Person。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。</p><p>在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构<br>造函数的原型对象。脚本中没有访问这个[[Prototype]]特性的标准方式，但 Firefox、Safari 和 Chrome会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性完全被隐藏了。关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数可以是函数表达式</span></span><br><span class="line"><span class="comment"> * 也可以是函数声明，因此以下两种形式都可以：</span></span><br><span class="line"><span class="comment"> * function Person() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * let Person = function() &#123;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明之后，构造函数就有了一个</span></span><br><span class="line"><span class="comment"> * 与之关联的原型对象：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// constructor: f Person(),</span></span><br><span class="line"><span class="comment">// __proto__: Object </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如前所述，构造函数有一个 prototype 属性</span></span><br><span class="line"><span class="comment"> * 引用其原型对象，而这个原型对象也有一个</span></span><br><span class="line"><span class="comment"> * constructor 属性，引用这个构造函数</span></span><br><span class="line"><span class="comment"> * 换句话说，两者循环引用：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正常的原型链都会终止于 Object 的原型对象</span></span><br><span class="line"><span class="comment"> * Object 原型的原型是 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// constructor: f Object(),</span></span><br><span class="line"><span class="comment">// toString: ...</span></span><br><span class="line"><span class="comment">// hasOwnProperty: ...</span></span><br><span class="line"><span class="comment">// isPrototypeOf: ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(),</span><br><span class="line"> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数、原型对象和实例</span></span><br><span class="line"><span class="comment"> * 是 3 个完全不同的对象：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 !== Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 !== Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype !== Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例通过__proto__链接到原型对象，</span></span><br><span class="line"><span class="comment"> * 它实际上指向隐藏特性[[Prototype]]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 构造函数通过 prototype 属性链接到原型对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实例与构造函数没有直接联系，与原型对象有直接联系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line">conosle.log(person1.__proto__.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同一个构造函数创建的两个实例</span></span><br><span class="line"><span class="comment"> * 共享同一个原型对象：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === person2.__proto__); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * instanceof 检查实例的原型链中</span></span><br><span class="line"><span class="comment"> * 是否包含指定构造函数的原型：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/11/09/BHHe4s.png" alt="我是图片"><br>Person 构造函数、Person 的原型对象和 Person 现有两个实例之间的关系。注意，Person.prototype 指向原型对象，而 Person.prototype.contructor 指回 Person 构造函数。原型对象包含 constructor 属性和其他后来添加的属性。Person 的两个实例 person1 和 person2 都只有一个内部属性指回 Person.prototype，而且两者都与构造函数没有直接联系。另外要注意，虽然这两个实例都没有属性和方法，但 person1.sayName()可以正常调用。这是由于对象属性查找机制的原因。</p><p>Object 类型还有一个 setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;</span><br><span class="line"> numLegs: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, biped);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><h4 id="警告-Object-setPrototypeOf-可能会严重影响代码性能。Mozilla-文档说得很清楚：“在所有浏览器和-JavaScript-引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行-Object-setPrototypeOf-语句那么简单，而是会涉及所有访问了那些修改过-Prototype-的对象的代码。”"><a href="#警告-Object-setPrototypeOf-可能会严重影响代码性能。Mozilla-文档说得很清楚：“在所有浏览器和-JavaScript-引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行-Object-setPrototypeOf-语句那么简单，而是会涉及所有访问了那些修改过-Prototype-的对象的代码。”" class="headerlink" title="警告 Object.setPrototypeOf()可能会严重影响代码性能。Mozilla 文档说得很清楚：“在所有浏览器和 JavaScript 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行 Object.setPrototypeOf()语句那么简单，而是会涉及所有访问了那些修改过[[Prototype]]的对象的代码。”"></a>警告 Object.setPrototypeOf()可能会严重影响代码性能。Mozilla 文档说得很清楚：“在所有浏览器和 JavaScript 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行 Object.setPrototypeOf()语句那么简单，而是会涉及所有访问了那些修改过[[Prototype]]的对象的代码。”</h4><p>为避免使用 Object.setPrototypeOf()可能造成的性能下降，可以通过 Object.create()来创建一个新对象，同时为其指定原型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;</span><br><span class="line"> numLegs: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(biped);</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><h3 id="2-原型层级"><a href="#2-原型层级" class="headerlink" title="2. 原型层级"></a>2. 原型层级</h3><p>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原<br>型对象，然后在原型对象上找到属性后，再返回对应的值。因此，在调用 person1.sayName()时，会发生两步搜索。首先，JavaScript 引擎会问：“person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“person1 的原型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上的这个函数。在调用 person2.sayName()时，会发生同样的搜索过程，而且也会返回相同的结果。这就是原型用于在多个对象实例间共享属性和方法的原理。<br>虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个<br>与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br></pre></td></tr></table></figure><p>person1 的 name 属性遮蔽了原型对象上的同名属性。虽然 person1.name 和person2.name 都返回了值，但前者返回的是”Greg”（来自实例），后者返回的是”Nicholas”（来自原型）。当 console.log()访问 person1.name 时，会先在实例上搜索个属性。因为这个属性在实例上存在，所以就不会再搜索原型对象了。而在访问 person2.name 时，并没有在实例上找到这个属性，所以会继续搜索原型对象并使用定义在原型上的属性。</p><p>只要给对象实例添加一个属性，这个属性就会遮蔽（shadow）原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为 null，也不会恢复它和原型的联系。不过，使用 delete 操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br></pre></td></tr></table></figure><p>这个修改后的例子中使用 delete 删除了 person1.name，这个属性之前以”Greg”遮蔽了原型上的同名属性。然后原型上 name 属性的联系就恢复了，因此再访问 person1.name 时，就会返回原型对象上这个属性的值。</p><p>hasOwnProperty()方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自 Object的，会在属性存在于调用它的对象实例上时返回 true，如下面的例子所示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>在这个例子中，通过调用 hasOwnProperty()能够清楚地看到访问的是实例属性还是原型属性。调用 person1.hasOwnProperty(“name”)只在重写 person1 上 name 属性的情况下才返回 true，表明此时 name 是一个实例属性<br><img src="https://s1.ax1x.com/2020/11/09/BHbsyV.png" alt="我是图片"></p><h4 id="注意-ECMAScript-的-Object-getOwnPropertyDescriptor-方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用-Object-getOwnPropertyDescriptor-。"><a href="#注意-ECMAScript-的-Object-getOwnPropertyDescriptor-方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用-Object-getOwnPropertyDescriptor-。" class="headerlink" title="注意 ECMAScript 的 Object.getOwnPropertyDescriptor()方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用 Object.getOwnPropertyDescriptor()。"></a>注意 ECMAScript 的 Object.getOwnPropertyDescriptor()方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用 Object.getOwnPropertyDescriptor()。</h4><h3 id="3-原型和-in-操作符"><a href="#3-原型和-in-操作符" class="headerlink" title="3. 原型和 in 操作符"></a>3. 原型和 in 操作符</h3><p>有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person2); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>在上面整个例子中，name 随时可以通过实例或通过原型访问到。因此，调用”name” in persoon1<br>时始终返回 true，无论这个属性是否在实例上。如果要确定某个属性是否存在于原型上，则可以像下<br>面这样同时使用 hasOwnProperty()和 in 操作符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要通过对象可以访问，in 操作符就返回 true，而 hasOwnProperty()只有属性存在于实例上<br>时才返回 true。因此，只要 in 操作符返回 true 且 hasOwnProperty()返回 false，就说明该属性<br>是一个原型属性。来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(hasPrototypeProperty(person, <span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">person.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(hasPrototypeProperty(person, <span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在这里，name 属性首先只存在于原型上，所以 hasPrototypeProperty()返回 true。而在实例上重写这个属性后，实例上也有了这个属性，因此 hasPrototypeProperty()返回 false。即便此时原型对象还有 name 属性，但因为实例上的属性遮蔽了它，所以不会用到。在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（[[Enumerable]]特性被设置为 false）属性的实例属性也会在 for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。要获得对象上所有可枚举的实例属性，可以使用 Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// &quot;name,age,job,sayName&quot;</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.name = <span class="string">&quot;Rob&quot;</span>;</span><br><span class="line">p1.age = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">let</span> p1keys = <span class="built_in">Object</span>.keys(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p1keys); <span class="comment">// &quot;[name,age]&quot;</span></span><br></pre></td></tr></table></figure><p>这里，keys 变量保存的数组中包含”name”、”age”、”job”和”sayName”。这是正常情况下通过for-in 返回的顺序。而在 Person 的实例上调用时，Object.keys()返回的数组中只包含”name”和”age”两个属性。</p><p>如果想列出所有实例属性，无论是否可以枚举，都可以使用 Object.getOwnPropertyNames()：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// &quot;[constructor,name,age,job,sayName]&quot;</span></span><br></pre></td></tr></table></figure><h4 id="注意，返回的结果中包含了一个不可枚举的属性-constructor。Object-keys-和-Object-getOwnPropertyNames-在适当的时候都可用来代替-for-in-循环。"><a href="#注意，返回的结果中包含了一个不可枚举的属性-constructor。Object-keys-和-Object-getOwnPropertyNames-在适当的时候都可用来代替-for-in-循环。" class="headerlink" title="注意，返回的结果中包含了一个不可枚举的属性 constructor。Object.keys()和 Object.getOwnPropertyNames()在适当的时候都可用来代替 for-in 循环。"></a>注意，返回的结果中包含了一个不可枚举的属性 constructor。Object.keys()和 Object.getOwnPropertyNames()在适当的时候都可用来代替 for-in 循环。</h4><p>在 ECMAScript 6 新增符号类型之后，相应地出现了增加一个 Object.getOwnPropertyNames()的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此，Object.getOwnPropertySymbols()方法就出现了，这个方法与 Object.getOwnPropertyNames()类似，只是针对符号而已：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line"> k2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> [k1]: <span class="string">&#x27;k1&#x27;</span>,</span><br><span class="line"> [k2]: <span class="string">&#x27;k2&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)] </span></span><br></pre></td></tr></table></figure><h3 id="4-属性枚举顺序"><a href="#4-属性枚举顺序" class="headerlink" title="4. 属性枚举顺序"></a>4. 属性枚举顺序</h3><p>for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()以及 Object.assign()在属性枚举顺序方面有很大区别。for-in 循环和 Object.keys()的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。</p><p>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line"> k2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line"> first: <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line"> [k1]: <span class="string">&#x27;sym2&#x27;</span>,</span><br><span class="line"> second: <span class="string">&#x27;second&#x27;</span>,</span><br><span class="line"> <span class="number">0</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">o[k2] = <span class="string">&#x27;sym2&#x27;</span>;</span><br><span class="line">o[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">o.third = <span class="string">&#x27;third&#x27;</span>;</span><br><span class="line">o[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));</span><br><span class="line"><span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;first&quot;, &quot;second&quot;, &quot;third&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)] </span></span><br></pre></td></tr></table></figure><h2 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h2><p> JavaScript 有史以来的大部分时间内，迭代对象属性都是一个难题。ECMAScript 2017 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法Object.values()和 Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键/值对的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line"> foo: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line"> baz: <span class="number">1</span>,</span><br><span class="line"> qux: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o)); </span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 1, &#123;&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o)));</span><br><span class="line"><span class="comment">// [[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, &#123;&#125;]] </span></span><br></pre></td></tr></table></figure><p>注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line"> qux: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o)[<span class="number">0</span>] === o.qux);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(o)[<span class="number">0</span>][<span class="number">1</span>] === o.qux);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>符号属性会被忽略：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line"> [sym]: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o));</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o)));</span><br><span class="line"><span class="comment">// [] </span></span><br></pre></td></tr></table></figure><h3 id="1-其他原型语法"><a href="#1-其他原型语法" class="headerlink" title="1. 其他原型语法"></a>1. 其他原型语法</h3><p>在前面的例子中，每次定义一个属性或方法都会把 Person.prototype 重写一遍为了减少代码冗余，也为了从视觉上更好地封装原型功能，直接通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> age: <span class="number">29</span>,</span><br><span class="line"> job: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line"> sayName() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>这次的代码中特意包含了 constructor 属性，并将它设置为 Person，保证了这个属性仍然包含恰当的值。</p><p>但要注意，以这种方式恢复 constructor 属性会创建一个[[Enumerable]]为 true 的属性。而原生 constructor 属性默认是不可枚举的。因此，如果你使用的是兼容 ECMAScript 的 JavaScript 引擎，那可能会改为使用 Object.defineProperty()方法来定义 constructor 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> age: <span class="number">29</span>,</span><br><span class="line"> job: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line"> sayName() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 恢复 constructor 属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line"> enumerable: <span class="literal">false</span>,</span><br><span class="line"> value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-原型的动态性"><a href="#2-原型的动态性" class="headerlink" title="2. 原型的动态性"></a>2. 原型的动态性</h3><p>因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi(); <span class="comment">// &quot;hi&quot;，没问题！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码先创建一个 Person 实例并保存在 friend 中。然后一条语句在 Person.prototype 上添加了一个名为 sayHi()的方法。虽然 friend 实例是在添加方法之前创建的，但它仍然可以访问这个方法。之所以会这样，主要原因是实例与原型之间松散的联系。在调用 friend.sayHi()时，首先会从这个实例中搜索名为 sayHi 的属性。在没有找到的情况下，运行时会继续搜索原型对象。因为实例和原型之间的链接就是简单的指针，而不是保存的副本，所以会在原型上找到 sayHi 属性并返回这个属性保存的函数。</p><p>虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两回事。实例的[[Prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"> <span class="keyword">constructor</span>: Person,</span><br><span class="line"> name: &quot;Nicholas&quot;,</span><br><span class="line"> age: 29,</span><br><span class="line"> job: &quot;Software Engineer&quot;,</span><br><span class="line"> sayName() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayName(); <span class="comment">// 错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Person 的新实例是在重写原型对象之前创建的。在调用 friend.sayName()的时候，会导致错误。这是因为 firend 指向的原型还是最初的原型，而这个原型上并没有 sayName 属性。<br><a href="https://imgchr.com/i/BHLCg1"><img src="https://s1.ax1x.com/2020/11/09/BHLCg1.png" alt="BHLCg1.png"></a><br>重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。</p><h3 id="3-原生对象原型"><a href="#3-原生对象原型" class="headerlink" title="3. 原生对象原型"></a>3. 原生对象原型</h3><p>原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。<br>所有原生引用类型的构造函数（包括 Object、Array、String 等）都在原型上定义了实例方法。比如，数组实例的 sort()方法就是 Array.prototype 上定义的，而字符串包装对象的 substring()方法也是在 String.prototype 上定义的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort); <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring); <span class="comment">// &quot;function&quot; </span></span><br></pre></td></tr></table></figure><p>通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。可以像修改自定义对象原型一样修改原生对象原型，因此随时可以添加方法。比如，下面的代码就给 String原始值包装类型的实例添加了一个 startsWith()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.indexOf(text) === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果给定字符串的开头出现了调用 startsWith()方法的文本，那么该方法会返回 true。因为这个方法是被定义在 String.prototype 上，所以当前环境下所有的字符串都可以使用这个方法。msg是个字符串，在读取它的属性时，后台会自动创建 String 的包装实例，从而找到并调用 startsWith()方法。</p><h4 id="注意-尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。这样做很可能造成误会，而且可能引发命名冲突（比如一个名称在某个浏览器实现中不存在，在另一个实现中却存在）。另外还有可能意外重写原生的方法。推荐的做法是创建一个自定义的类，继承原生类型。"><a href="#注意-尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。这样做很可能造成误会，而且可能引发命名冲突（比如一个名称在某个浏览器实现中不存在，在另一个实现中却存在）。另外还有可能意外重写原生的方法。推荐的做法是创建一个自定义的类，继承原生类型。" class="headerlink" title="注意 尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。这样做很可能造成误会，而且可能引发命名冲突（比如一个名称在某个浏览器实现中不存在，在另一个实现中却存在）。另外还有可能意外重写原生的方法。推荐的做法是创建一个自定义的类，继承原生类型。"></a>注意 尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。这样做很可能造成误会，而且可能引发命名冲突（比如一个名称在某个浏览器实现中不存在，在另一个实现中却存在）。另外还有可能意外重写原生的方法。推荐的做法是创建一个自定义的类，继承原生类型。</h4><h3 id="4-原型的问题"><a href="#4-原型的问题" class="headerlink" title="4. 原型的问题"></a>4. 原型的问题</h3><p>原型模式也不是没有问题。首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。原型的最主要问题源自它的共<br>享特性。<br>我们知道，原型上的所有属性是在实例间共享的，这对函数来说比较合适。另外包含原始值的属性也还好，如前面例子中所示，可以通过在实例上添加同名属性来简单地遮蔽原型上的属性。真正的问题来自包含引用值的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"> <span class="keyword">constructor</span>: Person,</span><br><span class="line"> name: &quot;Nicholas&quot;,</span><br><span class="line"> age: 29,</span><br><span class="line"> job: &quot;Software Engineer&quot;,</span><br><span class="line"> friends: [&quot;Shelby&quot;, &quot;Court&quot;], </span><br><span class="line"> sayName() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">&quot;Van&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">// &quot;Shelby,Court,Van&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// &quot;Shelby,Court,Van&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这里，Person.prototype 有一个名为 friends 的属性，它包含一个字符串数组。然后这里创建了两个 Person 的实例。person1.friends 通过 push 方法向数组中添加了一个字符串。由于这个friends 属性存在于 Person.prototype 而非 person1 上，新加的这个字符串也会在（指向同一个数组的）person2.friends 上反映出来。如果这是有意在多个实例间共享数组，那没什么问题。但一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>很多面向对象语言都支持两种继承：接口继承和实现继承。<br>前者只继承方法签名，后者继承实际的方法。接口继承在 ECMAScript 中是不可能的，因为函数没有签名。实现继承是 ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>ECMA-262 把原型链定义为 ECMAScript 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>SuperType 和 SubType。这两个类型分别定义了一个属性和一个方法。这两个类型的主要区别是 SubType 通过创建 SuperType 的实例并将其赋值给自己的原型 SubTtype.<br>prototype 实现了对 SuperType 的继承。这个赋值重写了 SubType 最初的原型，将其替换为SuperType 的实例。这意味着 SuperType 实例可以访问的所有属性和方法也会存在于 SubType.prototype。这样实现继承之后，代码紧接着又给 SubType.prototype，也就是这个 SuperType 的实例添加了一个新方法。最后又创建了 SubType 的实例并调用了它继承的 getSuperValue()方法。<br><a href="https://imgchr.com/i/BHL0K0"><img src="https://s1.ax1x.com/2020/11/09/BHL0K0.png" alt="BHL0K0.png"></a></p><p>实现继承的关键，是 SubType 没有使用默认原型，而是将其替换成了一个新的对象。这个新的对象恰好是 SuperType 的实例。这样一来，SubType 的实例不仅能从 SuperType 的实例中继承属性和方法，而且还与 SuperType 的原型挂上了钩。于是 instance（通过内部的[[Prototype]]）指向SubType.prototype，而 SubType.prototype（作为 SuperType 的实例又通过内部的[[Prototype]]）指向 SuperType.prototype。注意，getSuperValue()方法还在 SuperType.prototype 对象上，而 property 属性则在 SubType.prototype 上。这是因为 getSuperValue()是一个原型方法，而property 是一个实例属性。SubType.prototype 现在是 SuperType 的一个实例，因此 property才会存储在它上面。还要注意，由于 SubType.prototype 的 constructor 属性被重写为指向SuperType，所以 instance.constructor 也指向 SuperType。</p><p>原型链扩展了前面描述的原型搜索机制。我们知道，在读取实例上的属性时，首先会在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型。在通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型。对前面的例子而言，调用 instance.getSuperValue()经过了 3 步搜索：instance、SubType.prototype 和 SuperType.prototype，最后一步才找到这个方法。对属性和方法的搜索会一直持续到原型链的末端。</p><h3 id="1-默认原型"><a href="#1-默认原型" class="headerlink" title="1. 默认原型"></a>1. 默认原型</h3><p>实际上，原型链中还有一环。默认情况下，所有引用类型都继承自 Object，这也是通过原型链实现的。任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向Object.prototype。这也是为什么自定义类型能够继承包括 toString()、valueOf()在内的所有默认方法的原因。</p><p><a href="https://imgchr.com/i/BHLqGd"><img src="https://s1.ax1x.com/2020/11/09/BHLqGd.png" alt="BHLqGd.png"></a><br>SubType 继承 SuperType，而 SuperType 继承 Object。在调用 instance.toString()时，实际上调用的是保存在 Object.prototype 上的方法。</p><h3 id="2-原型与继承关系"><a href="#2-原型与继承关系" class="headerlink" title="2. 原型与继承关系"></a>2. 原型与继承关系</h3><p>原型与实例的关系可以通过两种方式来确定。第一种方式是使用 instanceof 操作符，如果一个实例的原型链中出现过相应的构造函数，则 instanceof 返回 true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SubType); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从技术上讲，instance 是 Object、SuperType 和 SubType 的实例，因为 instance 的原型链中包含这些构造函数的原型。结果就是 instanceof 对所有这些构造函数都返回 true。<br>确定这种关系的第二种方式是使用 isPrototypeOf()方法。原型链中的每个原型都可以调用这个方法，如下例所示，只要原型链中包含这个原型，这个方法就返回 true：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototype.isPrototypeOf(instance)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><h3 id="3-关于方法"><a href="#3-关于方法" class="headerlink" title="3. 关于方法"></a>3. 关于方法</h3><p>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 覆盖已有的方法</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>第一个方法 getSubValue()是 SubType 的新方法，<br>而第二个方法 getSuperValue()是原型链上已经存在但在这里被遮蔽的方法。后面在 SubType 实例上调用 getSuperValue()时调用的是这个方法。而 SuperType 的实例仍然会调用最初的方法。重点在于上述两个方法都是在把原型赋值为 SuperType 的实例之后定义的。</p><p>另一个要理解的重点是，以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 通过对象字面量添加新方法，这会导致上一行无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line"> getSubValue() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line"> &#125;,</span><br><span class="line"> someOtherMethod() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure><p>在这段代码中，子类的原型在被赋值为 SuperType 的实例后，又被一个对象字面量覆盖了。覆盖后的原型是一个 Object 的实例，而不再是 SuperType 的实例。因此之前的原型链就断了。SubType和 SuperType 之间也没有关系了。</p><h3 id="4-原型链的问题"><a href="#4-原型链的问题" class="headerlink" title="4. 原型链的问题"></a>4. 原型链的问题</h3><p>原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red,blue,green,black&quot; </span></span><br></pre></td></tr></table></figure><p>SuperType 构造函数定义了一个 colors 属性，其中包含一个数组（引用值）。每个 SuperType 的实例都会有自己的 colors 属性，包含自己的数组。但是，当 SubType 通过原型继承SuperType 后，SubType.prototype 变成了 SuperType 的一个实例，因而也获得了自己的 colors属性。这类似于创建了 SubType.prototype.colors 属性。最终结果是，SubType 的所有实例都会<br>共享这个 colors 属性。这一点通过 instance1.colors 上的修改也能反映到 instance2.colors上就可以看出来。</p><p>原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。</p><h2 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h2><p>为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类<br>构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和 call()方法以新创建的对象为上下文执行构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 继承 SuperType</span></span><br><span class="line"> SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red,blue,green&quot; </span></span><br></pre></td></tr></table></figure><p>示例中加粗的代码展示了盗用构造函数的调用。通过使用 call()（或 apply()）方法，SuperType构造函数在为 SubType 的实例创建的新对象的上下文中执行了。这相当于新的 SubType 对象上运行了<br>SuperType()函数中的所有初始化代码。结果就是每个实例都会有自己的 colors 属性。</p><h3 id="1-传递参数"><a href="#1-传递参数" class="headerlink" title="1. 传递参数"></a>1. 传递参数</h3><p>相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 继承 SuperType 并传参</span></span><br><span class="line"> SuperType.call(<span class="built_in">this</span>, <span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"> <span class="comment">// 实例属性</span></span><br><span class="line"> <span class="built_in">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name); <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure><p>SuperType 构造函数接收一个参数 name，然后将它赋值给一个属性。在 SubType构造函数中调用 SuperType 构造函数时传入这个参数，实际上会在 SubType 的实例上定义 name 属性。<br>为确保 SuperType 构造函数不会覆盖 SubType 定义的属性，可以在调用父类构造函数之后再给子类实例添加额外的属性。</p><h3 id="2-盗用构造函数的问题"><a href="#2-盗用构造函数的问题" class="headerlink" title="2. 盗用构造函数的问题"></a>2. 盗用构造函数的问题</h3><p>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模<br>式。由于存在这些问题，盗用构造函数基本上也不能单独使用。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方<br>法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line"> <span class="comment">// 继承属性</span></span><br><span class="line"> SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.sayName(); <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 29</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red,blue,green&quot;</span></span><br><span class="line">instance2.sayName(); <span class="comment">// &quot;Greg&quot;;</span></span><br><span class="line">instance2.sayAge(); <span class="comment">// 27 </span></span><br></pre></td></tr></table></figure><p>SuperType 构造函数定义了两个属性，name 和 colors，而它的原型上也定义了一个方法叫 sayName()。SubType 构造函数调用了 SuperType 构造函数，传入了 name 参数，然后又<br>定义了自己的属性 age。此外，SubType.prototype 也被赋值为 SuperType 的实例。原型赋值之后，又在这个原型上添加了新方法 sayAge()。这样，就可以创建两个 SubType 实例，让这两个实例都有<br>自己的属性，包括 colors，同时还共享相同的方法。</p><p>组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力。</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>是即使不自定义类型也可以通过原型实现对象之间的信息共享。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> F.prototype = o;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个 object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends); <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure><p>Crockford 推荐的原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 object()，然后再对返回的对象进行适当修改。在这个例子中，person 对<br>象定义了另一个对象也应该共享的信息，把它传给 object()之后会返回一个新对象。这个新对象的原型是 person，意味着它的原型上既有原始值属性又有引用值属性。这也意味着 person.friends 不仅是<br>person 的属性，也会跟 anotherPerson 和 yetAnotherPerson 共享。这里实际上克隆了两个 person。</p><p>ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，<br>Object.create()与这里的 object()方法效果相同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends); <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot; </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Object.create()的第二个参数与 Object.defineProperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line"> name: &#123;</span><br><span class="line"> value: <span class="string">&quot;Greg&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name); <span class="comment">// &quot;Greg&quot; </span></span><br></pre></td></tr></table></figure><p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是 Crockford 首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种<br>方式增强对象，然后返回这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">let</span> clone = object(original); <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line"> clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在这段代码中，createAnother()函数接收一个参数，就是新对象的基准对象。这个对象 original会被传给 object()函数，然后将返回的新对象赋值给 clone。接着给 clone 对象添加一个新方法<br>sayHi()。最后返回这个对象。可以像下面这样使用 createAnother()函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">// &quot;hi&quot; </span></span><br></pre></td></tr></table></figure><p>基于 person 对象返回了一个新对象。新返回的 anotherPerson 对象具有 person 的所有属性和方法，还有一个新方法叫 sayHi()。<br>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。object()函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。</p><ul><li>注意 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。<h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2></li></ul><p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line"> SuperType.call(<span class="built_in">this</span>, name); <span class="comment">// 第二次调用 SuperType()</span></span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 第一次调用 SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>是调用 SuperType 构造函数的地方。在上面的代码执行后，SubType.prototype上会有两个属性：name 和 colors。它们都是 SuperType 的实例属性，但现在成为了 SubType 的原型<br>属性。在调用 SubType 构造函数时，也会调用 SuperType 构造函数，这一次会在新对象上创建实例属性 name 和 colors。这两个实例属性会遮蔽原型上同名的属性。</p><p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父<br>类原型，然后将返回的新对象赋值给子类原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> prototype = object(superType.prototype); <span class="comment">// 创建对象</span></span><br><span class="line"> prototype.constructor = subType; <span class="comment">// 增强对象</span></span><br><span class="line"> subType.prototype = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个 inheritPrototype()函数实现了寄生式组合继承的核心逻辑。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的<br>prototype 对象设置 constructor 属性，解决由于重写原型导致默认 constructor 丢失的问题。最后将新创建的对象赋值给子类型的原型。如下例所示，调用 inheritPrototype()就可以实现前面例<br>子中的子类型原型赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"> SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>这里只调用了一次 SuperType 构造函数，避免了 SubType.prototype 上不必要也用不到的属性，因此可以说这个例子的效率更高。而且，原型链仍然保持不变，因此 instanceof 操作符和isPrototypeOf()方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类（class）<br>ECMAScript 中新的基础性语法糖结构，因此刚开始接触时可能会不太习惯。虽然 ECMAScript 6 类表面<br>上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。</p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用 class 关键字加大括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line"><span class="keyword">const</span> Animal = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;; </span><br></pre></td></tr></table></figure><p>与函数表达式类似，类表达式在它们被求值前也不能引用。不过，与函数定义不同的是，虽然函数声明可以提升，但类定义不能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(FunctionExpression); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> FunctionExpression = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(FunctionExpression); <span class="comment">// function() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(FunctionDeclaration); <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionDeclaration</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(FunctionDeclaration); <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ClassExpression); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> ClassExpression = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(ClassExpression); <span class="comment">// class &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ClassDeclaration); <span class="comment">// ReferenceError: ClassDeclaration is not defined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassDeclaration</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ClassDeclaration); <span class="comment">// class ClassDeclaration &#123;&#125; </span></span><br></pre></td></tr></table></figure><p>跟函数声明不同的地方是，函数受函数作用域限制，而类受块作用域限制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">FunctionDeclaration</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ClassDeclaration</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(FunctionDeclaration); <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ClassDeclaration); <span class="comment">// ReferenceError: ClassDeclaration is not defined </span></span><br></pre></td></tr></table></figure><h2 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h2><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。<br>与函数构造函数一样，多数编程风格都建议类名的首字母要大写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空类定义，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 有构造函数的类，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有获取函数的类，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line"> <span class="keyword">get</span> <span class="title">myBaz</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有静态方法的类，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> myQux() &#123;&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过 name 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonName</span> </span>&#123;</span><br><span class="line"> identify() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(Person.name, PersonName.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.identify(); <span class="comment">// PersonName PersonName</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.name); <span class="comment">// PersonName</span></span><br><span class="line"><span class="built_in">console</span>.log(PersonName); <span class="comment">// ReferenceError: PersonName is not defined </span></span><br></pre></td></tr></table></figure><h2 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h2><p>constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。</p><h3 id="1-实例化"><a href="#1-实例化" class="headerlink" title="1. 实例化"></a>1. 实例化</h3><p>使用 new 操作符实例化 Person 的操作等于使用 new 调用其构造函数。唯一可感知的不同之处就是，JavaScript 解释器知道使用 new 和类意味着应该使用 constructor 函数进行实例化。</p><ul><li>在内存中创建一个新对象。</li><li>这个新对象内部的[[Prototype]]指针被赋值为构造函数的 prototype 属性。</li><li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;person ctor&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vegetable</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">this</span>.color = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(); <span class="comment">// person ctor</span></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vegetable();</span><br><span class="line"><span class="built_in">console</span>.log(v.color); <span class="comment">// orange </span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line"> <span class="built_in">this</span>.name = name || <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person; <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name); <span class="comment">// null</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person(); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name); <span class="comment">// null</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jake&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(p3.name); <span class="comment">// Jake </span></span><br></pre></td></tr></table></figure><p>默认情况下，类构造函数会在执行之后返回 this 对象。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的 this 对象，那么这个对象会被销毁。不过，如果返回的不是 this 对象，而是其他对象，那么这个对象不会通过 instanceof 操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(override) &#123;</span><br><span class="line"> <span class="built_in">this</span>.foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"> <span class="keyword">if</span> (override) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line"> bar: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(),</span><br><span class="line"> p2 = <span class="keyword">new</span> Person(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1); <span class="comment">// Person&#123; foo: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2); <span class="comment">// &#123; bar: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用 new 操作符。而普通构造函数如果不使用 new 调用，那么就会以全局的 this（通常是 window）作为内部对象。调用类构造函数时如果忘了使用 new 则会抛出错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 把 window 作为 this 来构建实例</span></span><br><span class="line"><span class="keyword">let</span> p = Person();</span><br><span class="line"><span class="keyword">let</span> a = Animal();</span><br><span class="line"><span class="comment">// TypeError: class constructor Animal cannot be invoked without &#x27;new&#x27; </span></span><br></pre></td></tr></table></figure><p>类构造函数没有什么特殊之处，实例化之后，它会成为普通的实例方法（但作为类构造函数，仍然要使用 new 调用）。因此，实例化之后可以在实例上引用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 使用类创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.constructor();</span><br><span class="line"><span class="comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span></span><br><span class="line"><span class="comment">// 使用对类构造函数的引用创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> p1.constructor(); </span><br></pre></td></tr></table></figure><h3 id="2-把类当成特殊函数"><a href="#2-把类当成特殊函数" class="headerlink" title="2.把类当成特殊函数"></a>2.把类当成特殊函数</h3><p>ECMAScript 中没有正式的类这个类型。从各方面来看，ECMAScript 类就是一种特殊函数。声明一个类之后，通过 typeof 操作符检测类标识符，表明它是一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person); <span class="comment">// class Person &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person); <span class="comment">// function </span></span><br></pre></td></tr></table></figure><p>类标识符有 prototype 属性，而这个原型也有一个 constructor 属性指向类自身：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype); <span class="comment">// &#123; constructor: f() &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>与普通构造函数一样，可以使用 instanceof 操作符检查构造函数原型是否存在于实例的原型链中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>由此可知，可以使用 instanceof 操作符检查一个对象与类构造函数，以确定这个对象是不是类的实例。只不过此时的类构造函数要使用类标识符，比如，在前面的例子中要检查 p 和 Person。</p><p>如前所述，类本身具有与普通构造函数一样的行为。在类的上下文中，类本身在使用 new 调用时就会被当成构造函数。重点在于，类中定义的 constructor 方法不会被当成构造函数，在对它使用instanceof 操作符时会返回 false。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么 instanceof 操作符的返回值会反转</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person.constructor); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person.constructor();</span><br><span class="line"><span class="built_in">console</span>.log(p2.constructor === Person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person.constructor); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>类是 JavaScript 的一等公民，因此可以像其他对象或函数引用一样把类作为参数传递：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类可以像函数一样在任何地方定义，比如在数组中</span></span><br><span class="line"><span class="keyword">let</span> classList = [</span><br><span class="line"> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line"> <span class="built_in">this</span>.id_ = id;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`instance <span class="subst">$&#123;<span class="built_in">this</span>.id_&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">classDefinition, id</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> classDefinition(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = createInstance(classList[<span class="number">0</span>], <span class="number">3141</span>); <span class="comment">// instance 3141 </span></span><br></pre></td></tr></table></figure><p>与立即调用函数表达式相似，类也可以立即实例化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为是一个类表达式，所以类名是可选的</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; </span><br><span class="line"><span class="keyword">constructor</span>(x) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(x);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// Foo &#123;&#125; </span></span><br></pre></td></tr></table></figure><h2 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h2><p>类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。</p><h3 id="1-实例成员"><a href="#1-实例成员" class="headerlink" title="1. 实例成员"></a>1. 实例成员</h3><p>每次通过new调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（this）添加“自有”属性。至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员。<br>每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="comment">// 这个例子先使用对象包装类型定义一个字符串</span></span><br><span class="line"> <span class="comment">// 为的是在下面测试两个对象的相等性</span></span><br><span class="line"> <span class="built_in">this</span>.name = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"> <span class="built_in">this</span>.sayName = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line"> <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(),</span><br><span class="line"> p2 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.sayName(); <span class="comment">// Jack</span></span><br><span class="line">p2.sayName(); <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name === p2.name); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.nicknames === p2.nicknames); <span class="comment">// false</span></span><br><span class="line">p1.name = p1.nicknames[<span class="number">0</span>];</span><br><span class="line">p2.name = p2.nicknames[<span class="number">1</span>];</span><br><span class="line">p1.sayName(); <span class="comment">// Jake</span></span><br><span class="line">p2.sayName(); <span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure><h3 id="2-原型方法与访问器"><a href="#2-原型方法与访问器" class="headerlink" title="2. 原型方法与访问器"></a>2. 原型方法与访问器</h3><p>为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="comment">// 添加到 this 的所有内容都会存在于不同的实例上</span></span><br><span class="line"> <span class="built_in">this</span>.locate = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;instance&#x27;</span>);</span><br><span class="line"> &#125; </span><br><span class="line">  <span class="comment">// 在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line"> locate() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;prototype&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.locate(); <span class="comment">// instance</span></span><br><span class="line">Person.prototype.locate(); <span class="comment">// prototype </span></span><br></pre></td></tr></table></figure><p>可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> name: <span class="string">&#x27;Jake&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected token </span></span><br></pre></td></tr></table></figure><p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(<span class="string">&#x27;symbolKey&#x27;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> stringKey() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;invoked stringKey&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> [symbolKey]() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;invoked symbolKey&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> [<span class="string">&#x27;computed&#x27;</span> + <span class="string">&#x27;Key&#x27;</span>]() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;invoked computedKey&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.stringKey(); <span class="comment">// invoked stringKey</span></span><br><span class="line">p[symbolKey](); <span class="comment">// invoked symbolKey</span></span><br><span class="line">p.computedKey(); <span class="comment">// invoked computedKey </span></span><br></pre></td></tr></table></figure><p>类定义也支持获取和设置访问器。语法与行为跟普通对象一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">set</span> <span class="title">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line"> <span class="built_in">this</span>.name_ = newName;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.name_;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure><h3 id="3-静态类方法"><a href="#3-静态类方法" class="headerlink" title="3. 静态类方法"></a>3. 静态类方法</h3><p>可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个。<br>静态类成员在类定义中使用 static 关键字作为前缀。在静态成员中，this 引用类自身。其他所有约定跟原型成员一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="comment">// 添加到 this 的所有内容都会存在于不同的实例上</span></span><br><span class="line"> <span class="built_in">this</span>.locate = <span class="function">() =&gt;</span> </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;instance&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 定义在类的原型对象上</span></span><br><span class="line"> locate() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;prototype&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 定义在类本身上</span></span><br><span class="line"> <span class="keyword">static</span> locate() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;class&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.locate(); <span class="comment">// instance, Person &#123;&#125;</span></span><br><span class="line">Person.prototype.locate(); <span class="comment">// prototype, &#123;constructor: ... &#125;</span></span><br><span class="line">Person.locate(); <span class="comment">// class, class Person &#123;&#125; </span></span><br></pre></td></tr></table></figure><p>静态类方法非常适合作为实例工厂：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(age) &#123;</span><br><span class="line"> <span class="built_in">this</span>.age_ = age;</span><br><span class="line"> &#125;</span><br><span class="line"> sayAge() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.age_);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">static</span> create() &#123;</span><br><span class="line"> <span class="comment">// 使用随机年龄创建并返回一个 Person 实例</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">100</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.create()); <span class="comment">// Person &#123; age_: ... &#125; </span></span><br></pre></td></tr></table></figure><h3 id="4-非函数原型和类成员"><a href="#4-非函数原型和类成员" class="headerlink" title="4. 非函数原型和类成员"></a>4. 非函数原型和类成员</h3><p>虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> sayName() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;Person.greeting&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在类上定义数据成员</span></span><br><span class="line">Person.greeting = <span class="string">&#x27;My name is&#x27;</span>; </span><br><span class="line"><span class="comment">// 在原型上定义数据成员</span></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.sayName(); <span class="comment">// My name is Jake </span></span><br></pre></td></tr></table></figure><h4 id="注意-类定义中之所以没有显式支持添加数据成员，是因为在共享目标（原型和类）上添加可变（可修改）数据成员是一种反模式。一般来说，对象实例应该独自拥有通过-this引用的数据。"><a href="#注意-类定义中之所以没有显式支持添加数据成员，是因为在共享目标（原型和类）上添加可变（可修改）数据成员是一种反模式。一般来说，对象实例应该独自拥有通过-this引用的数据。" class="headerlink" title="注意 类定义中之所以没有显式支持添加数据成员，是因为在共享目标（原型和类）上添加可变（可修改）数据成员是一种反模式。一般来说，对象实例应该独自拥有通过 this引用的数据。"></a>注意 类定义中之所以没有显式支持添加数据成员，是因为在共享目标（原型和类）上添加可变（可修改）数据成员是一种反模式。一般来说，对象实例应该独自拥有通过 this引用的数据。</h4><h3 id="5-迭代器与生成器方法"><a href="#5-迭代器与生成器方法" class="headerlink" title="5. 迭代器与生成器方法"></a>5. 迭代器与生成器方法</h3><p>类定义语法支持在原型和类本身上定义生成器方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 在原型上定义生成器方法</span></span><br><span class="line"> *createNicknameIterator() &#123;</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;J-Dog&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 在类上定义生成器方法</span></span><br><span class="line"> <span class="keyword">static</span> *createJobIterator() &#123;</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;Butcher&#x27;</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;Baker&#x27;</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;Candlestick maker&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jobIter = Person.createJobIterator();</span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value); <span class="comment">// Butcher</span></span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value); <span class="comment">// Baker</span></span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value); <span class="comment">// Candlestick maker</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> nicknameIter = p.createNicknameIterator();</span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value); <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value); <span class="comment">// Jake</span></span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value); <span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure><p>因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line"> <span class="keyword">yield</span> *<span class="built_in">this</span>.nicknames.entries();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(nickname);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// Jake</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure><p>也可以只返回迭代器实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.nicknames.entries();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// Jake</span></span><br><span class="line"><span class="comment">// J-Dog </span></span><br></pre></td></tr></table></figure><h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><p>虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p><h3 id="1-继承基础"><a href="#1-继承基础" class="headerlink" title="1. 继承基础"></a>1. 继承基础</h3><p>ES6 类支持单继承。使用 extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bus); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Vehicle); <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承普通构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> Engineer();</span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Engineer); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Person); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>派生类都会通过原型链访问到类和原型上定义的方法。this 的值会反映调用相应方法的实例或者类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> identifyPrototype(id) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(id, <span class="built_in">this</span>);</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">static</span> identifyClass(id) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(id, <span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line">b.identifyPrototype(<span class="string">&#x27;bus&#x27;</span>); <span class="comment">// bus, Bus &#123;&#125;</span></span><br><span class="line">v.identifyPrototype(<span class="string">&#x27;vehicle&#x27;</span>); <span class="comment">// vehicle, Vehicle &#123;&#125;</span></span><br><span class="line">Bus.identifyClass(<span class="string">&#x27;bus&#x27;</span>); <span class="comment">// bus, class Bus &#123;&#125;</span></span><br><span class="line">Vehicle.identifyClass(<span class="string">&#x27;vehicle&#x27;</span>); <span class="comment">// vehicle, class Vehicle &#123;&#125; </span></span><br></pre></td></tr></table></figure><h4 id="注意-extends-关键字也可以在类表达式中使用，因此-let-Bar-class-extends-Foo-是有效的语法。"><a href="#注意-extends-关键字也可以在类表达式中使用，因此-let-Bar-class-extends-Foo-是有效的语法。" class="headerlink" title="注意 extends 关键字也可以在类表达式中使用，因此 let Bar = class extends Foo {}是有效的语法。"></a>注意 extends 关键字也可以在类表达式中使用，因此 let Bar = class extends Foo {}是有效的语法。</h4><h3 id="2-构造函数、HomeObject-和-super"><a href="#2-构造函数、HomeObject-和-super" class="headerlink" title="2. 构造函数、HomeObject 和 super()"></a>2. 构造函数、HomeObject 和 super()</h3><p>派生类的方法可以通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用 super 可以调用父类构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">this</span>.hasEngine = <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="comment">// 不要在调用 super()之前引用 this，否则会抛出 ReferenceError</span></span><br><span class="line"> <span class="built_in">super</span>(); <span class="comment">// 相当于 super.constructor()</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vehicle); <span class="comment">// true</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// Bus &#123; hasEngine: true &#125;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bus(); </span><br></pre></td></tr></table></figure><p>在静态方法中可以通过 super 调用继承的类上定义的静态方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> identify() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;vehicle&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> identify() &#123;</span><br><span class="line"> <span class="built_in">super</span>.identify();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bus.identify(); <span class="comment">// vehicle </span></span><br></pre></td></tr></table></figure><h4 id="注意-ES6-给类构造函数和静态方法添加了内部特性-HomeObject-，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在-JavaScript-引擎内部访问。super-始终会定义为-HomeObject-的原型。"><a href="#注意-ES6-给类构造函数和静态方法添加了内部特性-HomeObject-，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在-JavaScript-引擎内部访问。super-始终会定义为-HomeObject-的原型。" class="headerlink" title="注意 ES6 给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在 JavaScript 引擎内部访问。super 始终会定义为[[HomeObject]]的原型。"></a>注意 ES6 给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在 JavaScript 引擎内部访问。super 始终会定义为[[HomeObject]]的原型。</h4><p>在使用 super 时要注意几个问题。</p><ul><li>super 只能在派生类构造函数和静态方法中使用。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">super</span>();</span><br><span class="line"> <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li>不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">super</span>);</span><br><span class="line"> <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li>调用 super()会调用父类构造函数，并将返回的实例赋值给 this。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">super</span>();</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vehicle);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bus(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li>super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(licensePlate) &#123;</span><br><span class="line"> <span class="built_in">this</span>.licensePlate = licensePlate;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(licensePlate) &#123;</span><br><span class="line"> <span class="built_in">super</span>(licensePlate);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Bus(<span class="string">&#x27;1337H4X&#x27;</span>)); <span class="comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li><li>如果没有定义类构造函数，在实例化派生类时会调用 super()，而且会传入所有传给派生类的<br>参数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(licensePlate) &#123;</span><br><span class="line"> <span class="built_in">this</span>.licensePlate = licensePlate;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Bus(<span class="string">&#x27;1337H4X&#x27;</span>)); <span class="comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li><li>在类构造函数中，不能在调用 super()之前引用 this。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bus();</span><br><span class="line"><span class="comment">// ReferenceError: Must call super constructor in derived class</span></span><br><span class="line"><span class="comment">// before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br><span class="line">* 如果在派生类中显式定义了构造函数，则要么必须在其中调用 <span class="built_in">super</span>()，要么必须在其中返回</span><br><span class="line">一个对象。</span><br><span class="line">~~~javascript</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">super</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Van</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Car()); <span class="comment">// Car &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Bus()); <span class="comment">// Bus &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Van()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-抽象基类"><a href="#3-抽象基类" class="headerlink" title="3. 抽象基类"></a>3. 抽象基类</h3>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 ECMAScript 没有专门支持这种类的语法 ，但通过 new.target 也很容易实现。new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">new</span>.target === Vehicle) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>); </span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Bus(); <span class="comment">// class Bus &#123;&#125;</span></span><br><span class="line"><span class="keyword">new</span> Vehicle(); <span class="comment">// class Vehicle &#123;&#125;</span></span><br><span class="line"><span class="comment">// Error: Vehicle cannot be directly instantiated </span></span><br></pre></td></tr></table></figure><p>另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">new</span>.target === Vehicle) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">this</span>.foo) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Inheriting class must define foo()&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;success!&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"> foo() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Van</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Bus(); <span class="comment">// success!</span></span><br><span class="line"><span class="keyword">new</span> Van(); <span class="comment">// Error: Inheriting class must define foo() </span></span><br></pre></td></tr></table></figure><h3 id="4-继承内置类型"><a href="#4-继承内置类型" class="headerlink" title="4. 继承内置类型"></a>4. 继承内置类型</h3><p>ES6 类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"> shuffle() &#123;</span><br><span class="line"> <span class="comment">// 洗牌算法</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"> <span class="keyword">const</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>));</span><br><span class="line"> [<span class="built_in">this</span>[i], <span class="built_in">this</span>[j]] = [<span class="built_in">this</span>[j], <span class="built_in">this</span>[i]];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> SuperArray); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">a.shuffle();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [3, 1, 4, 5, 2] </span></span><br></pre></td></tr></table></figure><p>有些内置类型的方法会返回新实例。默认情况下，返回实例的类型与原始实例的类型是一致的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(a1); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>如果想覆盖这个默认行为，则可以覆盖 Symbol.species 访问器，这个访问器决定在创建返回的实例时使用的类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(a1); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> SuperArray); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><h3 id="5-类混入"><a href="#5-类混入" class="headerlink" title="5. 类混入"></a>5. 类混入</h3><p>把不同类的行为集中到一个类是一种常见的 JavaScript 模式。虽然 ES6 没有显式支持多类继承，但通过现有特性可以轻松地模拟这种行为。</p><h4 id="注意-Object-assign-方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用Object-assign-就可以了。"><a href="#注意-Object-assign-方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用Object-assign-就可以了。" class="headerlink" title="注意 Object.assign()方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用Object.assign()就可以了。"></a>注意 Object.assign()方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用Object.assign()就可以了。</h4><p>在下面的代码片段中，extends 关键字后面是一个 JavaScript 表达式。任何可以解析为一个类或一个构造函数的表达式都是有效的。这个表达式会在求值类定义时被求值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;evaluated expression&#x27;</span>);</span><br><span class="line"> <span class="keyword">return</span> Vehicle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">getParentClass</span>() </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 可求值的表达式</span></span><br></pre></td></tr></table></figure><p>混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被<br>继承的类。如果 Person 类需要组合 A、B、C，则需要某种机制实现 B 继承 A，C 继承 B，而 Person再继承 C，从而把 A、B、C 组合到这个超类中。实现这种模式有不同的策略。<br>一个策略是定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> FooMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line"> foo() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> BarMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line"> bar() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> BazMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line"> baz() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">FooMixin</span>(<span class="title">BarMixin</span>(<span class="title">BazMixin</span>(<span class="title">Vehicle</span>))) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line">b.foo(); <span class="comment">// foo</span></span><br><span class="line">b.bar(); <span class="comment">// bar</span></span><br><span class="line">b.baz(); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure><p>通过写一个辅助函数，可以把嵌套调用展开：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> FooMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line"> foo() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> BarMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line"> bar() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> BazMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line"> baz() &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params">BaseClass, ...Mixins</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> Mixins.reduce(<span class="function">(<span class="params">accumulator, current</span>) =&gt;</span> current(accumulator), BaseClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="title">Vehicle</span>, <span class="title">FooMixin</span>, <span class="title">BarMixin</span>, <span class="title">BazMixin</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line">b.foo(); <span class="comment">// foo</span></span><br><span class="line">b.bar(); <span class="comment">// bar</span></span><br><span class="line">b.baz(); <span class="comment">// baz </span></span><br></pre></td></tr></table></figure><h4 id="注意-很多-JavaScript-框架（特别是-React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition-over-inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。"><a href="#注意-很多-JavaScript-框架（特别是-React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition-over-inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。" class="headerlink" title="注意 很多 JavaScript 框架（特别是 React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition over inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。"></a>注意 很多 JavaScript 框架（特别是 React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition over inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。</h4>]]></content>
    
    
    <summary type="html">类与面向对象编程</summary>
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="类与面向对象编程" scheme="http://example.com/tags/%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之期约与异步</title>
    <link href="http://example.com/2020/11/01/%E7%BA%A2%E5%AE%9D%E4%B9%A612/"/>
    <id>http://example.com/2020/11/01/%E7%BA%A2%E5%AE%9D%E4%B9%A612/</id>
    <published>2020-11-01T05:06:43.000Z</published>
    <updated>2020-11-09T15:35:45.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="期约与异步"><a href="#期约与异步" class="headerlink" title="期约与异步"></a>期约与异步</h1><p> ECMAScript 6 及之后的几个版本逐步加大了对异步编程机制的支持，提供了令人眼前一亮的新特性。ECMAScript 6 新增了正式的 Promise（期约）引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了使用 async 和 await 关键字定义异步函数的机制。</p><ul><li><p>期约的主要功能<br>是为异步代码提供了清晰的抽象。可以用期约表示异步执行的代码块，也可以用期约表示异步计算的值。在需要串行异步代码时，期约的价值最为突出。作为可塑性极强的一种结构，期约可以被序列化、连锁使用、复合、扩展和重组。</p></li><li><p>异步函数是将期约应用于 JavaScript 函数的结果。<br>异步函数可以暂停执行，而不阻塞主线程。无论是编写基于期约的代码，还是组织串行或平行执行的异步代码，使用异步函数都非常得心应手。异步函数可以说是现代 JavaScript 工具箱中最重要的工具之一。</p></li></ul><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>同步行为和异步行为的对立统一是计算机科学的一个基本概念。特别是在 JavaScript 这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">x = x + <span class="number">4</span>; </span><br></pre></td></tr></table></figure><p>在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到最后一条指定执行完毕，存储在 x 的值就立即可以使用。</p><p>这两行 JavaScript 代码对应的低级指令（从 JavaScript 到 x86）并不难想象。首先，操作系统会在栈内存上分配一个存储浮点数值的空间，然后针对这个值做一次数学计算，再把计算结果写回之前分配的内存中。所有这些指令都是在单个线程中按顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。</p><p>相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。</p><p>异步操作的例子可以是在定时回调中执行一次简单的数学计算：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> x = x + <span class="number">4</span>, <span class="number">1000</span>); </span><br></pre></td></tr></table></figure><p>这段程序最终与同步代码执行的任务一样，都是把两个数加在一起，但这一次执行线程不知道 x 值何时会改变，因为这取决于回调何时从消息队列出列并执行。</p><p>异步代码不容易推断。虽然这个例子对应的低级代码最终跟前面的例子没什么区别，但第二个指令块（加操作及赋值操作）是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候会触发这个中断，这对 JavaScript 运行时来说是一个黑盒，因此实际上无法预知（尽管可以保证这发生在当前线程的同步代码执行之后，否则回调都没有机会出列被执行）。无论如何，在排定回调以后基本没办法知道系统状态何时变化。</p><p>为了让后续代码能够使用 x，异步执行的函数需要在更新 x 的值以后通知其他代码。如果程序不需要这个值，那么就只管继续执行，不必等待这个结果了。</p><p>设计一个能够知道 x 什么时候可以读取的系统是非常难的。JavaScript 在实现这样一个系统的过程中也经历了几次迭代。</p><h2 id="以往的异步编程模式"><a href="#以往的异步编程模式" class="headerlink" title="以往的异步编程模式"></a>以往的异步编程模式</h2><p>异步行为是 JavaScript 的基础，但以前的实现不理想。在早期的 JavaScript 中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。</p><p>假设有以下异步函数，使用了 setTimeout 在一秒钟之后执行某些操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">double(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 6（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure><p>这里的代码没什么神秘的，但关键是理解为什么说它是一个异步函数。setTimeout 可以定义一个在指定时间之后会被调度执行的回调函数。对这个例子而言，1000 毫秒之后，JavaScript 运行时会把回调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对 JavaScript 代码就完全不可见了。还有一点，double()函数在 setTimeout 成功调度异步操作之后会立即退出。</p><h3 id="1-异步返回值"><a href="#1-异步返回值" class="headerlink" title="1. 异步返回值"></a>1. 异步返回值</h3><p>假设 setTimeout 操作会返回一个有用的值。有什么好办法把这个值传给需要它的地方？广泛接受的一个策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, callback</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> callback(value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">double(<span class="number">3</span>, <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`I was given: <span class="subst">$&#123;x&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// I was given: 6（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure><p>这里的 setTimeout 调用告诉 JavaScript 运行时在 1000 毫秒之后把一个函数推到消息队列上。这个函数会由运行时负责异步调度执行。而位于函数闭包中的回调及其参数在异步执行时仍然是可用的。</p><h3 id="2-失败处理"><a href="#2-失败处理" class="headerlink" title="2. 失败处理"></a>2. 失败处理</h3><p>异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, success, failure</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">&#x27;Must provide number as first argument&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> success(<span class="number">2</span> * value);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"> failure(e);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> successCallback = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Success: <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">const</span> failureCallback = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line">double(<span class="number">3</span>, successCallback, failureCallback);</span><br><span class="line">double(<span class="string">&#x27;b&#x27;</span>, successCallback, failureCallback);</span><br><span class="line"><span class="comment">// Success: 6（大约 1000 毫秒之后）</span></span><br><span class="line"><span class="comment">// Failure: Must provide number as first argument（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure><p>这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它。</p><h3 id="3-嵌套异步回调"><a href="#3-嵌套异步回调" class="headerlink" title="3. 嵌套异步回调"></a>3. 嵌套异步回调</h3><p>如果异步返值又依赖另一个异步返回值，那么回调的情况还会进一步变复杂。在实际的代码中，这就要求嵌套回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, success, failure</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">&#x27;Must provide number as first argument&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> success(<span class="number">2</span> * value);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"> failure(e);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;, <span class="number">1000</span>); </span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">const</span> successCallback = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line"> double(x, <span class="function">(<span class="params">y</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Success: <span class="subst">$&#123;y&#125;</span>`</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> failureCallback = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line">double(<span class="number">3</span>, successCallback, failureCallback);</span><br><span class="line"><span class="comment">// Success: 12（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure><p>显然，随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。嵌套回调的代码维护起来就是噩梦。</p><hr><h1 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h1><p>期约是对尚不存在结果的一个替身。期约（promise）这个名字最早是由 Daniel Friedman和 David Wise在他们于 1976 年发表的论文“The Impact of Applicative Programming on Multiprocessing”中提出来的。但直到十几年以后，Barbara Liskov 和 Liuba Shrira 在 1988 年发表了论文“Promises: Linguistic Support forEfficient Asynchronous Procedure Calls in Distributed Systems”，这个概念才真正确立下来。同一时期的计算机科学家还使用了“终局”（eventual）、“期许”（future）、“延迟”（delay）和“迟付”（deferred）等术语指代同样的概念。所有这些概念描述的都是一种异步程序执行的机制。</p><h2 id="Promises-A-规范"><a href="#Promises-A-规范" class="headerlink" title="Promises/A+规范"></a>Promises/A+规范</h2><p>早期的期约机制在 jQuery 和 Dojo 中是以 Deferred API 的形式出现的。到了 2010 年，CommonJS 项目实现的 Promises/A 规范日益流行起来。Q 和 Bluebird 等第三方 JavaScript 期约库也越来越得到社区认可，虽然这些库的实现多少都有些不同。为弥合现有实现之间的差异，2012 年 Promises/A+组织分叉（fork）了 CommonJS 的 Promises/A 建议，并以相同的名字制定了 Promises/A+规范。这个规范最终成为了ECMAScript 6 规范实现的范本。</p><p>ECMAScript 6 增加了对 Promises/A+规范的完善支持，即 Promise 类型。一经推出，Promise 就大受欢迎，成为了主导性的异步编程机制。所有现代浏览器都支持 ES6 期约，很多其他浏览器 API（如fetch()和 Battery Status API）也以期约为基础。</p><h2 id="期约基础"><a href="#期约基础" class="headerlink" title="期约基础"></a>期约基础</h2><p>ECMAScript 6 新增的引用类型 Promise，可以通过 new 操作符来实例化。创建新期约时需要传入<br>执行器（executor）函数作为参数（后面马上会介绍），下面的例子使用了一个空函数对象来应付一下解<br>释器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt; </span></span><br></pre></td></tr></table></figure><h3 id="1-期约状态机"><a href="#1-期约状态机" class="headerlink" title="1. 期约状态机"></a>1. 期约状态机</h3><p>在把一个期约实例传给 console.log()时，控制台输出（可能因浏览器不同而略有差异）表明该实例处于待定（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之一：</p><ul><li>待定（pending）</li><li>兑现（fulfilled，有时候也称为“解决”，resolved）</li><li>拒绝（rejected）</li></ul><p>待定（pending）是期约的最初始状态。在待定状态下，期约可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。</p><p>无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约解决（resolve）还是拒绝（reject），甚至永远处于待定（pending）状态，都应该具有恰当的行为。</p><p>重要的是，期约的状态是私有的，不能直接通过 JavaScript 检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部 JavaScript 代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。</p><h3 id="2-解决值、拒绝理由及期约用例"><a href="#2-解决值、拒绝理由及期约用例" class="headerlink" title="2. 解决值、拒绝理由及期约用例"></a>2. 解决值、拒绝理由及期约用例</h3><p>期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。“待定”表示尚未开始或者正在执行中。“兑现”表示已经成功完成，而“拒绝”则表示没有成功完成。</p><p>为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部值（value）。类似地，每个期约只要状态切换为拒绝，就会有一个私有的内部理由（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 undefined。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。</p><h3 id="3-通过执行函数控制期约状态"><a href="#3-通过执行函数控制期约状态" class="headerlink" title="3. 通过执行函数控制期约状态"></a>3. 通过执行函数控制期约状态</h3><p>由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛出错误（后面会讨论这个错误）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">// Uncaught error (in promise) </span></span><br></pre></td></tr></table></figure><p>在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态。这里的关键在于，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。通过下面的例子可以看出上面代码的执行顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;executor&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;promise initialized&#x27;</span>);</span><br><span class="line"><span class="comment">// executor</span></span><br><span class="line"><span class="comment">// promise initialized </span></span><br></pre></td></tr></table></figure><p>添加 setTimeout 可以推迟切换状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line"><span class="comment">// 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt; </span></span><br></pre></td></tr></table></figure><p>无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> resolve();</span><br><span class="line"> reject(); <span class="comment">// 没有效果</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt; </span></span><br></pre></td></tr></table></figure><p>为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过 setTimeout 设置一个10 秒钟后无论如何都会拒绝期约的回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(reject, <span class="number">10000</span>); <span class="comment">// 10 秒后调用 reject()</span></span><br><span class="line"> <span class="comment">// 执行函数的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">11000</span>, p); <span class="comment">// 11 秒后再检查状态</span></span><br><span class="line"><span class="comment">// (After 10 seconds) Uncaught error</span></span><br><span class="line"><span class="comment">// (After 11 seconds) Promise &lt;rejected&gt; </span></span><br></pre></td></tr></table></figure><p>因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失败。</p><h3 id="4-Promise-resolve"><a href="#4-Promise-resolve" class="headerlink" title="4. Promise.resolve()"></a>4. Promise.resolve()</h3><p>期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用Promise.resolve()静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(); </span><br></pre></td></tr></table></figure><p>这个解决的期约的值对应着传给 Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve());</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)); </span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"><span class="comment">// 多余的参数会忽略</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 4 </span></span><br></pre></td></tr></table></figure><p>对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法，如下所示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.resolve(p));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve(p)));</span><br><span class="line"><span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>这个幂等性会保留传入期约的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(p)); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.resolve(p)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: Error: foo </span></span><br></pre></td></tr></table></figure><h3 id="5-Promise-reject"><a href="#5-Promise-reject" class="headerlink" title="5. Promise.reject()"></a>5. Promise.reject()</h3><p>与 Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际上是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(); </span><br></pre></td></tr></table></figure><p>这个拒绝的期约的理由就是传给 Promise.reject()的第一个参数。这个参数也会传给后续的拒<br>绝处理程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;rejected&gt;: 3</span></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, e)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.reject(<span class="built_in">Promise</span>.resolve()));</span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-同步-异步执行的二元性"><a href="#6-同步-异步执行的二元性" class="headerlink" title="6. 同步/异步执行的二元性"></a>6. 同步/异步执行的二元性</h3><p>Promise 的设计很大程度上会导致一种完全不同于 JavaScript 的计算模式。下面的例子完美地展示了这一点，其中包含了两种模式下抛出错误的情形</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(e); <span class="comment">// Error: foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: bar </span></span><br></pre></td></tr></table></figure><p>第一个 try/catch 抛出并捕获了错误，第二个 try/catch 抛出错误却没有捕获到。乍一看这可能有点违反直觉，因为代码中确实是同步创建了一个拒绝的期约实例，而这个实例也抛出了包含拒绝理由的错误。这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。</p><p>在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。</p><hr><h2 id="期约的实例方法"><a href="#期约的实例方法" class="headerlink" title="期约的实例方法"></a>期约的实例方法</h2><p>期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。</p><h3 id="1-实现-Thenable-接口"><a href="#1-实现-Thenable-接口" class="headerlink" title="1. 实现 Thenable 接口"></a>1. 实现 Thenable 接口</h3><p>在 ECMAScript 暴露的异步结构中，任何对象都有一个 then()方法。这个方法被认为实现了Thenable 接口。下面的例子展示了实现这一接口的最简单的类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThenable</span> </span>&#123;</span><br><span class="line"> then() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ECMAScript 的 Promise 类型实现了 Thenable 接口。这个简化的接口跟 TypeScript 或其他包中的接口或类型定义不同，它们都设定了 Thenable 接口更具体的形式。</p><h3 id="2-Promise-prototype-then"><a href="#2-Promise-prototype-then" class="headerlink" title="2. Promise.prototype.then()"></a>2. Promise.prototype.then()</h3><p>Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then()方法接收最多两个参数：onResolved 处理程序和 onRejected 处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolved</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>));</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> onResolved(<span class="string">&#x27;p1&#x27;</span>),</span><br><span class="line"> () =&gt; onRejected(<span class="string">&#x27;p1&#x27;</span>));</span><br><span class="line">p2.then(<span class="function">() =&gt;</span> onResolved(<span class="string">&#x27;p2&#x27;</span>),</span><br><span class="line"> () =&gt; onRejected(<span class="string">&#x27;p2&#x27;</span>));</span><br><span class="line"><span class="comment">//（3 秒后）</span></span><br><span class="line"><span class="comment">// p1 resolved</span></span><br><span class="line"><span class="comment">// p2 rejected</span></span><br></pre></td></tr></table></figure><p>因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。如前所述，两个处理程序参数都是可选的。而且，传给 then()的任何非函数类型的参数都会被静默忽略。如果想只提供 onRejected 参数，那就要在 onResolved 参数的位置上传入 undefined。这样有助于避免在内存中创建多余的对象，对期待函数参数的类型系统也是一个交代。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolved</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>));</span><br><span class="line"><span class="comment">// 非函数处理程序会被静默忽略，不推荐</span></span><br><span class="line">p1.then(<span class="string">&#x27;gobbeltygook&#x27;</span>);</span><br><span class="line"><span class="comment">// 不传 onResolved 处理程序的规范写法</span></span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> onRejected(<span class="string">&#x27;p2&#x27;</span>));</span><br><span class="line"><span class="comment">// p2 rejected（3 秒后）</span></span><br></pre></td></tr></table></figure><p>Promise.prototype.then()方法返回一个新的期约实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1 === p2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这个新期约实例基于 onResovled 处理程序的返回值构建。换句话说，该处理程序的返回值会通过Promise.resolve()包装来生成新期约。如果没有提供这个处理程序，则 Promise.resolve()就会包装上一个期约解决之后的值。如果没有显式的返回语句，则 Promise.resolve()会包装默认的返回值 undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 若调用 then()时不传处理程序，则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="function">() =&gt;</span> <span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = p1.then(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p5 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br></pre></td></tr></table></figure><p>如果有显式的返回值，则 Promise.resolve()会包装这个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p6 = p1.then(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p7 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;));</span><br><span class="line"><span class="keyword">let</span> p9 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject());</span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br></pre></td></tr></table></figure><p>抛出异常会返回拒绝的期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">let</span> p10 = p1.then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt; baz</span></span><br></pre></td></tr></table></figure><p>注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">let</span> p11 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;resolved&gt;: Error: qux</span></span><br></pre></td></tr></table></figure><p>onRejected 处理程序也与之类似：onRejected 处理程序返回的值也会被 Promise.resolve()包装。乍一看这可能有点违反直觉，但是想一想，onRejected 处理程序的任务不就是捕获异步错误吗？因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约。<br>下面的代码片段展示了用 Promise.reject()替代之前例子中的 Promise.resolve()之后的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用 then()时不传处理程序则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then();</span><br><span class="line"><span class="comment">// Uncaught (in promise) foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: foo</span></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p5 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p6 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p7 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;));</span><br><span class="line"><span class="keyword">let</span> p9 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject());</span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br><span class="line"><span class="keyword">let</span> p10 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt;: baz</span></span><br><span class="line"><span class="keyword">let</span> p11 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;resolved&gt;: Error: qux </span></span><br></pre></td></tr></table></figure><h3 id="3-Promise-prototype-catch"><a href="#3-Promise-prototype-catch" class="headerlink" title="3. Promise.prototype.catch()"></a>3. Promise.prototype.catch()</h3><p>Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype.then(null, onRejected)。</p><p>下面的代码展示了这两种同样的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject();</span><br><span class="line"><span class="keyword">let</span> onRejected = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这两种添加拒绝处理程序的方式是一样的：</span></span><br><span class="line">p.then(<span class="literal">null</span>, onRejected); <span class="comment">// rejected</span></span><br><span class="line">p.catch(onRejected); <span class="comment">// rejected</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch()返回一个新的期约实例：</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = p1.catch();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1 === p2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在返回新期约实例方面，Promise.prototype.catch()的行为与 Promise.prototype.then()的 onRejected 处理程序是一样的。</p><h3 id="4-Promise-prototype-finally"><a href="#4-Promise-prototype-finally" class="headerlink" title="4. Promise.prototype.finally()"></a>4. Promise.prototype.finally()</h3><p>Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject();</span><br><span class="line"><span class="keyword">let</span> onFinally = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;Finally!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">p1.finally(onFinally); <span class="comment">// Finally</span></span><br><span class="line">p2.finally(onFinally); <span class="comment">// Finally</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally()方法返回一个新的期约实例：</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1 === p2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这个新期约实例不同于 then()或 catch()方式返回的实例。因为 onFinally 被设计为一个状态无关的方法，所以在大多数情况下它将表现为父期约的传递。对于已解决状态和被拒绝状态都是如此。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 这里都会原样后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally();</span><br><span class="line"><span class="keyword">let</span> p3 = p1.finally(<span class="function">() =&gt;</span> <span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = p1.finally(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p5 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve());</span><br><span class="line"><span class="keyword">let</span> p6 = p1.finally(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p7 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> p8 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br></pre></td></tr></table></figure><p>如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝），如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p9 = p1.finally(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;));</span><br><span class="line"><span class="keyword">let</span> p10 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject());</span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br><span class="line"><span class="keyword">let</span> p11 = p1.finally(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;rejected&gt;: baz</span></span><br></pre></td></tr></table></figure><p>返回待定期约的情形并不常见，这是因为只要期约一解决，新期约仍然会原样后传初始的期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 忽略解决的值</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(</span><br><span class="line"> () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&#x27;bar&#x27;</span>), <span class="number">100</span>)));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2), <span class="number">200</span>);</span><br><span class="line"><span class="comment">// 200 毫秒后：</span></span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br></pre></td></tr></table></figure><h3 id="5-非重入期约方法"><a href="#5-非重入期约方法" class="headerlink" title="5. 非重入期约方法"></a>5. 非重入期约方法</h3><p>当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”（non-reentrancy）<br>特性。下面的例子演示了这个特性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建解决的期约</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="comment">// 添加解决处理程序</span></span><br><span class="line"><span class="comment">// 直觉上，这个处理程序会等期约一解决就执行</span></span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;onResolved handler&#x27;</span>));</span><br><span class="line"><span class="comment">// 同步输出，证明 then()已经返回</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;then() returns&#x27;</span>);</span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// then() returns</span></span><br><span class="line"><span class="comment">// onResolved handler</span></span><br></pre></td></tr></table></figure><p>在这个例子中，在一个解决期约上调用 then()会把 onResolved 处理程序推进消息队列。但这个处理程序在当前线程上的同步代码执行完成前不会执行。因此，跟在 then()后面的同步代码一定先于处理程序执行。</p><p>先添加处理程序后解决期约也是一样的。如果添加处理程序后，同步代码才改变期约状态，那么处理程序仍然会基于该状态变化表现出非重入特性。下面的例子展示了即使先添加了 onResolved 处理程序，再同步调用 resolve()，处理程序也不会进入同步线程执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> synchronousResolve;</span><br><span class="line"><span class="comment">// 创建一个期约并将解决函数保存在一个局部变量中</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line"> synchronousResolve = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;1: invoking resolve()&#x27;</span>);</span><br><span class="line"> resolve();</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;2: resolve() returns&#x27;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;4: then() handler executes&#x27;</span>));</span><br><span class="line">synchronousResolve();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3: synchronousResolve() returns&#x27;</span>);</span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// 1: invoking resolve()</span></span><br><span class="line"><span class="comment">// 2: resolve() returns</span></span><br><span class="line"><span class="comment">// 3: synchronousResolve() returns</span></span><br><span class="line"><span class="comment">// 4: then() handler executes</span></span><br></pre></td></tr></table></figure><p>在这个例子中，即使期约状态变化发生在添加处理程序之后，处理程序也会等到运行的消息队列让它出列时才会执行。</p><p>非重入适用于 onResolved/onRejected 处理程序、catch()处理程序和 finally()处理程序。下面的例子演示了这些处理程序都只能异步执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p1.then() onResolved&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p1.then() returns&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject();</span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p2.then() onRejected&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p2.then() returns&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.reject();</span><br><span class="line">p3.catch(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p3.catch() onRejected&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p3.catch() returns&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p4.finally(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p4.finally() onFinally&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p4.finally() returns&#x27;</span>);</span><br><span class="line"><span class="comment">// p1.then() returns</span></span><br><span class="line"><span class="comment">// p2.then() returns</span></span><br><span class="line"><span class="comment">// p3.catch() returns</span></span><br><span class="line"><span class="comment">// p4.finally() returns</span></span><br><span class="line"><span class="comment">// p1.then() onResolved</span></span><br><span class="line"><span class="comment">// p2.then() onRejected</span></span><br><span class="line"><span class="comment">// p3.catch() onRejected</span></span><br><span class="line"><span class="comment">// p4.finally() onFinally </span></span><br></pre></td></tr></table></figure><h3 id="6-邻近处理程序的执行顺序"><a href="#6-邻近处理程序的执行顺序" class="headerlink" title="6. 邻近处理程序的执行顺序"></a>6. 邻近处理程序的执行顺序</h3><p>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是 then()、catch()还是 finally()添加的处理程序都是如此。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject();</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">p2.catch(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">p2.catch(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line">p1.finally(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">7</span>));</span><br><span class="line">p1.finally(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 8 </span></span><br></pre></td></tr></table></figure><h3 id="7-传递解决值和拒绝理由"><a href="#7-传递解决值和拒绝理由" class="headerlink" title="7. 传递解决值和拒绝理由"></a>7. 传递解决值和拒绝理由</h3><p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 JSON 是发送第二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失败的网络请求也应该把 HTTP 状态码传给 onRejected 处理程序。</p><p>在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一参数。下面的例子展示了上述传递过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// foo</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">p2.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">console</span>.log(reason)); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve()和 <span class="built_in">Promise</span>.reject()在被调用时就会接收解决值和拒绝理由。同样地，它</span><br><span class="line">们返回的期约也会像执行器一样把这些值传给 onResolved 或 onRejected 处理程序：</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// foo</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">p2.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">console</span>.log(reason)); <span class="comment">// bar </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-拒绝期约与拒绝错误处理"><a href="#8-拒绝期约与拒绝错误处理" class="headerlink" title="8. 拒绝期约与拒绝错误处理"></a>8. 拒绝期约与拒绝错误处理</h3><p>拒绝期约类似于 throw()表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。因此以下这些期约都会以一个错误对象为由被拒绝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>)));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="comment">// 也会抛出 4 个未捕获错误</span></span><br></pre></td></tr></table></figure><p>期约可以以任何理由拒绝，包括 undefined，但最好统一使用错误对象。这样做主要是因为创建错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的。例如，前面例子中抛出的 4 个错误的栈追踪信息如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: foo</span><br><span class="line"> at <span class="built_in">Promise</span> (test.html:<span class="number">5</span>)</span><br><span class="line"> at <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="xml"><span class="tag">&lt;<span class="name">anonymous</span>&gt;</span>)</span></span><br><span class="line"><span class="xml"> at test.html:5</span></span><br><span class="line"><span class="xml">Uncaught (in promise) Error: foo</span></span><br><span class="line"><span class="xml"> at Promise (test.html:6)</span></span><br><span class="line"> at new Promise (&lt;anonymous&gt;)</span><br><span class="line"> at test.html:6</span><br><span class="line">Uncaught (in promise) Error: foo</span><br><span class="line"> at test.html:8</span><br><span class="line">Uncaught (in promise) Error: foo</span><br><span class="line"> at Promise.resolve.then (test.html:7)</span><br></pre></td></tr></table></figure><p>所有错误都是异步抛出且未处理的，通过错误对象捕获的栈追踪信息展示了错误发生的路径。注意错误的顺序：Promise.resolve().then()的错误最后才出现，这是因为它需要在运行时消息队列中添加处理程序；也就是说，在最终抛出未捕获错误之前它还会创建另一个期约。</p><p>这个例子同样揭示了异步错误有意思的副作用。正常情况下，在通过 throw()关键字抛出错误时，JavaScript 运行时的错误处理机制会停止执行抛出错误之后的任何指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// 这一行不会执行</span></span><br><span class="line"><span class="comment">// Uncaught Error: foo</span></span><br></pre></td></tr></table></figure><p>但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: foo</span></span><br></pre></td></tr></table></figure><p>如本章前面的 Promise.reject()示例所示，异步错误只能通过异步的 onRejected 处理程序捕获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>)).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">// 不正确</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用 try/catch 在执行函数中捕获错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"> resolve(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br></pre></td></tr></table></figure><p>then()和 catch()的 onRejected 处理程序在语义上相当于 try/catch。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此，onRejected 处理程序的任务应该是在捕获异步错误之后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;begin synchronous execution&#x27;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;caught error&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;continue synchronous execution&#x27;</span>);</span><br><span class="line"><span class="comment">// begin synchronous execution</span></span><br><span class="line"><span class="comment">// caught error Error: foo</span></span><br><span class="line"><span class="comment">// continue synchronous execution</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;begin asynchronous execution&#x27;</span>);</span><br><span class="line"> reject(<span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;caught error&#x27;</span>, e);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;continue asynchronous execution&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// begin asynchronous execution</span></span><br><span class="line"><span class="comment">// caught error Error: bar</span></span><br><span class="line"><span class="comment">// continue asynchronous execution </span></span><br></pre></td></tr></table></figure><h2 id="期约连锁与期约合成"><a href="#期约连锁与期约合成" class="headerlink" title="期约连锁与期约合成"></a>期约连锁与期约合成</h2><p>多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。</p><h3 id="1-期约连锁"><a href="#1-期约连锁" class="headerlink" title="1.期约连锁"></a>1.期约连锁</h3><p>把期约逐个地串联起来是一种非常有用的编程模式。之所以可以这样做，是因为每个期约实例的方法（then()、catch()和 finally()）都会返回一个新的期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;first&#x27;</span>);</span><br><span class="line"> resolve();</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;second&#x27;</span>))</span><br><span class="line"> .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;third&#x27;</span>))</span><br><span class="line"> .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;fourth&#x27;</span>));</span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"><span class="comment">// fourth</span></span><br></pre></td></tr></table></figure><p>这个实现最终执行了一连串同步任务。正因为如此，这种方式执行的任务没有那么有用，毕竟分别使用 4 个同步函数也可以做到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;first&#x27;</span>))();</span><br><span class="line">(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;second&#x27;</span>))();</span><br><span class="line">(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;third&#x27;</span>))();</span><br><span class="line">(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;fourth&#x27;</span>))();</span><br></pre></td></tr></table></figure><p>要真正执行异步任务，可以改写前面的例子，让每个执行器都返回一个期约实例。这样就可以让每个后续期约都等待之前的期约，也就是串行化异步任务。比如，可以像下面这样让每个期约在一定时间后解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;p1 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;p2 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line"> &#125;))</span><br><span class="line"> .then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;p3 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line"> &#125;))</span><br><span class="line"> .then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;p4 executor&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line"> &#125;));</span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br></pre></td></tr></table></figure><p>把生成期约的代码提取到一个工厂函数中，就可以写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedResolve</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(str);</span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125; </span><br><span class="line">delayedResolve(<span class="string">&#x27;p1 executor&#x27;</span>)</span><br><span class="line"> .then(<span class="function">() =&gt;</span> delayedResolve(<span class="string">&#x27;p2 executor&#x27;</span>))</span><br><span class="line"> .then(<span class="function">() =&gt;</span> delayedResolve(<span class="string">&#x27;p3 executor&#x27;</span>))</span><br><span class="line"> .then(<span class="function">() =&gt;</span> delayedResolve(<span class="string">&#x27;p4 executor&#x27;</span>))</span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br></pre></td></tr></table></figure><p>每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简洁地将异步任务串行化，解决之前依赖回调的难题。假如这种情况下不使用期约，那么前面的代码可能就要这样写了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedExecute</span>(<span class="params">str, callback = null</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(str);</span><br><span class="line"> callback &amp;&amp; callback();</span><br><span class="line"> &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">delayedExecute(<span class="string">&#x27;p1 callback&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> delayedExecute(<span class="string">&#x27;p2 callback&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> delayedExecute(<span class="string">&#x27;p3 callback&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> delayedExecute(<span class="string">&#x27;p4 callback&#x27;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// p1 callback（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 callback（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 callback（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 callback（4 秒后）</span></span><br></pre></td></tr></table></figure><p>心明眼亮的开发者会发现，这不正是期约所要解决的回调地狱问题吗？<br>因为 then()、catch()和 finally()都返回期约，所以串联这些方法也很直观。下面的例子同时使用这 3 个实例方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;initial promise rejects&#x27;</span>);</span><br><span class="line"> reject();</span><br><span class="line">&#125;);</span><br><span class="line">p.catch(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;reject handler&#x27;</span>))</span><br><span class="line"> .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;resolve handler&#x27;</span>))</span><br><span class="line"> .finally(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;finally handler&#x27;</span>));</span><br><span class="line"><span class="comment">// initial promise rejects</span></span><br><span class="line"><span class="comment">// reject handler</span></span><br><span class="line"><span class="comment">// resolve handler</span></span><br><span class="line"><span class="comment">// finally handler </span></span><br></pre></td></tr></table></figure><h3 id="2-期约图"><a href="#2-期约图" class="headerlink" title="2.期约图"></a>2.期约图</h3><p>因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。</p><p>下面的例子展示了一种期约有向图，也就是二叉树:<br>// A<br>// / <br>// B C<br>// /\ /<br>// D E F G<br>let A = new Promise((resolve, reject) =&gt; {<br> console.log(‘A’);<br> resolve();<br>});<br>let B = A.then(() =&gt; console.log(‘B’));<br>let C = A.then(() =&gt; console.log(‘C’));<br>B.then(() =&gt; console.log(‘D’));<br>B.then(() =&gt; console.log(‘E’));<br>C.then(() =&gt; console.log(‘F’));<br>C.then(() =&gt; console.log(‘G’));<br>// A<br>// B<br>// C<br>// D<br>// E<br>// F<br>// G </p><p>注意，日志的输出语句是对二叉树的层序遍历。如前所述，期约的处理程序是按照它们添加的顺序执行的。由于期约的处理程序是先添加到消息队列，然后才逐个执行，因此构成了层序遍历。</p><p>树只是期约图的一种形式。考虑到根节点不一定唯一，且多个期约也可以组合成一个期约（通过下一节介绍的 Promise.all()和 Promise.race()），所以有向非循环图是体现期约连锁可能性的最准确表达。</p><h3 id="3-Promise-all-和-Promise-race"><a href="#3-Promise-all-和-Promise-race" class="headerlink" title="3.Promise.all()和 Promise.race()"></a>3.Promise.all()和 Promise.race()</h3><p>Promise 类提供两个将多个期约实例组合成一个期约的静态方法：Promise.all()和 Promise.race()。而合成后期约的行为取决于内部期约的行为。</p><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p>Promise.all()静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([</span><br><span class="line"> <span class="built_in">Promise</span>.resolve(),</span><br><span class="line"> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过 Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.all([<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 空的可迭代对象等价于 Promise.resolve()</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.all([]);</span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all();</span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined </span></span><br></pre></td></tr></table></figure><p>合成的期约只会在每个包含的期约都解决之后才解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line"> <span class="built_in">Promise</span>.resolve(),</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;all() resolved!&#x27;</span>));</span><br><span class="line"><span class="comment">// all() resolved!（大约 1 秒后）</span></span><br></pre></td></tr></table></figure><p>如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 永远待定</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="comment">// 一次拒绝会导致最终期约拒绝</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.all([</span><br><span class="line"> <span class="built_in">Promise</span>.resolve(),</span><br><span class="line"> <span class="built_in">Promise</span>.reject(),</span><br><span class="line"> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) undefined</span></span><br></pre></td></tr></table></figure><p>如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line"> <span class="built_in">Promise</span>.resolve(),</span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>)</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function">(<span class="params">values</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, values)); <span class="comment">// [3, undefined, 4]</span></span><br></pre></td></tr></table></figure><p>如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入</span></span><br><span class="line"><span class="comment">// 拒绝处理程序，第二个期约的拒绝也</span></span><br><span class="line"><span class="comment">// 会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line"> <span class="built_in">Promise</span>.reject(<span class="number">3</span>),</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line">p.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, reason)); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p>Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个方法接收一个可迭代对象，返回一个新期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.race([</span><br><span class="line"> <span class="built_in">Promise</span>.resolve(),</span><br><span class="line"> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过 Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.race([<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 空的可迭代对象等价于 new Promise(() =&gt; &#123;&#125;)</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.race([]);</span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race();</span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br></pre></td></tr></table></figure><p>Promise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，Promise.race()就会包装其解决值或拒绝理由并返回新期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决先发生，超时后的拒绝被忽略</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.race([</span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"><span class="comment">// 拒绝先发生，超时后的解决被忽略</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.race([</span><br><span class="line"> <span class="built_in">Promise</span>.reject(<span class="number">4</span>),</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: 4</span></span><br><span class="line"><span class="comment">// 迭代顺序决定了落定顺序</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.race([</span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">5</span>),</span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">6</span>),</span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">7</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: 5</span></span><br></pre></td></tr></table></figure><p>如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。与 Promise.all()类似，合成的期约会静默处理所有包含期约的拒绝操作，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入</span></span><br><span class="line"><span class="comment">// 拒绝处理程序，第二个期约的拒绝也</span></span><br><span class="line"><span class="comment">// 会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line"> <span class="built_in">Promise</span>.reject(<span class="number">3</span>),</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line">p.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, reason)); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure><h3 id="4-串行期约合成"><a href="#4-串行期约合成" class="headerlink" title="4.串行期约合成"></a>4.串行期约合成</h3><p>到目前为止，我们讨论期约连锁一直围绕期约的串行执行，忽略了期约的另一个主要特性：异步产生值并将其传给处理程序。基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。这很像函数合成，即将多个函数合成为一个函数，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> addFive(addTwo(addThree(x)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(addTen(<span class="number">7</span>)); <span class="comment">// 17 </span></span><br></pre></td></tr></table></figure><p>在这个例子中，有 3 个函数基于一个值合成为一个函数。类似地，期约也可以像这样合成起来，渐进地消费一个值，并返回一个结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(x)</span><br><span class="line"> .then(addTwo)</span><br><span class="line"> .then(addThree)</span><br><span class="line"> .then(addFive);</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18 </span></span><br></pre></td></tr></table></figure><p>使用 Array.prototype.reduce()可以写成更简洁的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> [addTwo, addThree, addFive]</span><br><span class="line"> .reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.then(fn), <span class="built_in">Promise</span>.resolve(x));</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18 </span></span><br></pre></td></tr></table></figure><p>这种模式可以提炼出一个通用函数，可以把任意多个函数作为处理程序合成一个连续传值的期约连锁。这个通用的合成函数可以这样实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function">(<span class="params">x</span>) =&gt;</span> fns.reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.then(fn), <span class="built_in">Promise</span>.resolve(x))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> addTen = compose(addTwo, addThree, addFive);</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><h2 id="期约扩展"><a href="#期约扩展" class="headerlink" title="期约扩展"></a>期约扩展</h2><p>ES6 期约实现是很可靠的，但它也有不足之处。比如，很多第三方期约库实现中具备而 ECMAScript规范却未涉及的两个特性：期约取消和进度追踪。</p><h3 id="1-期约取消"><a href="#1-期约取消" class="headerlink" title="1. 期约取消"></a>1. 期约取消</h3><p>我们经常会遇到期约正在处理过程中，程序却不再需要其结果的情形。这时候如果能够取消期约就好了。某些第三方库，比如 Bluebird，就提供了这个特性。实际上，TC39 委员会也曾准备增加这个特性，但相关提案最终被撤回了。结果，ES6 期约被认为是“激进的”：只要期约的逻辑开始执行，就没有办法阻止它执行到完成。</p><p>实际上，可以在现有实现基础上提供一种临时性的封装，以实现取消期约的功能。这可以用到 KevinSmith 提到的“取消令牌”（cancel token）。生成的令牌实例提供了一个接口，利用这个接口可以取消期约；同时也提供了一个期约的实例，可以用来触发取消后的操作并求值取消状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelToken</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(cancelFn) &#123;</span><br><span class="line"> <span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> cancelFn(resolve);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个类包装了一个期约，把解决方法暴露给了 cancelFn 参数。这样，外部代码就可以向构造函数中传入一个函数，从而控制什么情况下可以取消期约。这里期约是令牌类的公共成员，因此可以给它添加处理程序以取消期约。</p><p>这个类大概可以这样使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span>&gt;</span>Start<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;cancel&quot;</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">CancelToken</span> </span>&#123;</span></span><br><span class="line"><span class="javascript"> <span class="keyword">constructor</span>(cancelFn) &#123;</span></span><br><span class="line"><span class="javascript"> <span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"> cancelFn(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&quot;delay cancelled&quot;</span>);</span></span><br><span class="line"> resolve();</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="keyword">const</span> startButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#start&#x27;</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> cancelButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#cancel&#x27;</span>);</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">cancellableDelayedResolve</span>(<span class="params">delay</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&quot;set delay&quot;</span>);</span></span><br><span class="line"><span class="javascript"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"> <span class="keyword">const</span> id = <span class="built_in">setTimeout</span>((<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&quot;delayed resolve&quot;</span>);</span></span><br><span class="line"> resolve();</span><br><span class="line"> &#125;), delay); </span><br><span class="line"><span class="javascript"><span class="keyword">const</span> cancelToken = <span class="keyword">new</span> CancelToken(<span class="function">(<span class="params">cancelCallback</span>) =&gt;</span></span></span><br><span class="line"><span class="javascript"> cancelButton.addEventListener(<span class="string">&quot;click&quot;</span>, cancelCallback));</span></span><br><span class="line"><span class="javascript"> cancelToken.promise.then(<span class="function">() =&gt;</span> <span class="built_in">clearTimeout</span>(id));</span></span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript">startButton.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> cancellableDelayedResolve(<span class="number">1000</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每次单击“Start”按钮都会开始计时，并实例化一个新的 CancelToken 的实例。此时，“Cancel”按钮一旦被点击，就会触发令牌实例中的期约解决。而解决之后，单击“Start”按钮设置的超时也会被取消。</p><h3 id="2-期约进度通知"><a href="#2-期约进度通知" class="headerlink" title="2. 期约进度通知"></a>2. 期约进度通知</h3><p>执行中的期约可能会有不少离散的“阶段”，在最终解决之前必须依次经过。某些情况下，监控期<br>约的执行进度会很有用。ECMAScript 6 期约并不支持进度追踪，但是可以通过扩展来实现。<br>一种实现方式是扩展 Promise 类，为它添加 notify()方法，如下所示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackablePromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line"> <span class="keyword">const</span> notifyHandlers = [];</span><br><span class="line"> <span class="built_in">super</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> executor(resolve, reject, <span class="function">(<span class="params">status</span>) =&gt;</span> &#123;</span><br><span class="line"> notifyHandlers.map(<span class="function">(<span class="params">handler</span>) =&gt;</span> handler(status));</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">this</span>.notifyHandlers = notifyHandlers;</span><br><span class="line"> &#125;</span><br><span class="line"> notify(notifyHandler) &#123;</span><br><span class="line"> <span class="built_in">this</span>.notifyHandlers.push(notifyHandler);</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样，TrackablePromise 就可以在执行函数中使用 notify()函数了。可以像下面这样使用这个函数来实例化一个期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> TrackablePromise(<span class="function">(<span class="params">resolve, reject, notify</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> notify(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>% remaining`</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> countdown(x - <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> resolve();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> countdown(<span class="number">5</span>);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>这个期约会连续5次递归地设置1000毫秒的超时。每个超时回调都会调用notify()并传入状态值。假设通知处理程序简单地这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> TrackablePromise(<span class="function">(<span class="params">resolve, reject, notify</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> notify(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>% remaining`</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> countdown(x - <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> resolve();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> countdown(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.notify(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;progress:&#x27;</span>, x));</span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;completed&#x27;</span>));</span><br><span class="line"><span class="comment">// （约 1 秒后）80% remaining</span></span><br><span class="line"><span class="comment">// （约 2 秒后）60% remaining</span></span><br><span class="line"><span class="comment">// （约 3 秒后）40% remaining</span></span><br><span class="line"><span class="comment">// （约 4 秒后）20% remaining</span></span><br><span class="line"><span class="comment">// （约 5 秒后）completed </span></span><br></pre></td></tr></table></figure><p>notify()函数会返回期约，所以可以连缀调用，连续添加处理程序。多个处理程序会针对收到的每条消息分别执行一遍，如下所示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line">p.notify(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;a:&#x27;</span>, x))</span><br><span class="line">.notify(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;b:&#x27;</span>, x));</span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;completed&#x27;</span>));</span><br><span class="line"><span class="comment">// （约 1 秒后） a: 80% remaining</span></span><br><span class="line"><span class="comment">// （约 1 秒后） b: 80% remaining</span></span><br><span class="line"><span class="comment">// （约 2 秒后） a: 60% remaining</span></span><br><span class="line"><span class="comment">// （约 2 秒后） b: 60% remaining</span></span><br><span class="line"><span class="comment">// （约 3 秒后） a: 40% remaining</span></span><br><span class="line"><span class="comment">// （约 3 秒后） b: 40% remaining</span></span><br><span class="line"><span class="comment">// （约 4 秒后） a: 20% remaining</span></span><br><span class="line"><span class="comment">// （约 4 秒后） b: 20% remaining </span></span><br></pre></td></tr></table></figure><p>总体来看，这还是一个比较粗糙的实现，但应该可以演示出如何使用通知报告进度了。</p><hr><h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><p>异步函数，也称为“async/await”（语法关键字），是 ES6 期约模式在 ECMAScript 函数中的应用。async/await 是 ES8 规范新增的。这个特性从行为和语法上都增强了 JavaScript，让以同步方式写的代码能够异步执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> </span><br><span class="line"><span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>)); </span><br></pre></td></tr></table></figure><p>这个期约在 1000 毫秒之后解决为数值 3。如果程序中的其他代码要在这个值可用时访问它，则需要写一个解决处理程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> </span><br><span class="line"><span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>)); </span><br><span class="line">p.then(<span class="function">(<span class="params">x</span>) =&gt;</span> </span><br><span class="line"><span class="built_in">console</span>.log(x)); <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>这其实是很不方便的，因为其他代码都必须塞到期约处理程序中。不过可以把处理程序定义为一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">x</span>) </span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">console</span>.log(x); &#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> </span><br><span class="line"><span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.then(handler); <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>这个改进其实也不大。这是因为任何需要访问这个期约所产生值的代码，都需要以处理程序的形式来接收这个值。也就是说，代码照样还是要放到处理程序里。ES8 为此提供了 async/await 关键字。</p><hr><p>ES8 的 async/await 旨在解决利用异步结构组织代码的问题。为此，ECMAScript 对函数进行了扩展，为其增加了两个新关键字：async 和 await。</p><h3 id="1-async"><a href="#1-async" class="headerlink" title="1. async"></a>1. async</h3><p>async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;</span><br><span class="line"> <span class="keyword">async</span> qux() &#123;&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用 async 关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭包方面，异步函数仍然具有普通 JavaScript 函数的正常行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><p>不过，异步函数如果使用 return 关键字返回了值（如果没有 return 则会返回 undefined），这个值会被 Promise.resolve()包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line">foo().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>当然，直接返回一个期约对象也是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line">foo().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>异步函数的返回值期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。如果返回的是实现 thenable 接口的对象，则这个对象可以由提供给 then()的处理程序“解包”。如果不是，则返回值就被当作已经解决的期约。下面的代码演示了这些情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 返回一个没有实现 thenable 接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">bar().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"><span class="comment">// 返回一个实现了 thenable 接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> thenable = &#123;</span><br><span class="line"> then(callback) &#123; callback(<span class="string">&#x27;baz&#x27;</span>); &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> thenable;</span><br><span class="line">&#125;</span><br><span class="line">baz().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 返回一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">qux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">qux().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// qux</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line">不过，拒绝期约的错误不会被异步函数捕获：</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Attach a rejected handler to the returned promise</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Uncaught (in promise): 3 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-await"><a href="#2-await" class="headerlink" title="2. await"></a>2. await</h3><p>因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用 await关键字可以暂停异步函数代码的执行，等待期约解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> </span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> p);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>注意，await 关键字会暂停执行异步函数后面的代码，让出 JavaScript 运行时的执行线程。这个行为与生成器函数中的 yield 关键字是一样的。await 关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行<br>await 关键字的用法与 JavaScript 的一元操作一样。它可以单独使用，也可以在表达式中使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步打印&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 异步打印&quot;bar&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// 1000 毫秒后异步打印&quot;baz&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">baz();</span><br><span class="line"><span class="comment">// baz（1000 毫秒后）</span></span><br></pre></td></tr></table></figure><p>await 关键字期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。如果是实现 thenable 接口的对象，则这个对象可以由 await 来“解包”。如果不是，则这个值就被当作已经解决的期约。下面的代码演示了这些情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 等待一个没有实现 thenable 接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> [<span class="string">&#x27;bar&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"><span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"><span class="comment">// 等待一个实现了 thenable 接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> thenable = &#123;</span><br><span class="line"> then(callback) &#123; callback(<span class="string">&#x27;baz&#x27;</span>); &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> thenable);</span><br><span class="line">&#125;</span><br><span class="line">baz();</span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 等待一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">qux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">qux();</span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure><p>等待会抛出错误的同步操作，会返回拒绝的期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">await</span> (<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="number">3</span>; &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>如前面的例子所示，单独的 Promise.reject()不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用 await 则会释放（unwrap）错误值（将拒绝期约返回）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">4</span>); <span class="comment">// 这行代码不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><h3 id="3-await的限制"><a href="#3-await的限制" class="headerlink" title="3. await的限制"></a>3. await的限制</h3><p>await 关键字必须在异步函数中使用，不能在顶级上下文如script标签或模块中使用。不过，定义并立即调用异步函数是没问题的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 立即调用的异步函数表达式</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>));</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>此外，异步函数的特质不会扩展到嵌套函数。因此，await 关键字也只能直接出现在异步函数的定义中。在同步函数内部使用 await 会抛出 SyntaxError。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不允许：await 出现在了箭头函数中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> syncFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="built_in">console</span>.log(syncFn()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不允许：await 出现在了同步函数声明中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">syncFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(syncFn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不允许：await 出现在了同步函数表达式中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> syncFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="built_in">console</span>.log(syncFn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不允许：IIFE 使用同步函数表达式或箭头函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>)); &#125;)();</span><br><span class="line"> (<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>)))();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="停止和恢复执行"><a href="#停止和恢复执行" class="headerlink" title="停止和恢复执行"></a>停止和恢复执行</h3><p>使用 await 关键字之后的区别其实比看上去的还要微妙一些。比如，下面的例子中按顺序调用了 3个函数，但它们的输出结果顺序是相反的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">bar();</span><br><span class="line">baz();</span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// foo </span></span><br></pre></td></tr></table></figure><p>async/await 中真正起作用的是 await。async 关键字，无论从哪方面来看，都不过是一个标识符。毕竟，异步函数如果不包含 await 关键字，其执行基本上跟普通函数没有什么区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>要完全理解 await 关键字，必须知道它并非只是等待一个值可用那么简单。JavaScript 运行时在碰到 await 关键字时，会记录在哪里暂停执行。等到 await 右边的值可用了，JavaScript 运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。</p><p>因此，即使 await 后面跟着一个立即可用的值，函数的其余部分也会被异步求值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">await</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><ul><li>打印 1；</li><li>调用异步函数 foo()；</li><li>（在 foo()中）打印 2；</li><li>（在 foo()中）await 关键字暂停执行，为立即可用的值 null 向消息队列中添加一个任务；</li><li>foo()退出；</li><li>打印 3；</li><li>同步线程的代码执行完毕；</li><li>JavaScript 运行时从消息队列中取出任务，恢复异步函数执行；</li><li>（在 foo()中）恢复执行，await 取得 null 值（这里并没有使用）；</li><li>（在 foo()中）打印 4；</li><li>foo()返回。</li></ul><hr><h2 id="异步函数策略"><a href="#异步函数策略" class="headerlink" title="异步函数策略"></a>异步函数策略</h2><p>因为简单实用，所以异步函数很快成为 JavaScript 项目使用最广泛的特性之一。不过，在使用异步函数时，还是有些问题要注意。</p><h3 id="1-实现-sleep"><a href="#1-实现-sleep" class="headerlink" title="1. 实现 sleep()"></a>1. 实现 sleep()</h3><p>有了异步函数之后，就不一样了。一个简单的箭头函数就可以实现 sleep()：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line"> <span class="keyword">await</span> sleep(<span class="number">1500</span>); <span class="comment">// 暂停约 1500 毫秒</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - t0);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 1502 </span></span><br></pre></td></tr></table></figure><h3 id="2-利用平行执行"><a href="#2-利用平行执行" class="headerlink" title="2. 利用平行执行"></a>2. 利用平行执行</h3><p>如果使用 await 时不留心，则很可能错过平行加速的机会。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line"> <span class="keyword">const</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line"> resolve();</span><br><span class="line"> &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line"> <span class="keyword">await</span> randomDelay(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">await</span> randomDelay(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">await</span> randomDelay(<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">await</span> randomDelay(<span class="number">3</span>);</span><br><span class="line"> <span class="keyword">await</span> randomDelay(<span class="number">4</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 877ms elapsed </span></span><br></pre></td></tr></table></figure><p>用一个 for 循环重写，就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line"> <span class="keyword">const</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line"> resolve();</span><br><span class="line"> &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"> <span class="keyword">await</span> randomDelay(i);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 877ms elapsed </span></span><br></pre></td></tr></table></figure><p>就算这些期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序，但总执行时间会变长。</p><p>如果顺序不是必需保证的，那么可以先一次性初始化所有期约，然后再分别等待它们的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line"> <span class="keyword">const</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line"> resolve();</span><br><span class="line"> &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line"> <span class="keyword">const</span> p0 = randomDelay(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">const</span> p1 = randomDelay(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">const</span> p2 = randomDelay(<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">const</span> p3 = randomDelay(<span class="number">3</span>);</span><br><span class="line"> <span class="keyword">const</span> p4 = randomDelay(<span class="number">4</span>);</span><br><span class="line"> <span class="keyword">await</span> p0;</span><br><span class="line"> <span class="keyword">await</span> p1;</span><br><span class="line"> <span class="keyword">await</span> p2;</span><br><span class="line"> <span class="keyword">await</span> p3;</span><br><span class="line"> <span class="keyword">await</span> p4;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 1 finished </span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 877ms elapsed</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用数组和 for 循环再包装一下就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line"> <span class="keyword">const</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line"> resolve();</span><br><span class="line"> &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line"> <span class="keyword">const</span> promises = <span class="built_in">Array</span>(<span class="number">5</span>).fill(<span class="literal">null</span>).map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> randomDelay(i));</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line"> <span class="keyword">await</span> p;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 877ms elapsed</span></span><br></pre></td></tr></table></figure><p>注意，虽然期约没有按照顺序执行，但 await 按顺序收到了每个期约的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line"> <span class="keyword">const</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line"> resolve(id);</span><br><span class="line"> &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line"> <span class="keyword">const</span> promises = <span class="built_in">Array</span>(<span class="number">5</span>).fill(<span class="literal">null</span>).map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> randomDelay(i));</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`awaited <span class="subst">$&#123;<span class="keyword">await</span> p&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); </span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// awaited 0</span></span><br><span class="line"><span class="comment">// awaited 1</span></span><br><span class="line"><span class="comment">// awaited 2</span></span><br><span class="line"><span class="comment">// awaited 3</span></span><br><span class="line"><span class="comment">// awaited 4</span></span><br><span class="line"><span class="comment">// 645ms elapsed </span></span><br></pre></td></tr></table></figure><h3 id="3-串行执行期约"><a href="#3-串行执行期约" class="headerlink" title="3. 串行执行期约"></a>3. 串行执行期约</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123;</span><br><span class="line"> x = <span class="keyword">await</span> fn(x);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">9</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure><p>这里，await 直接传递了每个函数的返回值，结果通过迭代产生。当然，这个例子并没有使用期约，<br>如果要使用期约，则可以把所有函数都改成异步函数。这样它们就都返回期约了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123;</span><br><span class="line"> x = <span class="keyword">await</span> fn(x);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">9</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 19 </span></span><br></pre></td></tr></table></figure><h3 id="4-栈追踪与内存管理"><a href="#4-栈追踪与内存管理" class="headerlink" title="4.栈追踪与内存管理"></a>4.栈追踪与内存管理</h3><p>期约与异步函数的功能有相当程度的重叠，但它们在内存中的表示则差别很大。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(fooPromiseExecutor);</span><br><span class="line">&#125; </span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br><span class="line"><span class="comment">// setTimeout (async)</span></span><br><span class="line"><span class="comment">// fooPromiseExecutor</span></span><br><span class="line"><span class="comment">// foo </span></span><br></pre></td></tr></table></figure><p>  根据对期约的不同理解程度，以上栈追踪信息可能会让某些读者不解。栈追踪信息应该相当直接地<br>表现 JavaScript 引擎当前栈内存中函数调用之间的嵌套关系。在超时处理程序执行时和拒绝期约时，我<br>们看到的错误信息包含嵌套函数的标识符，那是被调用以创建最初期约实例的函数。可是，我们知道这<br>些函数已经返回了，因此栈追踪信息中不应该看到它们。<br>答案很简单，这是因为 JavaScript 引擎会在创建期约时尽可能保留完整的调用栈。在抛出错误时，<br>调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。当然，这意味着栈追踪信息<br>会占用内存，从而带来一些计算和存储成本。</p>]]></content>
    
    
    <summary type="html">期约与异步</summary>
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="期约与异步" scheme="http://example.com/tags/%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之函数</title>
    <link href="http://example.com/2020/10/30/%E7%BA%A2%E5%AE%9D%E4%B9%A611/"/>
    <id>http://example.com/2020/10/30/%E7%BA%A2%E5%AE%9D%E4%B9%A611/</id>
    <published>2020-10-30T05:06:43.000Z</published>
    <updated>2020-11-10T06:54:37.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函-数"><a href="#函-数" class="headerlink" title="函 数"></a>函 数</h1><p>函数是ECMAScript中最有意思的部分之一，这主要是因为函数实际上是对象。每个函数都是Function类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。函数通常以函数声明的方式定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     alert(<span class="string">&quot;我是一个函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//函数的调用</span></span><br><span class="line"> myfun();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个带有参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> sum = (num1 + num2);</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">99</span>, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">-15</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure><hr><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p> ECMAScript 6 新增了使用胖箭头（=&gt;）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> S = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> Sum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(S(<span class="number">5</span>, <span class="number">8</span>)); <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(Sum(<span class="number">5</span>, <span class="number">8</span>)); <span class="comment">// 13 </span></span><br></pre></td></tr></table></figure><p> 箭头函数简洁的语法非常适合嵌入函数的场景</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</span></span><br><span class="line"><span class="keyword">let</span> int = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    int.map(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>; &#125;</span><br><span class="line">    )); </span><br><span class="line">    <span class="comment">// [2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    int.map(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span> </span><br><span class="line">        &#125;)); </span><br><span class="line">        <span class="comment">// [2, 3, 4] </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都有效</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">let</span> triple = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">3</span> * x; </span><br><span class="line">     &#125;;</span><br><span class="line"><span class="comment">// 没有参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> getRandom = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Math</span>.random();</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="comment">// 多个参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 无效的写法：</span></span><br><span class="line"><span class="keyword">let</span> multiply = a, <span class="function"><span class="params">b</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> a * b; </span><br><span class="line">    &#125;; </span><br></pre></td></tr></table></figure><p> 箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都有效，而且返回相应的值</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">2</span> * x; </span><br><span class="line">     &#125;;</span><br><span class="line"><span class="keyword">let</span> triple = <span class="function">(<span class="params">x</span>) =&gt;</span></span><br><span class="line"> <span class="number">3</span> * x;</span><br><span class="line"><span class="comment">// 可以赋值</span></span><br><span class="line"><span class="keyword">let</span> value = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> setName = <span class="function">(<span class="params">x</span>) =&gt;</span> </span><br><span class="line">    x.name = <span class="string">&quot;Matt&quot;</span>;</span><br><span class="line">setName(value);</span><br><span class="line"><span class="built_in">console</span>.log(value.name); <span class="comment">// &quot;Matt&quot;</span></span><br><span class="line"><span class="comment">// 无效的写法：</span></span><br><span class="line"><span class="keyword">let</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> </span><br><span class="line"><span class="keyword">return</span> a * b; </span><br></pre></td></tr></table></figure><p>箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用 arguments、super 和new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。</p><hr><h2 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h2><p>因为函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个名称</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aSum = sum;</span><br><span class="line"><span class="built_in">console</span>.log(aSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20 </span></span><br></pre></td></tr></table></figure><p>以上代码定义了一个名为 sum()的函数，用于求两个数之和。然后又声明了一个变量 aSum，并将它的值设置为等于 sum。注意，使用不带括号的函数名会访问函数指针，而不会执行函数。此时，aSum 和 sum 都指向同一个函数。调用 aSum()也可以返回结果。把 sum 设置为 null之后，就切断了它与函数之间的关联。而 aSum()还是可以照常调用，没有问题。</p><p>ECMAScript 6 的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用 Function 构造函数创建的，则会标识成”anonymous”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.name); <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.name); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.name); <span class="comment">// baz</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function">() =&gt;</span> &#123;&#125;).name); <span class="comment">//（空字符串）</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name); <span class="comment">// anonymous </span></span><br></pre></td></tr></table></figure><p>如果函数是一个获取函数、设置函数，或者使用 bind()实例化，那么标识符前面会加上一个前缀：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bind(<span class="literal">null</span>).name); <span class="comment">// bound foo</span></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line"> years: <span class="number">1</span>,</span><br><span class="line"> <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.years;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="keyword">set</span> <span class="title">age</span>(<span class="params">newAge</span>) &#123;</span><br><span class="line"> <span class="built_in">this</span>.years = newAge;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(dog, <span class="string">&#x27;age&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor.get.name); <span class="comment">// get age</span></span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor.set.name); <span class="comment">// set age </span></span><br></pre></td></tr></table></figure><hr><h2 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h2><p>ECMAScript 函数的参数跟大多数其他语言不同。ECMAScript 函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。</p><p>之所以会这样，主要是因为 ECMAScript 函数的参数在内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。事实上，在使用 function 关键字定义（非箭头）函数时，可以在函数内部访问 arguments 对象，从中取得传进来的每个参数值。</p><p>arguments 对象是一个类数组对象（但不是 Array 的实例），因此可以使用中括号语法访问其中的元素（第一个参数是 arguments[0]，第二个参数是 arguments[1]）。而要确定传进来多少个参数，可以访问 arguments.length 属性。</p><p> 在下面的例子中，sayHi()函数的第一个参数叫 name：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以通过 arguments[0]取得相同的参数值。因此，把函数重写成不声明参数也可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p> 也可以通过 arguments 对象的 length 属性检查传入的参数个数。下面的例子展示了在每调用一个函数时，都会打印出传入的参数个数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Args</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">        &#125;</span><br><span class="line">Args(<span class="string">&quot;string&quot;</span>, <span class="number">45</span>); <span class="comment">// 2   俩参数</span></span><br><span class="line">Args(); <span class="comment">// 0       你就没传参数</span></span><br><span class="line">Args(<span class="number">12</span>); <span class="comment">// 1      一个~！~~</span></span><br></pre></td></tr></table></figure><p>既然如此，那么开发者可以想传多少参数就传多少参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="number">10</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">doAdd(<span class="number">10</span>); <span class="comment">// 20</span></span><br><span class="line">doAdd(<span class="number">30</span>, <span class="number">20</span>); <span class="comment">// 50 </span></span><br></pre></td></tr></table></figure><p>这个函数 doAdd()在只传一个参数时会加 10，在传两个参数时会将它们相加，然后返回。因此doAdd(10)返回 20，而 doAdd(30,20)返回 50。虽然不像真正的函数重载那么明确，但这已经足以弥补 ECMAScript 在这方面的缺失了。</p><p>还有一个必须理解的重要方面，那就是 arguments 对象可以跟命名参数一起使用，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(num1 + <span class="number">10</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>arguments 对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个 doAdd()函数把第二个参数的值重写为 10。因为 arguments 对象的值会自动同步到对应的命名参数，所以修改 arguments[1]也会修改 num2 的值，因此两者的值都是 10。但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。另外还要记住一点：如果只传了一个参数，然后把 arguments[1]设置为某个值，那么这个值并不会反映到第二个命名参数。这是因为 arguments 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的。对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是 undefined。这就类似于定义了变量而没有初始化。比如，如果只给 doAdd()传了一个参数，那么 num2 的值就是 undefined。</p><p>严格模式下，arguments 会有一些变化。首先，像前面那样给 arguments[1]赋值不会再影响 num2的值。就算把 arguments[1]设置为 10，num2 的值仍然还是传入的值。其次，在函数中尝试重写arguments 对象会导致语法错误。（代码也不会执行。）</p><hr><h2 id="箭头函数中的参数"><a href="#箭头函数中的参数" class="headerlink" title="箭头函数中的参数"></a>箭头函数中的参数</h2><p>如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只能通过定义的命名参数访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br><span class="line">bar(<span class="number">5</span>); <span class="comment">// ReferenceError: arguments is not defined </span></span><br></pre></td></tr></table></figure><p>虽然箭头函数中没有 arguments 对象，但可以在包装函数中把它提供给箭头函数，我们称之为嵌套：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> bar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 5</span></span><br><span class="line"> &#125;;</span><br><span class="line"> bar();</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>); </span><br></pre></td></tr></table></figure><p>ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。</p><hr><h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><p>ECMAScript 函数不能像传统编程那样重载。在其他语言比如 Java 中，一个函数可以有两个定义，只要签名（接收参数的类型和数量）不同就行。如前所述，ECMAScript 函数没有签名，因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。</p><p>如果在 ECMAScript 中定义了两个同名函数，则后定义的会覆盖先定义的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aer</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aer</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = aer(<span class="number">100</span>); <span class="comment">// 300 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aer = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">aer = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> result = aer(<span class="number">100</span>); <span class="comment">// 300</span></span><br></pre></td></tr></table></figure><p>看这段代码应该更容易理解发生了什么。在创建第二个函数时，变量 addSomeNumber 被重写成保存第二个函数对象了。</p><hr><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><p>在 ECMAScript5.1 及以前，实现默认参数的一种常用方式就是检测某个参数是否等于 undefined，如果是则意味着没有传这个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mg</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> name = (<span class="keyword">typeof</span> name !== <span class="string">&#x27;undefined&#x27;</span>) ? name : <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mg()); <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(mg(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis VIII&#x27; </span></span><br></pre></td></tr></table></figure><p>ECMAScript 6 之后就不用这么麻烦了，因为它支持显式定义默认参数了。下面就是与前面代码等价的 ES6 写法，只要在函数定义中的参数后面用=就可以为参数赋一个默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mg</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mg(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(mg()); <span class="comment">// &#x27;King Henry VIII&#x27; </span></span><br></pre></td></tr></table></figure><p>给参数传 undefined 相当于没有传值，不过这样可以利用多个独立的默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="literal">undefined</span>, <span class="string">&#x27;VI&#x27;</span>)); <span class="comment">// &#x27;King Henry VI&#x27;</span></span><br></pre></td></tr></table></figure><p>在使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数。当然，跟 ES5 严格模式一样，修改命名参数也不会影响 arguments 对象，它始终以调用函数时传入的值为准：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) </span>&#123;</span><br><span class="line"> name = <span class="string">&#x27;Louis&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;<span class="built_in">arguments</span>[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// &#x27;King undefined&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis&#x27;</span></span><br></pre></td></tr></table></figure><p>默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> romanNumerals = [<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;II&#x27;</span>, <span class="string">&#x27;III&#x27;</span>, <span class="string">&#x27;IV&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;VI&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> ordinality = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumerals</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 每次调用后递增</span></span><br><span class="line"> <span class="keyword">return</span> romanNumerals[ordinality++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = getNumerals()</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// &#x27;King Henry I&#x27; </span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>, <span class="string">&#x27;XVI&#x27;</span>)); <span class="comment">// &#x27;King Louis XVI&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// &#x27;King Henry II&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// &#x27;King Henry III&#x27;</span></span><br></pre></td></tr></table></figure><p>函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。</p><p>箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> makeKing = <span class="function">(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) =&gt;</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// King Henry </span></span><br></pre></td></tr></table></figure><h3 id="默认参数作用域与暂时性死区"><a href="#默认参数作用域与暂时性死区" class="headerlink" title="默认参数作用域与暂时性死区"></a>默认参数作用域与暂时性死区</h3><p>因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的。</p><p>给多个参数定义默认值实际上跟使用 let 关键字顺序声明变量一样。来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// King Henry VIII</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的默认参数会按照定义它们的顺序依次被初始化。可以依照如下示例想象一下这个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> name = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line"> <span class="keyword">let</span> numerals = <span class="string">&#x27;VIII&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。看下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = name</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// King Henry Henry</span></span><br></pre></td></tr></table></figure><p>参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。像这样就会抛出错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用时不传第一个参数会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = numerals, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数也存在于自己的作用域中，它们不能引用函数体的作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用时不传第二个参数会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = defaultNumeral</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> defaultNumeral = <span class="string">&#x27;VIII&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h2 id="参数扩展与收集"><a href="#参数扩展与收集" class="headerlink" title="参数扩展与收集"></a>参数扩展与收集</h2><p> ECMAScript 6 新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据。扩展操作符最有用的场景就是函数定义中的参数列表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特点。扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。</p><h3 id="扩展参数"><a href="#扩展参数" class="headerlink" title="扩展参数"></a>扩展参数</h3><p>在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。假设有如下函数定义，它会将所有传入的参数累加起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line"> sum += <span class="built_in">arguments</span>[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>希望将所有加数逐个传进来，然后通过迭代 arguments 对象来实现累加。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于 apply()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getSum.apply(<span class="literal">null</span>, values)); <span class="comment">// 10 </span></span><br></pre></td></tr></table></figure><p>但在 ECMAScript 6 中，可以通过扩展操作符极为简洁地实现这种操作。对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getSum(...values)); <span class="comment">// 10 </span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">-1</span>, ...values)); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...values, <span class="number">5</span>)); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">-1</span>, ...values, <span class="number">5</span>)); <span class="comment">// 14</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...values, ...[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])); <span class="comment">// 28 </span></span><br></pre></td></tr></table></figure><p>对函数中的 arguments 对象而言，它并不知道扩展操作符的存在，而是按照调用函数时传入的参数接收每一个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line">countArguments(<span class="number">-1</span>, ...values); <span class="comment">// 5</span></span><br><span class="line">countArguments(...values, <span class="number">5</span>); <span class="comment">// 5</span></span><br><span class="line">countArguments(<span class="number">-1</span>, ...values, <span class="number">5</span>); <span class="comment">// 6</span></span><br><span class="line">countArguments(...values, ...[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]); <span class="comment">// 7 </span></span><br></pre></td></tr></table></figure><p>在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params">a, b, c = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getSum = <span class="function">(<span class="params">a, b, c = <span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>])); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>,<span class="number">1</span>])); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><h3 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h3><p>在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似arguments 对象的构造机制，只不过收集参数的结果会得到一个 Array 实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gm</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 顺序累加 values 中的所有值</span></span><br><span class="line"> <span class="comment">// 初始值的总和为 0</span></span><br><span class="line"> <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(gm(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 6 </span></span><br></pre></td></tr></table></figure><p>收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params">...values, lastValue</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ignoreFirst</span>(<span class="params">firstValue, ...values</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;</span><br><span class="line">ignoreFirst(); <span class="comment">// []</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>); <span class="comment">// []</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2]</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// [2, 3] </span></span><br></pre></td></tr></table></figure><p>箭头函数虽然不支持 arguments 对象，但支持收集参数的定义方式，因此也可以实现与使用arguments 一样的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> getSum = <span class="function">(<span class="params">...values</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 6 </span></span><br></pre></td></tr></table></figure><p>另外，使用收集参数并不影响 arguments 对象，它仍然反映调用时传给函数的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">// 3</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"> <span class="built_in">console</span>.log(values); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); </span><br></pre></td></tr></table></figure><hr><h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><p>JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p> 函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作函数声明提升（function declaration hoisting）。在执行代码时，JavaScript 引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部。</p><p>把前面代码中的函数声明改为等价的函数表达式，那么执行的时候就会出错 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>函数定义包含在一个变量初始化语句中，而不是函数声明中。<br>这意味着代码如果没有执行到加粗的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会出错。这并不是因为使用 let 而导致的，使用 var 关键字也会碰到同样的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>除了函数什么时候真正有定义这个区别之外，这两种语法是等价的。</p><p>注意 在使用函数表达式初始化变量时，也可以给函数一个名称，比如 let sum =function sum() {}。这一点在 10.11 节讨论函数表达式时会再讨论。</p><hr><h2 id="函数作为值"><a href="#函数作为值" class="headerlink" title="函数作为值"></a>函数作为值</h2><p>因为函数名在 ECMAScript 中就是变量，所以函数可以用在任何可以使用变量的地方。不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个函数接收两个参数。第一个参数应该是一个函数，第二个参数应该是要传给这个函数的值。任何函数都可以像下面这样作为参数传递：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = cn(add10, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r1); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gg</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r2 = cn(gg, <span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r2); <span class="comment">// &quot;Hello, Nicholas&quot; </span></span><br></pre></td></tr></table></figure><p>callSomeFunction()函数是通用的，第一个参数传入的是什么函数都可以，而且它始终返回调用作为第一个参数传入的函数的结果。要注意的是，如果是访问函数而不是调用函数，那就必须不带括号，所以传给 callSomeFunction()的必须是 add10 和 getGreeting，而不能是它们的执行结果。从一个函数中返回另一个函数也是可以的，而且非常有用。例如，假设有一个包含对象的数组，而我们想按照任意对象属性对数组进行排序。为此，可以定义一个 sort()方法需要的比较函数，它接收两个参数，即要比较的值。但这个比较函数还需要想办法确定根据哪个属性来排序。这个问题可以通过定义一个根据属性名来创建比较函数的函数来解决。</p><hr><h2 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h2><p>在 ECMAScript 5 中，函数内部存在两个特殊的对象arguments 和 this。ECMAScript 6 又新增了 new.target 属性</p><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>arguments 对象前面讨论过多次了，它是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以 function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但 arguments 对象其实还有一个 callee 属性，是一个指向 arguments 对象所在函数的指针。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fl</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> num * fl(num - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是 factorial，从而导致了紧密耦合。使用 arguments.callee 就可以让函数逻辑与函数名解耦：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个重写之后的 factorial()函数已经用 arguments.callee 代替了之前硬编码的 factorial。这意味着无论函数叫什么名称，都可以引用正确的函数。考虑下面的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> trueFactorial = factorial;</span><br><span class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(trueFactorial(<span class="number">5</span>)); <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><p>这里，trueFactorial 变量被赋值为 factorial，实际上把同一个函数的指针又保存到了另一个位置。然后，factorial 函数又被重写为一个返回 0 的函数。如果像 factorial()最初的版本那样不<br>使用 arguments.callee，那么像上面这样调用 trueFactorial()就会返回 0。不过，通过将函数与名称解耦，trueFactorial()就可以正确计算阶乘，而 factorial()则只能返回 0。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>另一个特殊的对象是 this，它在标准函数和箭头函数中有不同的行为。<br>在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值（在网页的全局上下文中调用函数时，this 指向 windows）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sr(); <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line">o.sr = sr;</span><br><span class="line">o.sr(); <span class="comment">// &#x27;blue&#x27; </span></span><br></pre></td></tr></table></figure><p>定义在全局上下文中的函数 sr()引用了 this 对象。这个 this 到底引用哪个对象必须到函数被调用时才能确定。因此这个值在代码执行的过程中可能会变。如果在全局上下文中调用sr()，这结果会输出”red”，因为 this 指向 window，而 this.color 相当于 window.color。而在把 sr()赋值给 o 之后再调用 o.sr()，this 会指向 o，即 this.color 相当于o.color，所以会显示”blue”。</p><p>在箭头函数中，this引用的是定义箭头函数的上下文。下面的例子演示了这一点。在对sayColor()的两次调用中，this 引用的都是 window 对象，因为这个箭头函数是在 window 上下文中定义的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> sr = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">sr(); <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line">o.sr = sr;</span><br><span class="line">o.sr(); <span class="comment">// &#x27;red&#x27; </span></span><br></pre></td></tr></table></figure><p>在事件回调或定时回调中调用某个函数时，this 值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的 this 会保留定义该函数时的上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.re = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line"> <span class="comment">// this 引用 King 的实例</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.re), <span class="number">1000</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.re = <span class="string">&#x27;Elizabeth&#x27;</span>;</span><br><span class="line"> <span class="comment">// this 引用 window 对象</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.re); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> King(); <span class="comment">// Henry</span></span><br><span class="line"><span class="keyword">new</span> Queen(); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><p>ECMAScript 5 也会给函数对象上添加一个属性：caller。虽然 ECMAScript 3 中并没有定义，但所有浏览器除了早期版本的 Opera 都支持这个属性。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(inner.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><p>以上代码会显示 outer()函数的源代码。这是因为 ourter()调用了 inner()，inner.caller指向 outer()。如果要降低耦合度，则可以通过 arguments.callee.caller 来引用同样的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer(); </span><br></pre></td></tr></table></figure><p>在严格模式下访问 arguments.callee 会报错。ECMAScript 5 也定义了 arguments.caller，但在严格模式下访问它会报错，在非严格模式下则始终是 undefined。这是为了分清 arguments.caller和函数的 caller 而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同一上下文中运行的其他代码。</p><p>严格模式下还有一个限制，就是不能给函数的 caller 属性赋值，否则会导致错误。</p><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>ECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">&#x27;King must be instantiated using &quot;new&quot;&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;King instantiated using &quot;new&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> King(); <span class="comment">// King instantiated using &quot;new&quot;</span></span><br><span class="line">King(); <span class="comment">// Error: King must be instantiated using &quot;new&quot; </span></span><br></pre></td></tr></table></figure><hr><h2 id="函数属性与方法"><a href="#函数属性与方法" class="headerlink" title="函数属性与方法"></a>函数属性与方法</h2><p>ECMAScript 中的函数是对象，因此有属性和方法。每个函数都有两个属性：length和 prototype。其中，length 属性保存函数定义的命名参数的个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sayName.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(sayHi.length); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><p> sayName()函数有 1 个命名参数，所以其 length 属性为 1。类似地，sum()函数有两个命名参数，所以其 length 属性是 2。而 sayHi()没有命名参数，其 length 属性为 0。</p><p> prototype<br> 是保存引用类型所有实例方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实例共享。这个属性在自定义类型时特别重要。（相关内容已经在第 8 章详细介绍过了。）在 ECMAScript 5中，prototype 属性是不可枚举的，因此使用 for-in 循环不会返回这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> sum.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 传入 arguments 对象</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> sum.apply(<span class="built_in">this</span>, [num1, num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20 </span></span><br></pre></td></tr></table></figure><p> callSum1()会调用 sum()函数，将 this 作为函数体内的 this 值（这里等于window，因为是在全局作用域中调用的）传入，同时还传入了 arguments 对象。callSum2()也会调用 sum()函数，但会传入参数的数组。这两个函数都会执行并返回正确的结果。</p><p>在严格模式下，调用函数时如果没有指定上下文对象，则 this 值不会指向 window。除非使用 apply()或 call()把函数指定给一个对象，否则 this 的值会变成 undefined。<br>call()方法与 apply()的作用一样，只是传参的形式不同。第一个参数跟 apply()一样，也是 this值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过 call()向函数传参时，必须将参数一个一个地列出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> sum.call(<span class="built_in">this</span>, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20 </span></span><br></pre></td></tr></table></figure><p>这里的 callSum()函数必须逐个地把参数传给 call()方法。结果跟 apply()的例子一样。到底是使用 apply()还是 call()，完全取决于怎么给要调用的函数传参更方便。如果想直接传 arguments对象或者一个数组，那就用 apply()；否则，就用 call()。当然，如果不用给被调用的函数传参，则使用哪个方法都一样。</p><p>apply()和 call()真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内 this值的能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor(); <span class="comment">// red</span></span><br><span class="line">sayColor.call(<span class="built_in">this</span>); <span class="comment">// red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">// red</span></span><br><span class="line">sayColor.call(o); <span class="comment">// blue </span></span><br></pre></td></tr></table></figure><p>这个例子是在之前那个关于 this 对象的例子基础上修改而成的。同样，sayColor()是一个全局函数，如果在全局作用域中调用它，那么会显示”red”。这是因为 this.color 会求值为 window.color。如果在全局作用域中显式调用 sayColor.call(this)或者 sayColor.call(window)，则同样都会显示”red”。而在使用 sayColor.call(o)把函数的执行上下文即 this 切换为对象 o 之后，结果就变成了显示”blue”了。</p><p>使用 call()或 apply()的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法。在前面例子最初的版本中，为切换上下文需要先把 sayColor()直接赋值为 o 的属性，然后再<br>调用。而在这个修改后的版本中，就不需要这一步操作了。ECMAScript 5 出于同样的目的定义了一个新方法：bind()。bind()方法会创建一个新的函数实例，其 this 值会被绑定到传给 bind()的对象。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line"> color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure><p>这里，在 sayColor()上调用 bind()并传入对象 o 创建了一个新函数 objectSayColor()。objectSayColor()中的 this 值被设置为 o，因此直接调用这个函数，即使是在全局作用域中调用，<br>也会返回字符串”blue”。对函数而言，继承的方法 toLocaleString()和 toString()始终返回函数的代码。返回代码的具体格式因浏览器而异。有的返回源代码，包含注释，而有的只返回代码的内部形式，会删除注释，甚至代码可能被解释器修改过。由于这些差异，因此不能在重要功能中依赖这些方法返回的值，而只应在调试中使用它们。继承的方法 valueOf()返回函数本身。</p><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>函数表达式虽然更强大，但也更容易让人迷惑。我们知道，定义函数有两种方式：函数声明和函数表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 函数体</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>函数声明的关键特点是函数声明提升，即函数声明会在代码执行之前获得定义。这意味着函数声明可以出现在调用它的代码之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个例子不会抛出错误，因为 JavaScript 引擎会先读取函数声明，然后再执行代码。第二种创建函数的方式就是函数表达式。函数表达式有几种不同的形式，最常见的是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 函数体</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量functionName。这样创建的函数叫作匿名函数（anonymous funtion），因为 function 关键字后面没有标识符。（匿名函数有也时候也被称为兰姆达函数）。未赋值给其他变量的匿名函数的 name 属性是空字符串。</p><p>函数表达式跟 JavaScript 中的其他表达式一样，需要先赋值再使用。下面的例子会导致错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi(); <span class="comment">// Error! function doesn&#x27;t exist yet</span></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>理解函数声明与函数表达式之间的区别，关键是理解提升。比如，以下代码的执行结果可能会出乎意料：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 千万别这样做！</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;Yo!&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这段代码看起来很正常，就是如果 condition 为 true，则使用第一个 sayHi()定义；否则，就使用第二个。事实上，这种写法在 ECAMScript 中不是有效的语法。JavaScript 引擎会尝试将其纠正为适当的声明。问题在于浏览器纠正这个问题的方式并不一致。多数浏览器会忽略 condition 直接返回第二个声明。Firefox 会在 condition 为 true 时返回第一个声明。这种写法很危险，不要使用。不过，如果把上面的函数声明换成函数表达式就没问题了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> sayHi;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Yo!&quot;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>根据 condition 的值为变量 sayHi 赋予相应的函数。创建函数并赋值给变量的能力也可以用于在一个函数中把另一个函数当作值返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cn</span>(<span class="params">pName</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> value1 = object1[pName];</span><br><span class="line"> <span class="keyword">let</span> value2 = object2[pName];</span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里的 cn()函数返回一个匿名函数，这个匿名函数要么被赋值给一个变量，要么可以直接调用。但在 cn()内部，那个函数是匿名的。任何时候，只要函数被当作值来使用，它就是一个函数表达式。</p><hr><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数通常的形式是一个函数通过名称调用自己</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fl</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> num * fl(num - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这是经典的递归阶乘函数。虽然这样写是可以的，但如果把这个函数赋值给其他变量，就会出问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anotherFactorial(<span class="number">4</span>)); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>这里把 factorial()函数保存在了另一个变量 anotherFactorial 中，然后将 factorial 设置为 null，于是只保留了一个对原始函数的引用。而在调用 anotherFactorial()时，要递归调用<br>factorial()，但因为它已经不是函数了，所以会出错。在写递归函数时使用 arguments.callee 可以避免这个问题。</p><p>arguments.callee 就是一个指向正在执行的函数的指针，因此可以在函数内部递归调用，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>像这里加粗的这一行一样，把函数名称替换成 arguments.callee，可以确保无论通过什么变量调用这个函数都不会出问题。因此在编写递归函数时，arguments.callee 是引用当前函数的首选。<br>不过，在严格模式下运行的代码是不能访问 arguments.callee 的，因为访问会出错。此时，可以使用命名函数表达式（named function expression）达到目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里创建了一个命名函数表达式 f()，然后将它赋值给了变量 factorial。即使把函数赋值给另一个变量，函数表达式的名称 f 也不变，因此递归调用不会有问题。这个模式在严格模式和非严格模式下都可以使用。</p><hr><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><h4 id="ECMAScript-6-规范新增了一项内存管理优化机制，让-JavaScript-引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。"><a href="#ECMAScript-6-规范新增了一项内存管理优化机制，让-JavaScript-引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。" class="headerlink" title="ECMAScript 6 规范新增了一项内存管理优化机制，让 JavaScript 引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。"></a>ECMAScript 6 规范新增了一项内存管理优化机制，让 JavaScript 引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">oFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> iFun(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="在-ES6-优化之前，执行这个例子会在内存中发生如下操作"><a href="#在-ES6-优化之前，执行这个例子会在内存中发生如下操作" class="headerlink" title="在 ES6 优化之前，执行这个例子会在内存中发生如下操作"></a>在 ES6 优化之前，执行这个例子会在内存中发生如下操作</h4><ul><li>执行到 oFun 函数体，第一个栈帧被推到栈上。</li><li>执行 oFun 函数体，到 return 语句。计算返回值必须先计算 iFun。</li><li>执行到 iFun 函数体，第二个栈帧被推到栈上。</li><li>执行 iFun 函数体，计算其返回值。</li><li>将返回值传回 oFun，然后 oFun 再返回值。</li><li>将栈帧弹出栈外。<h4 id="ES6-优化之后，执行这个例子会在内存中发生如下操作。"><a href="#ES6-优化之后，执行这个例子会在内存中发生如下操作。" class="headerlink" title="ES6 优化之后，执行这个例子会在内存中发生如下操作。"></a>ES6 优化之后，执行这个例子会在内存中发生如下操作。</h4></li><li>执行到 oFun 函数体，第一个栈帧被推到栈上。</li><li>执行 oFun 函数体，到达 return 语句。为求值返回语句，必须先求值iFun。</li><li>引擎发现把第一个栈帧弹出栈外也没问题，因为 iFun 的返回值也是 oFun<br>的返回值。</li><li>弹出oFun 的栈帧。</li><li>执行到 iFun 函数体，栈帧被推到栈上。</li><li>执行 iFun 函数体，计算其返回值。</li><li>将 iFun 的栈帧弹出栈外。<h4 id="现在还没有办法测试尾调用优化是否起作用。不过，因为这是-ES6-规范所规定的，兼容的浏览器实现都能保证在代码满足条件的情况下应用这个优化。"><a href="#现在还没有办法测试尾调用优化是否起作用。不过，因为这是-ES6-规范所规定的，兼容的浏览器实现都能保证在代码满足条件的情况下应用这个优化。" class="headerlink" title="现在还没有办法测试尾调用优化是否起作用。不过，因为这是 ES6 规范所规定的，兼容的浏览器实现都能保证在代码满足条件的情况下应用这个优化。"></a>现在还没有办法测试尾调用优化是否起作用。不过，因为这是 ES6 规范所规定的，兼容的浏览器实现都能保证在代码满足条件的情况下应用这个优化。</h4></li></ul><h3 id="尾调用优化的条件"><a href="#尾调用优化的条件" class="headerlink" title="尾调用优化的条件"></a>尾调用优化的条件</h3><p>尾调用优化的条件就是确定外部栈帧真的没有必要存在了。</p><ul><li>代码在严格模式下执行；</li><li>外部函数的返回值是对尾调用函数的调用；</li><li>尾调用函数返回后不需要执行额外的逻辑；</li><li>尾调用函数不是引用外部函数作用域中自由变量的闭包。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 无优化：尾调用没有返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> innerFunction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用没有直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> innerFunctionResult = innerFunction();</span><br><span class="line"> <span class="keyword">return</span> innerFunctionResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用返回后必须转型为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> innerFunction().toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用是一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> foo; &#125;</span><br><span class="line"> <span class="keyword">return</span> innerFunction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>下面是几个符合尾调用优化条件的例子：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 有优化：栈帧销毁前执行参数计算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> innerFunction(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有优化：初始返回值不涉及栈帧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> innerFunction(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有优化：两个内部函数都在尾部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> condition ? innerFunctionA() : innerFunctionB();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>差异化尾调用和递归尾调用是容易让人混淆的地方。无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。</li></ul><h3 id="尾调用优化的代码"><a href="#尾调用优化的代码" class="headerlink" title="尾调用优化的代码"></a>尾调用优化的代码</h3><p>可以通过把简单的递归函数转换为待优化的代码来加深对尾调用优化的理解。下面是一个通过递归计算斐波纳契数列的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">3</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">5</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">6</span>)); <span class="comment">// 8 </span></span><br></pre></td></tr></table></figure><p>显然这个函数不符合尾调用优化的条件，因为返回语句中有一个相加的操作。结果，fib(n)的栈帧数的内存复杂度是 O(2n)。因此，即使这么一个简单的调用也可以给浏览器带来麻烦：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>当然，解决这个问题也有不同的策略，比如把递归改写成迭代循环形式。不过，也可以保持递归实现，但将其重构为满足优化条件的形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部函数执行递归：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 基础框架</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> fibImpl(<span class="number">0</span>, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibImpl</span>(<span class="params">a, b, n</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> fibImpl(b, a + b, n - <span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样重构之后，就可以满足尾调用优化的所有条件，再调用 fib(1000)就不会对浏览器造成威胁了。</p><hr><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>匿名函数经常被人误认为是闭包（closure）<br>闭包是一个拥有许多变量和绑定这些变量的环境表达式<br>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cFun</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = obj1[propertyName]; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">let</span> v2 = obj2[propertyName]; <span class="comment">//</span></span><br><span class="line">          <span class="keyword">if</span> (v1 &lt; v2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1 &gt; v2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里加斜杠的代码位于内部函数（匿名函数）中，其中引用了外部函数的变量 propertyName。在这个内部函数被返回并在其他地方被使用后，它仍然引用着那个变量。这是因为内部函数的作用域链包含cFunn()函数的作用域。要理解为什么会这样，可以想想第一次调用这个函数时会发生什么</p><p>理解作用域链创建和使用的细节对理解闭包非常重要。在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用 arguments和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。在函数执行时，要从作用域链中查找变量，以便读、写值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = compare(<span class="number">5</span>, <span class="number">10</span>); </span><br></pre></td></tr></table></figure><p>这里定义的 compare()函数是在全局上下文中调用的。第一次调用 compare()时，会为它创建一个包含 arguments、value1 和 value2 的活动对象，这个对象是其作用域链上的第一个对象。而全局上下文的变量对象则是 compare()作用域链上的第二个对象，其中包含 this、result 和 compare。</p><p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义<br>compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。在调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链。接着<br>会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。在这个例子中，这意味着 compare()函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。<br><a href="https://imgchr.com/i/BqRQFx"><img src="https://s1.ax1x.com/2020/11/10/BqRQFx.png" alt="BqRQFx.png"></a></p><p>在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在createComparisonFunction()函数中，匿名函数的作用域链中实际上包含 createComparisonFunction()的活动对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compare = createComparisonFunction(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> result = compare(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;); </span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/BqRU0A"><img src="https://s1.ax1x.com/2020/11/10/BqRU0A.png" alt="BqRU0A.png"></a></p><p>在 createComparisonFunction()返回匿名函数后，它的作用域链被初始化为包含 createComparisonFunction()的活动对象和全局变量对象。这样，匿名函数就可以访问到 createComparisonFunction()可以访问的所有变量。另一个有意思的副作用就是，createComparisonFunction()的活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在 createComparisonFunction()执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建比较函数</span></span><br><span class="line"><span class="keyword">let</span> compareNames = createComparisonFunction(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="keyword">let</span> result = compareNames(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// 解除对函数的引用，这样就可以释放内存了</span></span><br><span class="line">compareNames = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>这里，创建的比较函数被保存在变量 compareNames 中。把 compareNames 设置为等于 null 会解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全局作用域之外）也可以销毁。</p><p>因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用，因此建议仅在十分必要时使用。V8 等优化的 JavaScript 引擎会努力回收被闭包困住的内存，不过我们还是建议在使用闭包时要谨慎。</p><h2 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h2><p>在闭包中使用 this 会让代码变复杂。如果内部函数没有使用箭头函数定义，则 this 对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则 this 在非严格模式下等于 window，在严格模式下等于 undefined。如果作为某个对象的方法调用，则 this 等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着 this 会指向 window，除非在严格模式下 this 是 undefined。不过，由于闭包的写法所致，这个事实有时候没有那么容易看出来。</p><p>每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments。内部函数永远不可能直接访问外部函数的这两个变量。但是，如果把 this 保存到闭包可以访问的另一个变量中，则是行得通的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line"> identity: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line"> getIdentityFunc() &#123;</span><br><span class="line"> <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> that.identity;</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在定义匿名函数之前，先把外部函数的 this 保存到变量 that 中。然后在定义闭包时，就可以让它访问 that，因为这是包含函数中名称没有任何冲突的一个变量。即使在外部函数返回之后，that 仍然指向 object，所以调用 object.getIdentityFunc()()就会返回”My Object”。</p><p>注意 this 和 arguments 都是不能直接在内部函数中访问的。如果想访问包含作用域中的 arguments 对象，则同样需要将其引用先保存到闭包能访问的另一个变量中。</p><p>在一些特殊情况下，this 值可能并不是我们所期待的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line"> identity: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line"> getIdentity () &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.identity;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>getIdentity()方法就是返回 this.identity 的值。以下是几种调用 object.getIdentity()的方式及返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object.getIdentity(); <span class="comment">// &#x27;My Object&#x27;</span></span><br><span class="line">(object.getIdentity)(); <span class="comment">// &#x27;My Object&#x27;</span></span><br><span class="line">(object.getIdentity = object.getIdentity)(); <span class="comment">// &#x27;The Window&#x27; </span></span><br></pre></td></tr></table></figure><p>第一行调用 object.getIdentity()是正常调用，会返回”My Object”，因为 this.identity就是 object.identity。第二行在调用时把 object.getIdentity 放在了括号里。虽然加了括号之后看起来是对一个函数的引用，但 this 值并没有变。这是因为按照规范，object.getIdentity 和(object.getIdentity)是相等的。第三行执行了一次赋值，然后再调用赋值后的结果。因为赋值表达式的值是函数本身，this 值不再与任何对象绑定，所以返回的是”The Window”。<br>一般情况下，不大可能像第二行和第三行这样调用对象上的方法。但通过这个例子，我们可以知道，即使语法稍有不同，也可能影响 this 的值。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>由于 IE 在 IE9 之前对 JScript 对象和 COM 对象使用了不同的垃圾回收机制，所以闭包在这些旧版本 IE 中可能会导致问题。在这些版本的 IE 中，把 HTML 元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;someElement&#x27;</span>);</span><br><span class="line"> element.onclick = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(element.id);</span><br><span class="line">&#125;</span><br><span class="line">以上代码创建了一个闭包，即 element 元素的事件处理程序（事件处理程序将在第 <span class="number">13</span> 章讨论）。</span><br><span class="line">而这个处理程序又创建了一个循环引用。匿名函数引用着 assignHandler()的活动对象，阻止了对</span><br><span class="line">element 的引用计数归零。只要这个匿名函数存在，element 的引用计数就至少等于 <span class="number">1</span>。也就是说，</span><br><span class="line">内存不会被回收。其实只要这个例子稍加修改，就可以避免这种情况，比如：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;someElement&#x27;</span>);</span><br><span class="line"> <span class="keyword">let</span> id = element.id;</span><br><span class="line"> element.onclick = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(id);</span><br><span class="line"> element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个修改后的版本中，闭包改为引用一个保存着 element.id 的变量 id，从而消除了循环引用。不过，光有这一步还不足以解决内存问题。因为闭包还是会引用包含函数的活动对象，而其中包含element。即使闭包没有直接引用 element，包含函数的活动对象上还是保存着对它的引用。因此，必须再把 element 设置为 null。这样就解除了对这个 COM 对象的引用，其引用计数也会减少，从而确保其内存可以在适当的时候被回收。</p><h2 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h2><p>立即调用的匿名函数又被称作立即调用的函数表达式（IIFE，Immediately Invoked FunctionExpression）。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 块级作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>使用 IIFE 可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这<br>样位于函数体作用域的变量就像是在块级作用域中一样。ECMAScript 5 尚未支持块级作用域，使用 IIFE<br>模拟块级作用域是相当普遍的。比如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure><p>前面的代码在执行到 IIFE 外部的 console.log()时会出错，因为它访问的变量是在 IIFE 内部定义的，在外部访问不到。在 ECMAScript 5.1 及以前，为了防止变量定义外泄，IIFE 是个非常有效的方式。这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕，其作用域链就可以被销毁。</p><p>在 ECMAScript 6 以后，IIFE 就没有那么必要了，因为块级作用域中的变量无须 IIFE 就可以实现同样的隔离。下面展示了两种不同的块级作用域形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内嵌块级作用域</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">let</span> i;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 抛出错误</span></span><br><span class="line"><span class="comment">// 循环的块级作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure><p>说明 IIFE 用途的一个实际的例子，就是可以用它锁定参数值。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line"> divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 var 关键字声明了循环迭代变量 i，但这个变量并不会被限制在 for 循环的块级作用域内。因此，渲染到页面上之后，点击每个<div>都会弹出元素总数。这是因为在执行单击处理程序时，迭代变量的值是循环结束时的最终值，即元素的个数。而且，这个变量 i 存在于循环体外部，随时可以访问。以前，为了实现点击第几个<div>就显示相应的索引值，需要借助 IIFE 来执行一个函数表达式，传入每次循环的当前索引，从而“锁定”点击时应该显示的索引值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line"> divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">frozenCounter</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(frozenCounter);</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;)(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用 ECMAScript 块级作用域变量，就不用这么大动干戈了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line"> divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以让每次点击都显示正确的索引了。这里，事件处理程序执行时就会引用 for 循环块级作用域中的索引值。这是因为在 ECMAScript 6 中，如果对 for 循环使用块级作用域变量关键字，在这里就是 let，那么循环就会为每个循环创建独立的变量，从而让每个单击处理程序都能引用特定的索引。但要注意，如果把变量声明拿到 for 循环外部，那就不行了。下面这种写法会碰到跟在循环中使用var i = 0 同样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line"> divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>严格来讲，JavaScript 没有私有成员的概念，所有对象属性都公有的。不过，倒是有私有变量的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> sum = num1 + num2;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>函数 add()有 3 个私有变量：num1、num2 和 sum。这几个变量只能在函数内部使用，不能在函数外部访问。如果这个函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部的这 3 个变量。基于这一点，就可以创建出能够访问私有变量的公有方法。</p><p>特权方法是能够访问函数私有变量（及私有函数）的公有方法。在对象上有两种方式创建特权方法。第一种是在构造函数中实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 特权方法</span></span><br><span class="line"> <span class="built_in">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> privateVariable++;</span><br><span class="line"> <span class="keyword">return</span> privateFunction();</span><br><span class="line"> &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个模式是把所有私有变量和私有函数都定义在构造函数中。然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力。在这个例子中，变量 privateVariable 和函数privateFunction()只能通过 publicMethod()方法来访问。在创建 MyObject 的实例后，没有办法直接访问 privateVariable 和 privateFunction()，唯一的办法是使用 publicMethod()。<br>如下面的例子所示，可以定义私有变量和特权方法，以隐藏不能被直接修改的数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> name;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"> name = value;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;Nicholas&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line">person.setName(<span class="string">&#x27;Greg&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// &#x27;Greg&#x27; </span></span><br></pre></td></tr></table></figure><p>这段代码中的构造函数定义了两个特权方法：getName()和 setName()。每个方法都可以构造函数外部调用，并通过它们来读写私有的 name 变量。在 Person 构造函数外部，没有别的办法访问 name。因为两个方法都定义在构造函数内部，所以它们都是能够通过作用域链访问 name 的闭包。私有变量name 对每个 Person 实例而言都是独一无二的，因为每次调用构造函数都会重新创建一套变量和方法。不过这样也有个问题：必须通过构造函数来实现这种隔离。正如第 8 章所讨论的，构造函数模式的缺点是每个实例都会重新创建一遍新方法。使用静态私有变量实现特权方法可以避免这个问题。</p><h2 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h2><h4 id="特权方法也可以通过使用私有作用域定义私有变量和函数来实现。"><a href="#特权方法也可以通过使用私有作用域定义私有变量和函数来实现。" class="headerlink" title="特权方法也可以通过使用私有作用域定义私有变量和函数来实现。"></a>特权方法也可以通过使用私有作用域定义私有变量和函数来实现。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 构造函数</span></span><br><span class="line"> MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"> <span class="comment">// 公有和特权方法</span></span><br><span class="line"> MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> privateVariable++;</span><br><span class="line"> <span class="keyword">return</span> privateFunction();</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;)(); </span><br></pre></td></tr></table></figure><p>在这个模式中，匿名函数表达式创建了一个包含构造函数及其方法的私有作用域。首先定义的是私有变量和私有函数，然后又定义了构造函数和公有方法。公有方法定义在构造函数的原型上，与典型的原型模式一样。注意，这个模式定义的构造函数没有使用函数声明，使用的是函数表达式。函数声明会创建内部函数，在这里并不是必需的。基于同样的原因（但操作相反），这里声明 MyObject 并没有使用任何关键字。因为不使用关键字声明的变量会创建在全局作用域中，所以 MyObject 变成了全局变量，可以在这个私有作用域外部被访问。注意在严格模式下给未声明的变量赋值会导致错误。</p><p>这个模式与前一个模式的主要区别就是，私有变量和私有函数是由实例共享的。因为特权方法定义在原型上，所以同样是由实例共享的。特权方法作为一个闭包，始终引用着包含它的作用域。来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"> name = value;</span><br><span class="line"> &#125;;</span><br><span class="line"> Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> name;</span><br><span class="line"> &#125;;</span><br><span class="line"> Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"> name = value;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Nicholas&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line">person1.setName(<span class="string">&#x27;Matt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Michael&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// &#x27;Michael&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.getName()); <span class="comment">// &#x27;Michael&#x27; </span></span><br></pre></td></tr></table></figure><p>这里的 Person 构造函数可以访问私有变量 name，跟 getName()和 setName()方法一样。使用这种模式，name 变成了静态变量，可供所有实例使用。这意味着在任何实例上调用 setName()修改这个变量都会影响其他实例。调用 setName()或创建新的 Person 实例都要把 name 变量设置为一个新值。而所有实例都会返回相同的值。</p><p>像这样创建静态私有变量可以利用原型更好地重用代码，只是每个实例没有了自己的私有变量。最终，到底是把私有变量放在实例中，还是作为静态私有变量，都需要根据自己的需求来确定。</p><h4 id="注意-使用闭包和私有变量会导致作用域链变长，作用域链越长，则查找变量所需的时间也越多。"><a href="#注意-使用闭包和私有变量会导致作用域链变长，作用域链越长，则查找变量所需的时间也越多。" class="headerlink" title="注意 使用闭包和私有变量会导致作用域链变长，作用域链越长，则查找变量所需的时间也越多。"></a>注意 使用闭包和私有变量会导致作用域链变长，作用域链越长，则查找变量所需的时间也越多。</h4><h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><h4 id="前面的模式通过自定义类型创建了私有变量和特权方法。而下面要讨论的-Douglas-Crockford-所说的模块模式，则在一个单例对象上实现了相同的隔离和封装。单例对象（singleton）就是只有一个实例的对象。按照惯例，JavaScript-是通过对象字面量来创建单例对象的"><a href="#前面的模式通过自定义类型创建了私有变量和特权方法。而下面要讨论的-Douglas-Crockford-所说的模块模式，则在一个单例对象上实现了相同的隔离和封装。单例对象（singleton）就是只有一个实例的对象。按照惯例，JavaScript-是通过对象字面量来创建单例对象的" class="headerlink" title="前面的模式通过自定义类型创建了私有变量和特权方法。而下面要讨论的 Douglas Crockford 所说的模块模式，则在一个单例对象上实现了相同的隔离和封装。单例对象（singleton）就是只有一个实例的对象。按照惯例，JavaScript 是通过对象字面量来创建单例对象的"></a>前面的模式通过自定义类型创建了私有变量和特权方法。而下面要讨论的 Douglas Crockford 所说的模块模式，则在一个单例对象上实现了相同的隔离和封装。单例对象（singleton）就是只有一个实例的对象。按照惯例，JavaScript 是通过对象字面量来创建单例对象的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = &#123;</span><br><span class="line"> name: value, </span><br><span class="line"> method() &#123;</span><br><span class="line"> <span class="comment">// 方法的代码</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。模块模式<br>的样板代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 特权/公有方法和属性</span></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line"> publicProperty: <span class="literal">true</span>,</span><br><span class="line"> publicMethod() &#123;</span><br><span class="line"> privateVariable++;</span><br><span class="line"> <span class="keyword">return</span> privateFunction();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后，创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的所有公有方法都可以访问同一个作用域的私有变量和私有函数。本质上，对象字面量定义了单例对象的公共接口。如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"> <span class="comment">// 初始化</span></span><br><span class="line"> components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line"> <span class="comment">// 公共接口</span></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line"> getComponentCount() &#123;</span><br><span class="line"> <span class="keyword">return</span> components.length;</span><br><span class="line"> &#125;,</span><br><span class="line"> registerComponent(component) &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line"> components.push(component);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>在 Web 开发中，经常需要使用单例对象管理应用程序级的信息。上面这个简单的例子创建了一个<br>application 对象用于管理组件。在创建这个对象之后，内部就会创建一个私有的数组 components，然后将一个 BaseComponent 组件的新实例添加到数组中。（BaseComponent 组件的代码并不重要，在这里用它只是为了说明模块模式的用法。）对象字面量中定义的 getComponentCount()和 registerComponent()方法都是可以访问 components 私有数组的特权方法。前一个方法返回注册组件的数量，后一个方法负责注册新组件。</p><p>在模块模式中，单例对象作为一个模块，经过初始化可以包含某些私有的数据，而这些数据又可以通过其暴露的公共方法来访问。以这种方式创建的每个单例对象都是 Object 的实例，因为最终单例都由一个对象字面量来表示。不过这无关紧要，因为单例对象通常是可以全局访问的，而不是作为参数传给函数的，所以可以避免使用 instanceof 操作符确定参数是不是对象类型的需求。</p><h2 id="模块增强模式"><a href="#模块增强模式" class="headerlink" title="模块增强模式"></a>模块增强模式</h2><p>另一个利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 创建对象</span></span><br><span class="line"> <span class="keyword">let</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line"> <span class="comment">// 添加特权/公有属性和方法</span></span><br><span class="line"> object.publicProperty = <span class="literal">true</span>;</span><br><span class="line"> object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> privateVariable++;</span><br><span class="line"> <span class="keyword">return</span> privateFunction();</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 返回对象</span></span><br><span class="line"> <span class="keyword">return</span> object;</span><br><span class="line">&#125;(); </span><br></pre></td></tr></table></figure><p>如果前一节的 application 对象必须是 BaseComponent 的实例，那么就可以使用下面的代码来创建它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"> <span class="comment">// 初始化</span></span><br><span class="line"> components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line"> <span class="comment">// 创建局部变量保存实例</span></span><br><span class="line"> <span class="keyword">let</span> app = <span class="keyword">new</span> BaseComponent();</span><br><span class="line"> <span class="comment">// 公共接口</span></span><br><span class="line"> app.getComponentCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> components.length;</span><br><span class="line"> &#125;; </span><br><span class="line">app.registerComponent = <span class="function"><span class="keyword">function</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line"> components.push(component);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 返回实例</span></span><br><span class="line"> <span class="keyword">return</span> app;</span><br><span class="line">&#125;(); </span><br></pre></td></tr></table></figure><p>在这个重写的 application 单例对象的例子中，首先定义了私有变量和私有函数，跟之前例子中一样。主要区别在于这里创建了一个名为 app 的变量，其中保存了BaseComponent 组件的实例。这是最终要变成 application 的那个对象的局部版本。在给这个局部变量 app 添加了能够访问私有变量的公共方法之后，匿名函数返回了这个对象。然后，这个对象被赋值给 application。 </p>]]></content>
    
    
    <summary type="html">函数</summary>
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="函数" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之对象与数组</title>
    <link href="http://example.com/2020/10/27/%E7%BA%A2%E5%AE%9D%E4%B9%A610/"/>
    <id>http://example.com/2020/10/27/%E7%BA%A2%E5%AE%9D%E4%B9%A610/</id>
    <published>2020-10-27T05:06:43.000Z</published>
    <updated>2020-11-09T12:26:44.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h5 id="到目前为止，大多数引用值的示例使用的是-Object-类型。Object-是-ECMAScript-中最常用的类型之一。虽然-Object-的实例没有多少功能，但很适合存储和在应用程序间交换数据。"><a href="#到目前为止，大多数引用值的示例使用的是-Object-类型。Object-是-ECMAScript-中最常用的类型之一。虽然-Object-的实例没有多少功能，但很适合存储和在应用程序间交换数据。" class="headerlink" title="到目前为止，大多数引用值的示例使用的是 Object 类型。Object 是 ECMAScript 中最常用的类型之一。虽然 Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据。"></a>到目前为止，大多数引用值的示例使用的是 Object 类型。Object 是 ECMAScript 中最常用的类型之一。虽然 Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decade = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">decade.name = <span class="string">&quot;MSS&quot;</span>;</span><br><span class="line">decade.age = <span class="number">29</span>; </span><br></pre></td></tr></table></figure><h5 id="另一种方式是使用对象字面量（object-literal）表示法。对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。"><a href="#另一种方式是使用对象字面量（object-literal）表示法。对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。" class="headerlink" title="另一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。"></a>另一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  <span class="comment">// 与 new Object()相同</span></span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h5 id="有几种基本的方式可以创建数组。一种是使用-Array-构造函数，比如："><a href="#有几种基本的方式可以创建数组。一种是使用-Array-构造函数，比如：" class="headerlink" title="有几种基本的方式可以创建数组。一种是使用 Array 构造函数，比如："></a>有几种基本的方式可以创建数组。一种是使用 Array 构造函数，比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>); <span class="comment">//创建一个初始 length 为 20 的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">//创建一个包含 3 个元素的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = []; <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,]; <span class="comment">// 创建一个包含 2 个元素的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含 3 个元素的数组</span></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Greg&quot;</span>); <span class="comment">// 创建一个只包含一个元素，即字符串&quot;Greg&quot;的数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数组空位"><a href="#数组空位" class="headerlink" title="数组空位"></a>数组空位</h2><h4 id="使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript-会将逗号之间相应索引位置的值当成空位，ES6-规范重新定义了该如何处理这些空位。"><a href="#使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript-会将逗号之间相应索引位置的值当成空位，ES6-规范重新定义了该如何处理这些空位。" class="headerlink" title="使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript 会将逗号之间相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位。"></a>使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript 会将逗号之间相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = [,,,,,]; <span class="comment">// 创建包含 5 个元素的数组</span></span><br><span class="line"><span class="built_in">console</span>.log(options.length); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(options); <span class="comment">// [,,,,,] </span></span><br></pre></td></tr></table></figure><h2 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 定义一个字符串数组</span></span><br><span class="line">alert(colors[<span class="number">0</span>]); <span class="comment">// 显示第一项</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">&quot;black&quot;</span>; <span class="comment">// 修改第三项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">&quot;brown&quot;</span>; <span class="comment">// 添加第四项</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组-length-属性的独特之处在于，它不是只读的。通过修改-length-属性，可以从数组末尾删除或添加元素。"><a href="#数组-length-属性的独特之处在于，它不是只读的。通过修改-length-属性，可以从数组末尾删除或添加元素。" class="headerlink" title="数组 length 属性的独特之处在于，它不是只读的。通过修改 length 属性，可以从数组末尾删除或添加元素。"></a>数组 length 属性的独特之处在于，它不是只读的。通过修改 length 属性，可以从数组末尾删除或添加元素。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><h4 id="一个经典的-ECMAScript-问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用-instanceof-操作符就足矣"><a href="#一个经典的-ECMAScript-问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用-instanceof-操作符就足矣" class="headerlink" title="一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣"></a>一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line"> <span class="comment">// 操作数组</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="Array-isArray-方法这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。"><a href="#Array-isArray-方法这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。" class="headerlink" title="Array.isArray()方法这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。"></a>Array.isArray()方法这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line"> <span class="comment">// 操作数组</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h2><h4 id="在-ES6-中，Array-的原型上暴露了-3-个用于检索数组内容的方法：keys-、values-和entries-。keys-返回数组索引的迭代器，values-返回数组元素的迭代器，而-entries-返回索引-值对的迭代器"><a href="#在-ES6-中，Array-的原型上暴露了-3-个用于检索数组内容的方法：keys-、values-和entries-。keys-返回数组索引的迭代器，values-返回数组元素的迭代器，而-entries-返回索引-值对的迭代器" class="headerlink" title="在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而 entries()返回索引/值对的迭代器"></a>在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而 entries()返回索引/值对的迭代器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>];</span><br><span class="line"><span class="comment">// 因为这些方法都返回迭代器，所以可以将它们的内容</span></span><br><span class="line"><span class="comment">// 通过 Array.from()直接转换为数组实例</span></span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="built_in">Array</span>.from(a.keys());</span><br><span class="line"><span class="keyword">const</span> aValues = <span class="built_in">Array</span>.from(a.values());</span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="built_in">Array</span>.from(a.entries());</span><br><span class="line"><span class="built_in">console</span>.log(aKeys); <span class="comment">// [0, 1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(aValues); <span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(aEntries); <span class="comment">// [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复制和填充方法"><a href="#复制和填充方法" class="headerlink" title="复制和填充方法"></a>复制和填充方法</h2><h4 id="ES6-新增了两个方法：批量复制方法-copyWithin-，以及填充数组方法-fill-。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。"><a href="#ES6-新增了两个方法：批量复制方法-copyWithin-，以及填充数组方法-fill-。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。" class="headerlink" title="ES6 新增了两个方法：批量复制方法 copyWithin()，以及填充数组方法 fill()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。"></a>ES6 新增了两个方法：批量复制方法 copyWithin()，以及填充数组方法 fill()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="comment">// 用 5 填充整个数组</span></span><br><span class="line">zeroes.fill(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [5, 5, 5, 5, 5]</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 6 填充索引大于等于 3 的元素</span></span><br><span class="line">zeroes.fill(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 0, 0, 6, 6]</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 7 填充索引大于等于 1 且小于 3 的元素</span></span><br><span class="line">zeroes.fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 7, 7, 0, 0];</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 8 填充索引大于等于 1 且小于 4 的元素</span></span><br><span class="line"><span class="comment">// (-4 + zeroes.length = 1)</span></span><br><span class="line"><span class="comment">// (-1 + zeroes.length = 4)</span></span><br><span class="line">zeroes.fill(<span class="number">8</span>, <span class="number">-4</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 8, 8, 8, 0]; </span></span><br></pre></td></tr></table></figure><h4 id="与-fill-不同，copyWithin-会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与-fill-使用同样的计算方法"><a href="#与-fill-不同，copyWithin-会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与-fill-使用同样的计算方法" class="headerlink" title="与 fill()不同，copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 fill()使用同样的计算方法"></a>与 fill()不同，copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 fill()使用同样的计算方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,</span><br><span class="line"> reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置</span></span><br><span class="line"><span class="comment">// 在源索引或目标索引到达数组边界时停止</span></span><br><span class="line">ints.copyWithin(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ints); <span class="comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]</span></span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置</span></span><br><span class="line">ints.copyWithin(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ints); <span class="comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9] </span></span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始到索引 3 结束的内容</span></span><br><span class="line"><span class="comment">// 插入到索引 4 开始的位置</span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">alert(ints); <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]</span></span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// JavaScript 引擎在插值前会完整复制范围内的值</span></span><br><span class="line"><span class="comment">// 因此复制期间不存在重写的风险</span></span><br><span class="line">ints.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">alert(ints); <span class="comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]</span></span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// 支持负索引值，与 fill()相对于数组末尾计算正向索引的过程是一样的</span></span><br><span class="line">ints.copyWithin(<span class="number">-4</span>, <span class="number">-7</span>, <span class="number">-3</span>);</span><br><span class="line">alert(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><h4 id="前面提到过，所有对象都有-toLocaleString-、toString-和-valueOf-方法。其中，valueOf-返回的还是数组本身。而-toString-返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其-toString-方法，以得到最终的字符串。"><a href="#前面提到过，所有对象都有-toLocaleString-、toString-和-valueOf-方法。其中，valueOf-返回的还是数组本身。而-toString-返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其-toString-方法，以得到最终的字符串。" class="headerlink" title="前面提到过，所有对象都有 toLocaleString()、toString()和 valueOf()方法。其中，valueOf()返回的还是数组本身。而 toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其 toString()方法，以得到最终的字符串。"></a>前面提到过，所有对象都有 toLocaleString()、toString()和 valueOf()方法。其中，valueOf()返回的还是数组本身。而 toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其 toString()方法，以得到最终的字符串。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">alert(colors.toString()); <span class="comment">// red,blue,green</span></span><br><span class="line">alert(colors.valueOf()); <span class="comment">// red,blue,green</span></span><br><span class="line">alert(colors); <span class="comment">// red,blue,green </span></span><br></pre></td></tr></table></figure><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><h4 id="join-方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。"><a href="#join-方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。" class="headerlink" title="join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。"></a>join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line">alert(colors.join(<span class="string">&quot;,&quot;</span>)); <span class="comment">// red,green,blue</span></span><br><span class="line">alert(colors.join(<span class="string">&quot;||&quot;</span>)); <span class="comment">// red||green||blue </span></span><br></pre></td></tr></table></figure><hr><h2 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h2><h4 id="push-方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。"><a href="#push-方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。" class="headerlink" title="push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。"></a>push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.push(<span class="number">4</span>, <span class="string">&#x27;pink&#x27;</span>)); <span class="comment">// 5;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1, 2, 3,4, &#x27;pink&#x27;];</span></span><br></pre></td></tr></table></figure><hr><h2 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h2><h4 id="pop-方法则用于删除数组的最后一项，同时减少数组的-length-值，返回被删除的项。"><a href="#pop-方法则用于删除数组的最后一项，同时减少数组的-length-值，返回被删除的项。" class="headerlink" title="pop()方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。"></a>pop()方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.pop()); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[1,2]</span></span><br></pre></td></tr></table></figure><hr><h2 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h2><h4 id="它会删除数组的第一项并返回它，然后数组长度减-1。"><a href="#它会删除数组的第一项并返回它，然后数组长度减-1。" class="headerlink" title="它会删除数组的第一项并返回它，然后数组长度减 1。"></a>它会删除数组的第一项并返回它，然后数组长度减 1。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.shift()); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[2，3]</span></span><br></pre></td></tr></table></figure><hr><h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h2><h4 id="在数组开头添加任意多个值，然后返回新的数组长度。"><a href="#在数组开头添加任意多个值，然后返回新的数组长度。" class="headerlink" title="在数组开头添加任意多个值，然后返回新的数组长度。"></a>在数组开头添加任意多个值，然后返回新的数组长度。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.unshift(<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>));<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[&#x27;red&#x27;, &#x27;purple&#x27;,1, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><h4 id="用于连接两个或多个数组"><a href="#用于连接两个或多个数组" class="headerlink" title="用于连接两个或多个数组"></a>用于连接两个或多个数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1=[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>],</span><br><span class="line"> arr2=[<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line"> arr3;</span><br><span class="line"><span class="comment">// concat</span></span><br><span class="line">arr3=arr1.concat(arr2,[<span class="string">&quot;m&quot;</span>,<span class="number">99</span>,<span class="number">8</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br></pre></td></tr></table></figure><h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><h4 id="从已有的数组返回选定元素"><a href="#从已有的数组返回选定元素" class="headerlink" title="从已有的数组返回选定元素"></a>从已有的数组返回选定元素</h4><h4 id="如果没有指定end，那么切分的数组包含从start到数组结束的所有元素"><a href="#如果没有指定end，那么切分的数组包含从start到数组结束的所有元素" class="headerlink" title="如果没有指定end，那么切分的数组包含从start到数组结束的所有元素"></a>如果没有指定end，那么切分的数组包含从start到数组结束的所有元素</h4><h4 id="如果slice-方法的参数有一个负数，则用数组长度加上该数确定相应位置"><a href="#如果slice-方法的参数有一个负数，则用数组长度加上该数确定相应位置" class="headerlink" title="如果slice()方法的参数有一个负数，则用数组长度加上该数确定相应位置"></a>如果slice()方法的参数有一个负数，则用数组长度加上该数确定相应位置</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice(start,end) end下标</span></span><br><span class="line"><span class="keyword">var</span> colors=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;yellow&quot;</span>,<span class="string">&quot;orange&quot;</span>];</span><br><span class="line"><span class="comment">//var newColors=colors.slice(1,3);   //[&quot;green&quot;,&quot;blue&quot;]</span></span><br><span class="line"><span class="comment">//var newColors2=colors.slice(2,4);   //[&quot;blue&quot;,&quot;yellow&quot;]</span></span><br><span class="line"><span class="keyword">var</span> newColors3=colors.slice(<span class="number">-4</span>,<span class="number">3</span>); <span class="comment">// 1,3 [&quot;green&quot;,&quot;blue&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(newColors3);</span><br></pre></td></tr></table></figure><h2 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h2><h4 id="删除从index处开始的零个或多个元素"><a href="#删除从index处开始的零个或多个元素" class="headerlink" title="删除从index处开始的零个或多个元素"></a>删除从index处开始的零个或多个元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>];</span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="keyword">var</span> delArr = arr.splice(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(arr); <span class="comment">// [a,b,f]</span></span><br><span class="line">  <span class="comment">// 插入</span></span><br><span class="line">  <span class="keyword">var</span> insertArr = arr.splice(<span class="number">3</span>, <span class="number">0</span>, <span class="string">&quot;m&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="number">88</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(arr); <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;f&quot;, &quot;m&quot;, &quot;n&quot;, 88]</span></span><br><span class="line">  <span class="comment">// 替换</span></span><br><span class="line">  <span class="keyword">var</span> replaceArr = arr.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(arr); <span class="comment">//[&quot;a&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;m&quot;, &quot;n&quot;, 88]</span></span><br></pre></td></tr></table></figure><hr><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.reverse();</span><br><span class="line">alert(values); <span class="comment">// 5,4,3,2,1 </span></span><br></pre></td></tr></table></figure><hr><h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values); <span class="comment">// 0,1,10,15,5 </span></span><br></pre></td></tr></table></figure><h2 id="indexOf-、"><a href="#indexOf-、" class="headerlink" title="indexOf()、"></a>indexOf()、</h2><h4 id="接收两个参数：要查找的元素和一个可选的起始搜索位置。从数组前头（第一项）开始向后搜索"><a href="#接收两个参数：要查找的元素和一个可选的起始搜索位置。从数组前头（第一项）开始向后搜索" class="headerlink" title="接收两个参数：要查找的元素和一个可选的起始搜索位置。从数组前头（第一项）开始向后搜索"></a>接收两个参数：要查找的元素和一个可选的起始搜索位置。从数组前头（第一项）开始向后搜索</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 5 </span></span><br></pre></td></tr></table></figure><h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h2><h4 id="接收两个参数：要查找的元素和一个可选的起始搜索位置。lastIndexOf-从数组末尾（最后一项）开始向前搜索。"><a href="#接收两个参数：要查找的元素和一个可选的起始搜索位置。lastIndexOf-从数组末尾（最后一项）开始向前搜索。" class="headerlink" title="接收两个参数：要查找的元素和一个可选的起始搜索位置。lastIndexOf()从数组末尾（最后一项）开始向前搜索。"></a>接收两个参数：要查找的元素和一个可选的起始搜索位置。lastIndexOf()从数组末尾（最后一项）开始向前搜索。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 5</span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><h4 id="接收两个参数：要查找的元素和一个可选的起始搜索位置。从数组前头（第一项）开始向后搜索-1"><a href="#接收两个参数：要查找的元素和一个可选的起始搜索位置。从数组前头（第一项）开始向后搜索-1" class="headerlink" title="接收两个参数：要查找的元素和一个可选的起始搜索位置。从数组前头（第一项）开始向后搜索"></a>接收两个参数：要查找的元素和一个可选的起始搜索位置。从数组前头（第一项）开始向后搜索</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line">alert(numbers.includes(<span class="number">4</span>)); <span class="comment">// true </span></span><br><span class="line">alert(numbers.includes(<span class="number">4</span>, <span class="number">7</span>)); <span class="comment">// false </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数组与对象</summary>
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="数组与对象" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之字符串增删改查</title>
    <link href="http://example.com/2020/10/26/%E7%BA%A2%E5%AE%9D%E4%B9%A69/"/>
    <id>http://example.com/2020/10/26/%E7%BA%A2%E5%AE%9D%E4%B9%A69/</id>
    <published>2020-10-26T05:06:43.000Z</published>
    <updated>2020-11-09T12:26:48.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><h2 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><h5 id="用于将一个或多个字符串拼接成一个新字符串。来看下面的例子"><a href="#用于将一个或多个字符串拼接成一个新字符串。来看下面的例子" class="headerlink" title="用于将一个或多个字符串拼接成一个新字符串。来看下面的例子"></a>用于将一个或多个字符串拼接成一个新字符串。来看下面的例子</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> res = str.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// &quot;hello&quot; </span></span><br></pre></td></tr></table></figure><h5 id="也可以操控多个参数"><a href="#也可以操控多个参数" class="headerlink" title="也可以操控多个参数"></a>也可以操控多个参数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> res = str.concat(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &quot;hello world!&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// &quot;hello&quot; </span></span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><h5 id="返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。"><a href="#返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。" class="headerlink" title="返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。"></a>返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-3</span>)); <span class="comment">// &quot;rld&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br></pre></td></tr></table></figure><h3 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h3><h5 id="返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。-1"><a href="#返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。-1" class="headerlink" title="返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。"></a>返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">-3</span>)); <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">// &quot;&quot; (empty string)</span></span><br></pre></td></tr></table></figure><h3 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h3><h5 id="返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。-2"><a href="#返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。-2" class="headerlink" title="返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。"></a>返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">-3</span>)); <span class="comment">// &quot;hello world&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">// &quot;hel&quot;</span></span><br></pre></td></tr></table></figure><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><h5 id="从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）从字符串开头开始查找子字符串"><a href="#从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）从字符串开头开始查找子字符串" class="headerlink" title="从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）从字符串开头开始查找子字符串"></a>从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）从字符串开头开始查找子字符串</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 4 </span></span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 7 </span></span><br></pre></td></tr></table></figure><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.lastIndexOf(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(str.lastIndexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 4 </span></span><br></pre></td></tr></table></figure><h5 id="从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）从字符串末尾开始查找子字符串"><a href="#从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）从字符串末尾开始查找子字符串" class="headerlink" title="从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）从字符串末尾开始查找子字符串"></a>从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）从字符串末尾开始查找子字符串</h5><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><h5 id="把一个字符串分割成字符串数组"><a href="#把一个字符串分割成字符串数组" class="headerlink" title="把一个字符串分割成字符串数组"></a>把一个字符串分割成字符串数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;welcome-to-beijing&#x27;</span>;</span><br><span class="line"><span class="comment">//使用split将str转换为数组</span></span><br><span class="line"> <span class="keyword">var</span> arr=str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> date=<span class="string">&#x27;2016/05/05&#x27;</span>;</span><br><span class="line"><span class="comment">//[&quot;welcome&quot;,&quot;to&quot;,&quot;beijing&quot;]</span></span><br><span class="line"><span class="keyword">var</span> dateArr=date.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dateArr);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><h5 id="在字符串用一些字符串替换另一些字符，或替换一个与正则表达式匹配的字符串"><a href="#在字符串用一些字符串替换另一些字符，或替换一个与正则表达式匹配的字符串" class="headerlink" title="在字符串用一些字符串替换另一些字符，或替换一个与正则表达式匹配的字符串"></a>在字符串用一些字符串替换另一些字符，或替换一个与正则表达式匹配的字符串</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tel=<span class="string">&#x27;010-62971268,400-100-9098,010-86789889&#x27;</span>;</span><br><span class="line"><span class="comment">//newTel被替换之后的字符串</span></span><br><span class="line"><span class="keyword">var</span> newTel=tel.replace(<span class="string">&#x27;,&#x27;</span>,<span class="string">&quot;  &quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newTel);</span><br><span class="line"><span class="comment">//010-62971268  400-100-9098,010-86789889</span></span><br></pre></td></tr></table></figure><h3 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith()"></a>startsWith()</h3><h5 id="用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。startsWith-检查开始于索引-0-的匹配项"><a href="#用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。startsWith-检查开始于索引-0-的匹配项" class="headerlink" title="用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。startsWith()检查开始于索引 0 的匹配项"></a>用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。startsWith()检查开始于索引 0 的匹配项</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mes = <span class="string">&quot;foobarbaz&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(mes.startsWith(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mes.startsWith(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith()"></a>endsWith()</h3><h5 id="用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。endsWith-检查开始于索引-string-length-substring-length-的匹配项"><a href="#用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。endsWith-检查开始于索引-string-length-substring-length-的匹配项" class="headerlink" title="用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。endsWith()检查开始于索引(string.length - substring.length)的匹配项"></a>用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。endsWith()检查开始于索引(string.length - substring.length)的匹配项</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mes = <span class="string">&quot;foobarbaz&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(mes.endsWith(<span class="string">&quot;baz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mes.endsWith(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><h5 id="用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。includes-检查整个字符串"><a href="#用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。includes-检查整个字符串" class="headerlink" title="用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。includes()检查整个字符串"></a>用于判断字符串中是否包含另一个字符串的方法这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。includes()检查整个字符串</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mes = <span class="string">&quot;foobarbaz&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(mes.includes(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mes.includes(<span class="string">&quot;qux&quot;</span>)); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><h3 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h3><h5 id="ECMAScript-在所有字符串上都提供了-trim-方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。"><a href="#ECMAScript-在所有字符串上都提供了-trim-方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。" class="headerlink" title="ECMAScript 在所有字符串上都提供了 trim()方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。"></a>ECMAScript 在所有字符串上都提供了 trim()方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot; hello world &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> tri = str.trim();</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// &quot; hello world &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(tri); <span class="comment">// &quot;hello world&quot; </span></span><br></pre></td></tr></table></figure><h3 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat()方法"></a>repeat()方法</h3><h5 id="ECMAScript-在所有字符串上都提供了-repeat-方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。"><a href="#ECMAScript-在所有字符串上都提供了-repeat-方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。" class="headerlink" title="ECMAScript 在所有字符串上都提供了 repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。"></a>ECMAScript 在所有字符串上都提供了 repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;de &quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">4</span>) + <span class="string">&quot;decade&quot;</span>);</span><br><span class="line"><span class="comment">// de de de de decade </span></span><br></pre></td></tr></table></figure><h3 id="padStart"><a href="#padStart" class="headerlink" title="padStart()"></a>padStart()</h3><h5 id="会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格"><a href="#会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格" class="headerlink" title="会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格"></a>会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str(<span class="number">6</span>)); <span class="comment">// &quot; foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;......foo&quot; </span></span><br></pre></td></tr></table></figure><h3 id="padEnd"><a href="#padEnd" class="headerlink" title="padEnd()"></a>padEnd()</h3><h5 id="会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格-1"><a href="#会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格-1" class="headerlink" title="会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格"></a>会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.padEnd(<span class="number">6</span>)); <span class="comment">// &quot;foo &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.padEnd(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;foo......&quot; </span></span><br></pre></td></tr></table></figure><h3 id="toLowerCase-、toUpperCase-、toLocaleLowerCase-和toLocaleUpperCase"><a href="#toLowerCase-、toUpperCase-、toLocaleLowerCase-和toLocaleUpperCase" class="headerlink" title="toLowerCase()、toUpperCase()、toLocaleLowerCase()和toLocaleUpperCase()"></a>toLowerCase()、toUpperCase()、toLocaleLowerCase()和toLocaleUpperCase()</h3><h5 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.toLocaleUpperCase()); <span class="comment">// &quot;HELLO WORLD&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase()); <span class="comment">// &quot;HELLO WORLD&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toLocaleLowerCase()); <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toLowerCase()); <span class="comment">// &quot;hello world&quot; </span></span><br></pre></td></tr></table></figure><h3 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h3><h5 id="最后一个方法是-localeCompare-，这个方法比较两个字符串，返回如下-3-个值中的一个"><a href="#最后一个方法是-localeCompare-，这个方法比较两个字符串，返回如下-3-个值中的一个" class="headerlink" title="最后一个方法是 localeCompare()，这个方法比较两个字符串，返回如下 3 个值中的一个"></a>最后一个方法是 localeCompare()，这个方法比较两个字符串，返回如下 3 个值中的一个</h5><ol><li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看<br>与实际值相关的实现。）</li><li>如果字符串与字符串参数相等，则返回 0。</li><li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;brick&quot;</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;zoo&quot;</span>)); <span class="comment">// -1 </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;增删改查&quot;&gt;&lt;a href=&quot;#增删改查&quot; class=&quot;headerlink&quot; title=&quot;增删改查&quot;&gt;&lt;/a&gt;增删改查&lt;/h1&gt;&lt;h2 id=&quot;字符串操作方法&quot;&gt;&lt;a href=&quot;#字符串操作方法&quot; class=&quot;headerlink&quot; title=&quot;字符串</summary>
      
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="字符串增删改查" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>电商网站构图之商品详情</title>
    <link href="http://example.com/2020/10/25/%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E6%80%9D%E6%83%B33/"/>
    <id>http://example.com/2020/10/25/%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E6%80%9D%E6%83%B33/</id>
    <published>2020-10-25T05:06:43.000Z</published>
    <updated>2020-11-06T06:17:48.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-品优购项目-四"><a href="#1-品优购项目-四" class="headerlink" title="1. 品优购项目(四)"></a>1. 品优购项目(四)</h1><h2 id="1-详情页-detail-html-常用单词"><a href="#1-详情页-detail-html-常用单词" class="headerlink" title="1). 详情页 detail.html  常用单词"></a>1). 详情页 detail.html  常用单词</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>主体</td><td>de_container</td></tr><tr><td>面包屑导航</td><td>crumb_wrap</td></tr><tr><td>产品介绍</td><td>product_intro   （ introduction介绍）</td></tr><tr><td>预览包</td><td>preview_wrap（左侧部分）</td></tr><tr><td>预览缩略图</td><td>preview_img</td></tr><tr><td>预览列表</td><td>preview_list</td></tr><tr><td>左按钮</td><td>arrow_prev</td></tr><tr><td>右按钮</td><td>arrow_next</td></tr><tr><td>小图列表</td><td>preview_items</td></tr><tr><td>产品详细信息区域</td><td>itemInfo_wrap （右侧部分）</td></tr><tr><td>头部名称</td><td>sku_name       skull  头骨</td></tr><tr><td>新闻</td><td>news</td></tr><tr><td>摘要</td><td>summary</td></tr><tr><td>评价</td><td>remark</td></tr><tr><td>价格摘要</td><td>summary_price</td></tr><tr><td>配送至</td><td>summary_stock</td></tr><tr><td>支持</td><td>summary_support</td></tr><tr><td>选择</td><td>choose</td></tr><tr><td>选择按钮组</td><td>choose_btns</td></tr><tr><td>选择数量</td><td>choose_amount</td></tr><tr><td>减去</td><td>reduce</td></tr><tr><td>加入购物车</td><td>addshopcar</td></tr><tr><td>产品细节</td><td>product_detail      （   detail描述）</td></tr><tr><td>左侧边</td><td>aside</td></tr><tr><td>详细描述</td><td>detail</td></tr></tbody></table><h2 id="2-面包屑导航"><a href="#2-面包屑导航" class="headerlink" title="2). 面包屑导航"></a>2). 面包屑导航</h2><p><img src="https://s1.ax1x.com/2020/11/06/BfJfx0.png" alt="我是图片"></p><ul><li>crumb_wrap   面包屑导航</li><li>关于面包屑导航的由来是源于一则童话故事的一个词语：汉泽尔和格蕾特尔两个人在穿过森林是，为了避免找不到回家的路，他们在沿途走过的地方都会撒下面包屑以便于根据这些面包屑找到回家的路。</li></ul><h2 id="3-产品介绍-模块"><a href="#3-产品介绍-模块" class="headerlink" title="3). 产品介绍 模块"></a>3). 产品介绍 模块</h2><p><img src="https://s1.ax1x.com/2020/11/06/BfJ5rT.png" alt="我是图片"></p><ul><li>1号盒子 本模块 命名为产品模块   product_intro   （ introduction介绍）</li><li>此模块不要给高度  因为右侧的模块内容高度不固定</li><li>里面有2个盒子  分为是2号盒子 和  3号盒子  </li><li>2号盒子为  预览区域  preview_wrap   给宽度，给高度， 左浮动</li><li>3号盒子为  产品详细信息区域  itemInfo_wrap 给宽度 ，不要给高度  左侧浮动 </li></ul><h3 id="3-1-preview-list-制作"><a href="#3-1-preview-list-制作" class="headerlink" title="3.1 preview_list 制作"></a>3.1 preview_list 制作</h3><p><img src="https://s1.ax1x.com/2020/11/06/BftxED.png" alt="我是图片"></p><ul><li>盒子 有左右按钮   arrow_prev   arrow_next  用定位即可 </li><li>中间 用 ul  命名为    list-item    给宽度和高度 然后  margin: 0 auto;  水平居中对齐即可</li></ul><h2 id="4-预览区域制作"><a href="#4-预览区域制作" class="headerlink" title="4).  预览区域制作"></a>4).  预览区域制作</h2><p><img src="https://s1.ax1x.com/2020/11/06/BfJ4MV.png" alt="我是图片"></p><ul><li>1号盒子 为  图片预览   命名为   preview_img    注意里面的图片，我们切图的时候是 398*398 像素的</li><li>2号盒子 为 预览列表   命名为  preview_list</li></ul><h2 id="5-产品详细信息区域制作-itemInfo-wrap"><a href="#5-产品详细信息区域制作-itemInfo-wrap" class="headerlink" title="5). 产品详细信息区域制作 itemInfo_wrap"></a>5). 产品详细信息区域制作 itemInfo_wrap</h2><p><img src="https://s1.ax1x.com/2020/11/06/BfJTZF.png" alt="我是图片"></p><ul><li><p>此盒子命名为 itemInfo</p></li><li><p>1 号盒子 为 头部 sku_name    </p></li><li><p>2 号盒子 为 最新新闻  news  </p></li><li><p>3号盒子 为  产品详细摘要  我们命名为  summary （摘要的意思）   之所以下面都是摘要部分，因为里面格式基本相同。</p></li><li><p>下面为详细命名</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>头部名称</td><td>sku_name       skull  头骨</td></tr><tr><td>新闻</td><td>news</td></tr><tr><td>摘要</td><td>summary</td></tr><tr><td>评价</td><td>remark</td></tr><tr><td>价格摘要</td><td>summary_price</td></tr><tr><td>促销摘要</td><td>summary_promotion</td></tr><tr><td>配送至</td><td>summary_stock</td></tr><tr><td>支持</td><td>summary_support</td></tr><tr><td>选择</td><td>choose</td></tr><tr><td>选择版本</td><td>choose_version</td></tr><tr><td>选择类型</td><td>choose_type</td></tr><tr><td>选择按钮组</td><td>choose_btns</td></tr><tr><td>选择数量</td><td>choose_amount        add 是加的意思</td></tr><tr><td>减去</td><td>reduce     cursor: not-allowed;  禁止符号</td></tr><tr><td>加入购物车</td><td>addshopcar</td></tr></tbody></table></li></ul><h2 id="6-产品细节模块-product-detail"><a href="#6-产品细节模块-product-detail" class="headerlink" title="6).  产品细节模块 product_detail"></a>6).  产品细节模块 product_detail</h2><p><img src="https://s1.ax1x.com/2020/11/06/BfJIqU.png" alt="我是图片"></p><ul><li>大盒子为 product_detail 模块 不要给高度 ，别忘记清除浮动</li><li>1号盒子 左侧浮动 命名为 aside  有宽度 不给高度</li><li>2号盒子 右侧浮动  命名为 detail   有宽度不给高度</li></ul><h3 id="6-1-aside-布局"><a href="#6-1-aside-布局" class="headerlink" title="6.1) aside 布局"></a>6.1) aside 布局</h3><p><img src="https://s1.ax1x.com/2020/11/06/BfJzqO.png" alt="我是图片"><br><img src="https://s1.ax1x.com/2020/11/06/BftwB8.png" alt="我是图片"></p><ul><li>1 号盒子 命名为 tab_list   给高度就好了 ，里面 放 ul 和 li   注意这是 tab栏切换布局</li><li>2 号盒子  命名为  tab_con    里面还包含 很多个ul.item 和 上面的 tab_list 里面的li一一对应。   </li></ul><h3 id="6-2-detail-布局"><a href="#6-2-detail-布局" class="headerlink" title="6.2) detail 布局"></a>6.2) detail 布局</h3><p><img src="https://s1.ax1x.com/2020/11/06/Bftdnf.png" alt="我是图片"></p><ul><li>1 号盒子 命名为 detail_tab_list   给高度就好了 ，里面 放 ul 和 li   注意这是 tab栏切换布局</li><li>2 号盒子  命名为  detail_tab_con    里面还包含 很多个ul.item 和 上面的 tab_list 里面的li一一对应。   </li></ul><h2 id="1-html-我们学的就是常用标签，-就是基本盒子"><a href="#1-html-我们学的就是常用标签，-就是基本盒子" class="headerlink" title="1. html 我们学的就是常用标签， 就是基本盒子"></a>1. html 我们学的就是常用标签， 就是基本盒子</h2><h2 id="2-css-就是用来美化布局网页。"><a href="#2-css-就是用来美化布局网页。" class="headerlink" title="2. css 就是用来美化布局网页。"></a>2. css 就是用来美化布局网页。</h2><h2 id="3-html-css-是没有逻辑可言的，基本就是搭积木摆放盒子的过程，你需要的是耐心。"><a href="#3-html-css-是没有逻辑可言的，基本就是搭积木摆放盒子的过程，你需要的是耐心。" class="headerlink" title="3. html+css 是没有逻辑可言的，基本就是搭积木摆放盒子的过程，你需要的是耐心。"></a>3. html+css 是没有逻辑可言的，基本就是搭积木摆放盒子的过程，你需要的是耐心。</h2><h2 id="4-对同学们来说，现在最困难的是-布局结构-。欠缺分析页面布局的能力"><a href="#4-对同学们来说，现在最困难的是-布局结构-。欠缺分析页面布局的能力" class="headerlink" title="4. 对同学们来说，现在最困难的是 布局结构 。欠缺分析页面布局的能力"></a>4. 对同学们来说，现在最困难的是 布局结构 。欠缺分析页面布局的能力</h2><h2 id="5-多看别人写的页面，模仿人家的布局，每次写页面总会有新的收获。"><a href="#5-多看别人写的页面，模仿人家的布局，每次写页面总会有新的收获。" class="headerlink" title="5. 多看别人写的页面，模仿人家的布局，每次写页面总会有新的收获。"></a>5. 多看别人写的页面，模仿人家的布局，每次写页面总会有新的收获。</h2><h2 id="6-错误总是在所难免，一定要学会利用chrome-调试工具，-他们能快速帮我们排查错误。你还需要细心。"><a href="#6-错误总是在所难免，一定要学会利用chrome-调试工具，-他们能快速帮我们排查错误。你还需要细心。" class="headerlink" title="6. 错误总是在所难免，一定要学会利用chrome 调试工具， 他们能快速帮我们排查错误。你还需要细心。"></a>6. 错误总是在所难免，一定要学会利用chrome 调试工具， 他们能快速帮我们排查错误。你还需要细心。</h2><h2 id="7-学好定位，对后面学习JavaScript-有很大的帮助。"><a href="#7-学好定位，对后面学习JavaScript-有很大的帮助。" class="headerlink" title="7. 学好定位，对后面学习JavaScript 有很大的帮助。"></a>7. 学好定位，对后面学习JavaScript 有很大的帮助。</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-品优购项目-四&quot;&gt;&lt;a href=&quot;#1-品优购项目-四&quot; class=&quot;headerlink&quot; title=&quot;1. 品优购项目(四)&quot;&gt;&lt;/a&gt;1. 品优购项目(四)&lt;/h1&gt;&lt;h2 id=&quot;1-详情页-detail-html-常用单词&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="电商网站构图思想" scheme="http://example.com/categories/%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E6%9E%84%E5%9B%BE%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="项目" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之基本引用类型</title>
    <link href="http://example.com/2020/10/24/%E7%BA%A2%E5%AE%9D%E4%B9%A68/"/>
    <id>http://example.com/2020/10/24/%E7%BA%A2%E5%AE%9D%E4%B9%A68/</id>
    <published>2020-10-24T05:06:43.000Z</published>
    <updated>2020-11-09T13:59:41.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><p>Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285 616 年的日期。</p><p> 要创建日期对象，就使用 new 操作符来调用 Date 构造函数：<br> 创建时间对象，在不传参数的情况下，返回当前日期时间对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br></pre></td></tr></table></figure><h2 id="获取时间的方法"><a href="#获取时间的方法" class="headerlink" title="获取时间的方法"></a>获取时间的方法</h2><table><thead><tr><th align="center">代码</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">getFullYear()</td><td align="center">返回4位数的年份</td></tr><tr><td align="center">getMonth()</td><td align="center">返回日期中的月份，返回值0-11</td></tr><tr><td align="center">getDate()</td><td align="center">返回月份中的天数</td></tr><tr><td align="center">getDay()</td><td align="center">返回星期，返回值为0-6</td></tr><tr><td align="center">getHours()</td><td align="center">返回小时</td></tr><tr><td align="center">getMinutes()</td><td align="center">返回分钟</td></tr><tr><td align="center">getMinutes()</td><td align="center">返回分钟</td></tr><tr><td align="center">getSeconds()</td><td align="center">返回秒</td></tr><tr><td align="center">getTime()</td><td align="center">返回日期的毫秒数</td></tr></tbody></table><hr><h2 id="设置时间的方法"><a href="#设置时间的方法" class="headerlink" title="设置时间的方法"></a>设置时间的方法</h2><table><thead><tr><th align="center">代码</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">setFullYear(year)</td><td align="center">设置4位数的年份</td></tr><tr><td align="center">setMonth(mon)</td><td align="center">设置日期中的月份，返回值0-11</td></tr><tr><td align="center">setDate()</td><td align="center">设置月份中的天数</td></tr><tr><td align="center">setDay()</td><td align="center">设置星期，返回值为0-6</td></tr><tr><td align="center">setHours()</td><td align="center">设置小时</td></tr><tr><td align="center">setMinutes()</td><td align="center">设置分钟</td></tr><tr><td align="center">setMinutes()</td><td align="center">设置分钟</td></tr><tr><td align="center">setSeconds()</td><td align="center">设置秒</td></tr><tr><td align="center">setTime()</td><td align="center">设置日期的毫秒数</td></tr></tbody></table><h3 id="获取一个日期时间对象"><a href="#获取一个日期时间对象" class="headerlink" title="获取一个日期时间对象"></a>获取一个日期时间对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="keyword">var</span> weeks=[<span class="string">&quot;日&quot;</span>,<span class="string">&quot;一&quot;</span>,<span class="string">&quot;二&quot;</span>,<span class="string">&quot;三&quot;</span>,<span class="string">&quot;四&quot;</span>,<span class="string">&quot;五&quot;</span>,<span class="string">&quot;六&quot;</span>],</span><br><span class="line">    today=<span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    year=today.getFullYear(),</span><br><span class="line">    month=today.getMonth()+<span class="number">1</span>,</span><br><span class="line">    date=today.getDate(),</span><br><span class="line">    week=today.getDay(),</span><br><span class="line">    hours=today.getHours(),</span><br><span class="line">    minutes=today.getMinutes(),</span><br><span class="line">    seconds=today.getSeconds(),</span><br><span class="line">    times=today.getTime(),</span><br><span class="line">    time=year+<span class="string">&#x27;年&#x27;</span>+month+<span class="string">&#x27;月&#x27;</span>+date+<span class="string">&#x27;日&#x27;</span>+hours+<span class="string">&#x27;时&#x27;</span>+minutes+<span class="string">&#x27;分&#x27;</span>+seconds+<span class="string">&#x27;秒 星期&#x27;</span>+weeks[week];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;现在是：&quot;</span>+time);</span><br><span class="line"><span class="built_in">console</span>.log(times);</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="设置一个日期时间对象"><a href="#设置一个日期时间对象" class="headerlink" title="设置一个日期时间对象"></a>设置一个日期时间对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> today=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      <span class="comment">//today.setFullYear(2017);</span></span><br><span class="line">      <span class="comment">//today.setMonth(15);</span></span><br><span class="line">      <span class="comment">//console.log(today.getFullYear());</span></span><br><span class="line">      <span class="comment">//  50天之后是星期</span></span><br><span class="line">      <span class="comment">// 第一种做法</span></span><br><span class="line">      <span class="comment">//today.setDate(today.getDate()+50);</span></span><br><span class="line">      <span class="comment">//console.log(today.getDay());</span></span><br><span class="line">      <span class="comment">// 第二种做法</span></span><br><span class="line">      <span class="keyword">var</span> weeks=[<span class="string">&quot;日&quot;</span>,<span class="string">&quot;一&quot;</span>,<span class="string">&quot;二&quot;</span>,<span class="string">&quot;三&quot;</span>,<span class="string">&quot;四&quot;</span>,<span class="string">&quot;五&quot;</span>,<span class="string">&quot;六&quot;</span>];</span><br><span class="line">      <span class="keyword">var</span> year=today.getFullYear();</span><br><span class="line">      <span class="keyword">var</span> month=today.getMonth();</span><br><span class="line">      <span class="keyword">var</span> day=today.getDate();</span><br><span class="line">      <span class="comment">// 创建了一个目标日期对象,年,月,日,时,分,秒</span></span><br><span class="line">      <span class="keyword">var</span> temp=<span class="keyword">new</span> <span class="built_in">Date</span>(year+<span class="number">1</span>,month,day);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;50天后的今天是：&quot;</span>+temp.getFullYear()+<span class="string">&#x27;-&#x27;</span>+(temp.getMonth()+<span class="number">1</span>)+<span class="string">&#x27;-&#x27;</span>+temp.getDate()+<span class="string">&#x27;-&#x27;</span>+<span class="string">&#x27;星期&#x27;</span>+weeks[temp.getDay()]);</span><br></pre></td></tr></table></figure><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>ECMAScript 提供了 Math 对象作为保存数学公式、信息和计算的地方。Math 对象提供了一些辅助计算的属性和方法。<br>注意 Math 对象上提供的计算要比直接在 JavaScript 实现的快得多，因为 Math 对象上的计算使用了 JavaScript 引擎中更高效的实现和处理器指令。但使用 Math 计算的问题是精度会因浏览器、操作系统、指令集和硬件而异。</p><h2 id="1-Math-对象属性"><a href="#1-Math-对象属性" class="headerlink" title="1. Math 对象属性"></a>1. Math 对象属性</h2><table><thead><tr><th align="center">属 性</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">Math.E</td><td align="center">自然对数的基数 e 的值</td></tr><tr><td align="center">Math.LN10</td><td align="center">10 为底的自然对数</td></tr><tr><td align="center">Math.LN2</td><td align="center">2 为底的自然对数</td></tr><tr><td align="center">Math.LOG2E</td><td align="center">以 2 为底 e 的对数</td></tr><tr><td align="center">Math.LOG10E</td><td align="center">以 10 为底 e 的对数</td></tr><tr><td align="center">Math.PI</td><td align="center">π 的值</td></tr><tr><td align="center">Math.SQRT1_2</td><td align="center">1/2 的平方根</td></tr><tr><td align="center">Math.SQRT2</td><td align="center">2 的平方根</td></tr></tbody></table><h2 id="2-min-和-max-方法"><a href="#2-min-和-max-方法" class="headerlink" title="2. min()和 max()方法"></a>2. min()和 max()方法</h2><h5 id="Math-对象也提供了很多辅助执行简单或复杂数学计算的方法。"><a href="#Math-对象也提供了很多辅助执行简单或复杂数学计算的方法。" class="headerlink" title="Math 对象也提供了很多辅助执行简单或复杂数学计算的方法。"></a>Math 对象也提供了很多辅助执行简单或复杂数学计算的方法。</h5><h5 id="min-和-max-方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数"><a href="#min-和-max-方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数" class="headerlink" title="min()和 max()方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数"></a>min()和 max()方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">console</span>.log(max); <span class="comment">// 54</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">console</span>.log(min); <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><h2 id="3-舍入方法"><a href="#3-舍入方法" class="headerlink" title="3. 舍入方法"></a>3. 舍入方法</h2><ol><li>Math.ceil()方法始终向上舍入为最接近的整数。</li><li>Math.floor()方法始终向下舍入为最接近的整数。</li><li>Math.round()方法执行四舍五入。</li><li>Math.fround()方法返回数值最接近的单精度（32 位）浮点值表示。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.9</span>)); <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.5</span>)); <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.1</span>)); <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.9</span>)); <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.5</span>)); <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.1</span>)); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">0.4</span>)); <span class="comment">// 0.4000000059604645</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">0.5</span>)); <span class="comment">// 0.5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">25.9</span>)); <span class="comment">// 25.899999618530273</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.9</span>)); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.5</span>)); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.1</span>)); <span class="comment">// 25 </span></span><br></pre></td></tr></table></figure></li></ol><h2 id="4-random-方法"><a href="#4-random-方法" class="headerlink" title="4. random()方法"></a>4. random()方法</h2><p>Math.random()方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1。对于希望显示随机名言或随机新闻的网页，这个方法是非常方便的。可以基于如下公式使用 Math.random()从一组整数中随机选择一个数</p><p>####注意 Math.random()方法在这里出于演示目的是没有问题的。如果是为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），那么建议使用 window.crypto.getRandomValues()。</p><h2 id="5-Math-abs"><a href="#5-Math-abs" class="headerlink" title="5.Math.abs()"></a>5.Math.abs()</h2><p>返回绝对值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> abs = <span class="built_in">Math</span>.abs(<span class="number">-3</span>, <span class="number">-54</span>, <span class="number">-32</span>, <span class="number">-16</span>);</span><br><span class="line"><span class="built_in">console</span>.log(abs); <span class="comment">// (3, 54, 32, 16)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h1><p>为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。</p><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入true 或 false，如下例所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> booleanObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); </span><br></pre></td></tr></table></figure><p>Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调用时也会被覆盖，返回字符串”true”或”false”。不过，Boolean 对象在 ECMAScript 中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用 Boolean 对象时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>;</span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>我们创建一个值为 false 的 Boolean 对象。然后，在一个布尔表达式中通过&amp;&amp;操作将这个对象与一个原始值 true 组合起来。在布尔算术中，false &amp;&amp; true 等于 false。可是，这个表达式是对 falseObject 对象而不是对它表示的值（false）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为 true，因此 falseObject 在这个表达式里实际上表示一个 true 值。那么true &amp;&amp; true 当然是 true。</p><p>除此之外，原始值和引用值（Boolean 对象）还有几个区别。首先，typeof 操作符对原始值返回”boolean”，但对引用值返回”object”。同样，Boolean 对象是 Boolean 类型的实例，在使用instaceof 操作符时返回 true，但对原始值则返回 false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseValue); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>理解原始布尔值和 Boolean 对象之间的区别非常重要，强烈建议永远不要使用后者。</p><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值<br>与 Boolean 类型一样，Number 类型重写了 valueOf()、toLocaleString()和 toString()方法。valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString()); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)); <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>)); <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">10</span>)); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>)); <span class="comment">// &quot;a&quot; </span></span><br></pre></td></tr></table></figure><h3 id="toFixed-方法返回包含指定小数点位数的数值字符串"><a href="#toFixed-方法返回包含指定小数点位数的数值字符串" class="headerlink" title="toFixed()方法返回包含指定小数点位数的数值字符串"></a>toFixed()方法返回包含指定小数点位数的数值字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)); <span class="comment">// &quot;10.00&quot; </span></span><br></pre></td></tr></table></figure><p>这里的 toFixed()方法接收了参数 2，表示返回的数值字符串要包含两位小数。结果返回值为”10.00”，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10.005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)); <span class="comment">// &quot;10.01&quot; </span></span><br></pre></td></tr></table></figure><p>toFixed()自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，0.1 + 0.2 = 0.30000000000000004。</p><h4 id="注意-toFixed-方法可以表示有-0-20-个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。"><a href="#注意-toFixed-方法可以表示有-0-20-个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。" class="headerlink" title="注意 toFixed()方法可以表示有 0~20 个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。"></a>注意 toFixed()方法可以表示有 0~20 个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。</h4><h3 id="toPrecision-方法"><a href="#toPrecision-方法" class="headerlink" title="toPrecision()方法"></a>toPrecision()方法</h3><p>会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">1</span>)); <span class="comment">// &quot;1e+2&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>)); <span class="comment">// &quot;99&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>)); <span class="comment">// &quot;99.0&quot; </span></span><br></pre></td></tr></table></figure><p>在这个例子中，首先要用 1 位数字表示数值 99，得到”1e+2”，也就是 100。因为 99 不能只用 1 位数字来精确表示，所以这个方法就将它舍入为 100，这样就可以只用 1 位数字（及其科学记数法形式）来表示了。用 2 位数字表示 99 得到”99”，用 3 位数字则是”99.0”。本质上，toPrecision()方法会根据数值和精度来决定调用 toFixed()还是 toExponential()。为了以正确的小数位精确表示数值，这 3 个方法都会向上或向下舍入。</p><p>与 Boolean 对象类似，Number 对象也为数值提供了重要能力。但是，考虑到两者存在同样的潜在问题，因此并不建议直接实例化 Number 对象。在处理原始数值和引用数值时，typeof 和 instacnceof操作符会返回不同的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> numberValue = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberObject); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberValue); <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(numberObject <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(numberValue <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>原始数值在调用 typeof 时始终返回”number”，而 Number 对象则返回”object”。类似地，Number对象是 Number 类型的实例，而原始数值不是。</p><h3 id="isInteger-方法"><a href="#isInteger-方法" class="headerlink" title="isInteger()方法"></a>isInteger()方法</h3><p>ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.00</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.01</span>)); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String 是对应字符串的引用类型。要创建一个 String 对象，使用 String 构造函数并传入一个数值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="每个-String-对象都有一个-length-属性，表示字符串中字符的数量。"><a href="#每个-String-对象都有一个-length-属性，表示字符串中字符的数量。" class="headerlink" title="每个 String 对象都有一个 length 属性，表示字符串中字符的数量。"></a>每个 String 对象都有一个 length 属性，表示字符串中字符的数量。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.length); <span class="comment">// &quot;11&quot; </span></span><br></pre></td></tr></table></figure><h3 id="1-JavaScript-字符"><a href="#1-JavaScript-字符" class="headerlink" title="1. JavaScript 字符"></a>1. JavaScript 字符</h3><p>JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少 16 位码元</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.length); <span class="comment">// 5 </span></span><br></pre></td></tr></table></figure><h1 id="单例内置对象"><a href="#单例内置对象" class="headerlink" title="单例内置对象"></a>单例内置对象</h1><p>ECMA-262 对内置对象的定义是“任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript程序开始执行时就存在的对象”。这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已经接触了大部分内置对象，包括 Object、Array 和 String。本节介绍 ECMA-262定义的另外两个单例内置对象：Global 和 Math。</p><h1 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h1><p>Global 对象是 ECMAScript 中最特别的对象，因为代码不会显式地访问它。ECMA-262 规定 Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。</p><h3 id="1-URL-编码方法"><a href="#1-URL-编码方法" class="headerlink" title="1.URL 编码方法"></a>1.URL 编码方法</h3><p>encodeURI()和 encodeURIComponent()方法用于编码统一资源标识符（URI），以便传给浏览器。有效的 URI 不能包含某些字符，比如空格。使用 URI 编码方法来编码 URI 可以让浏览器能够理解它们，同时又以特殊的 UTF-8 编码替换掉所有无效字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http://www.wrox.com/illegal value.js#start&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;http://www.wrox.com/illegal%20value.js#start&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(uri)); </span><br></pre></td></tr></table></figure><p>这里使用 encodeURI()编码后，除空格被替换为%20 之外，没有任何变化。而 encodeURIComponent()方法将所有非字母字符都替换成了相应的编码形式。这就是使用 encodeURI()编码整个URI，但只使用 encodeURIComponent()编码那些会追加到已有 URI 后面的字符串的原因。</p><h4 id="注意-一般来说，使用-encodeURIComponent-应该比使用-encodeURI-的频率更高，这是因为编码查询字符串参数比编码基准-URI-的次数更多。"><a href="#注意-一般来说，使用-encodeURIComponent-应该比使用-encodeURI-的频率更高，这是因为编码查询字符串参数比编码基准-URI-的次数更多。" class="headerlink" title="注意 一般来说，使用 encodeURIComponent()应该比使用 encodeURI()的频率更高，这是因为编码查询字符串参数比编码基准 URI 的次数更多。"></a>注意 一般来说，使用 encodeURIComponent()应该比使用 encodeURI()的频率更高，这是因为编码查询字符串参数比编码基准 URI 的次数更多。</h4><p>与 encodeURI()和 encodeURIComponent()相对的是 decodeURI()和 decodeURIComponent()。decodeURI()只对使用 encodeURI()编码过的字符解码。例如，%20 会被替换为空格，但%23 不会被替换为井号（#），因为井号不是由 encodeURI()替换的。类似地，decodeURIComponent()解码所有被encodeURIComponent()编码的字符，基本上就是解码所有特殊值。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;</span>;</span><br><span class="line"><span class="comment">// http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURI</span>(uri));</span><br><span class="line"><span class="comment">// http:// www.wrox.com/illegal value.js#start</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure><p>这里，uri 变量中包含一个使用 encodeURIComponent()编码过的字符串。首先输出的是使用decodeURI()解码的结果，可以看到只用空格替换了%20。然后是使用 decodeURIComponent()解码的结果，其中替换了所有特殊字符，并输出了没有包含任何转义的字符串。（这个字符串不是有效的 URL。）</p><h4 id="注意-URI方法-encodeURI-、encodeURIComponent-、decodeURI-和-decodeURIComponent-取代了-escape-和-unescape-方法，后者在-ECMA-262-第-3-版中就已经废弃了。URI-方法始终是首选方法，因为它们对所有-Unicode-字符进行编码，而原来的方法只能正确编码-ASCII-字符。不要在生产环境中使用-escape-和-unescape-。"><a href="#注意-URI方法-encodeURI-、encodeURIComponent-、decodeURI-和-decodeURIComponent-取代了-escape-和-unescape-方法，后者在-ECMA-262-第-3-版中就已经废弃了。URI-方法始终是首选方法，因为它们对所有-Unicode-字符进行编码，而原来的方法只能正确编码-ASCII-字符。不要在生产环境中使用-escape-和-unescape-。" class="headerlink" title="注意 URI方法 encodeURI()、encodeURIComponent()、decodeURI()和 decodeURIComponent()取代了 escape()和 unescape()方法，后者在 ECMA-262 第 3 版中就已经废弃了。URI 方法始终是首选方法，因为它们对所有 Unicode 字符进行编码，而原来的方法只能正确编码 ASCII 字符。不要在生产环境中使用 escape()和 unescape()。"></a>注意 URI方法 encodeURI()、encodeURIComponent()、decodeURI()和 decodeURIComponent()取代了 escape()和 unescape()方法，后者在 ECMA-262 第 3 版中就已经废弃了。URI 方法始终是首选方法，因为它们对所有 Unicode 字符进行编码，而原来的方法只能正确编码 ASCII 字符。不要在生产环境中使用 escape()和 unescape()。</h4><h3 id="2-eval-方法"><a href="#2-eval-方法" class="headerlink" title="2. eval()方法"></a>2. eval()方法</h3><p>最后一个方法可能是整个 ECMAScript 语言中最强大的了，它就是 eval()。这个方法就是一个完整的 ECMAScript 解释器，它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(&#x27;hi&#x27;)&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>); </span><br></pre></td></tr></table></figure><p>当解释器发现 eval()调用时，会将参数解释为实际的 ECMAScript 语句，然后将其插入到该位置。通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在 eval()调用内部被引用，比如下面这个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(msg)&quot;</span>); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>这里，变量 msg 是在 eval()调用的外部上下文中定义的，而 console.log()显示了文本”helloworld”。这是因为第二行代码会被替换成一行真正的函数调用代码。类似地，可以在 eval()内部定义一个函数或变量，然后在外部代码中引用，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;function sayHi() &#123; console.log(&#x27;hi&#x27;); &#125;&quot;</span>);</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure><p>这里，函数 sayHi()是在 eval()内部定义的。因为该调用会被替换为真正的函数定义，所以才可能在下一行代码中调用 sayHi()。对于变量也是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;let msg = &#x27;hello world&#x27;;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg); <span class="comment">// Reference Error: msg is not defined</span></span><br></pre></td></tr></table></figure><p>通过 eval()定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在 eval()执行的时候才会被创建。<br>在严格模式下，在 eval()内部创建的变量和函数无法被外部访问。换句话说，最后两个例子会报错。同样，在严格模式下，赋值给 eval 也会导致错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span> = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 导致错误</span></span><br></pre></td></tr></table></figure><h4 id="注意-解释代码字符串的能力是非常强大的，但也非常危险。在使用-eval-的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对-XSS-利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。"><a href="#注意-解释代码字符串的能力是非常强大的，但也非常危险。在使用-eval-的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对-XSS-利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。" class="headerlink" title="注意 解释代码字符串的能力是非常强大的，但也非常危险。在使用 eval()的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对 XSS 利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。"></a>注意 解释代码字符串的能力是非常强大的，但也非常危险。在使用 eval()的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对 XSS 利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。</h4><h3 id="3-Global-对象属性"><a href="#3-Global-对象属性" class="headerlink" title="3.Global 对象属性"></a>3.Global 对象属性</h3><p>像 undefined、NaN 和 Infinity 等特殊值都是 Global 对象的属性。此外，所有原生引用类型构造函数，比如 Object 和 Function，也都是Global 对象的属性。</p><table><thead><tr><th align="center">属 性</th><th align="center">说 明</th></tr></thead><tbody><tr><td align="center">undefined</td><td align="center">特殊值 undefined</td></tr><tr><td align="center">NaN</td><td align="center">特殊值 NaN</td></tr><tr><td align="center">Infinity</td><td align="center">特殊值 Infinity</td></tr><tr><td align="center">Object</td><td align="center">Object 的构造函数</td></tr><tr><td align="center">Array</td><td align="center">Array 的构造函数</td></tr><tr><td align="center">Function</td><td align="center">Function 的构造函数</td></tr><tr><td align="center">Boolean</td><td align="center">Boolean 的构造函数</td></tr><tr><td align="center">String</td><td align="center">String 的构造函数</td></tr><tr><td align="center">Number</td><td align="center">Number 的构造函数</td></tr><tr><td align="center">Date</td><td align="center">Date 的构造函数</td></tr><tr><td align="center">RegExp</td><td align="center">RegExp 的构造函数</td></tr><tr><td align="center">Symbol</td><td align="center">Symbol 的伪构造函数</td></tr><tr><td align="center">Error</td><td align="center">Error 的构造函数</td></tr><tr><td align="center">EvalError</td><td align="center">EvalError 的构造函数</td></tr><tr><td align="center">RangeError</td><td align="center">RangeError 的构造函数</td></tr><tr><td align="center">ReferenceError</td><td align="center">ReferenceError 的构造函数</td></tr><tr><td align="center">SyntaxError</td><td align="center">SyntaxError 的构造函数</td></tr><tr><td align="center">TypeError</td><td align="center">TypeError 的构造函数</td></tr><tr><td align="center">URIError</td><td align="center">URIError 的构造函数</td></tr></tbody></table><h3 id="4-window-对象"><a href="#4-window-对象" class="headerlink" title="4.window 对象"></a>4.window 对象</h3><h5 id="虽然-ECMA-262-没有规定直接访问-Global-对象的方式，但浏览器将-window-对象实现为-Global对象的代理。"><a href="#虽然-ECMA-262-没有规定直接访问-Global-对象的方式，但浏览器将-window-对象实现为-Global对象的代理。" class="headerlink" title="虽然 ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global对象的代理。"></a>虽然 ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global对象的代理。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">window</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.sayColor(); <span class="comment">// &quot;red&quot; </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里定义了一个名为color的全局变量和一个名为sayColor()的全局函数。在sayColor()内部，通过 window.color 访问了 color 变量，说明全局变量变成了 window 的属性。接着，又通过 window对象直接调用了 window.sayColor()函数，从而输出字符串。</p><p>另一种获取 Global 对象的方式是使用如下的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">global</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>这段代码创建一个立即调用的函数表达式，返回了 this 的值。如前所述，当一个函数在没有明确（通过成为某个对象的方法，或者通过 call()/apply()）指定 this 值的情况下执行时，this 值等于Global 对象。因此，调用一个简单返回 this 的函数是在任何执行上下文中获取 Global 对象的通用方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Date&quot;&gt;&lt;a href=&quot;#Date&quot; class=&quot;headerlink&quot; title=&quot;Date&quot;&gt;&lt;/a&gt;Date&lt;/h1&gt;&lt;p&gt;Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1</summary>
      
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="Date" scheme="http://example.com/tags/Date/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之垃圾回收</title>
    <link href="http://example.com/2020/10/23/%E7%BA%A2%E5%AE%9D%E4%B9%A67/"/>
    <id>http://example.com/2020/10/23/%E7%BA%A2%E5%AE%9D%E4%B9%A67/</id>
    <published>2020-10-23T05:06:43.000Z</published>
    <updated>2020-11-09T13:27:50.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p> JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。<br>基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。<br>垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。</p><h2 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h2><p>JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p><p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。</p><p>垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p><p>到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>没那么常用的垃圾回收策略是引用计数（reference counting）。</p><p>其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。</p><p>引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> <span class="keyword">let</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> objectA.someOtherObject = objectB;</span><br><span class="line"> objectB.anotherObject = objectA;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>objectA 和 objectB 通过各自的属性相互引用，意味着它们的引用数都是 2。在标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，objectA 和 objectB 在函数结束后还会存在，因为它们的引用数永远不会变成 0。如果函数被多次调用，则会导致大量内存永远不会被释放。为此，Netscape 在 4.0 版放弃了引用计数，转而采用标记清理。事实上，引用计数策略的问题还不止于此。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。</p><p>现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。比如，根据 V8 团队 2016 年的一篇博文的说法：“在一次完整的垃圾回收之后，V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃<br>圾回收。”</p><p>由于调度垃圾回收程序方面的问题会导致性能下降，IE 曾饱受诟病。它的策略是根据分配数，比如分配了 256 个变量、4096 个对象/数组字面量和数组槽位（slot），或者 64KB 字符串。只要满足其中某个条件，垃圾回收程序就会运行。这样实现的问题在于，分配那么多变量的脚本，很可能在其整个生命周期内始终需要那么多变量，结果就会导致垃圾回收程序过于频繁地运行。由于对性能的严重影响，IE7最终更新了垃圾回收程序。</p><p>IE7 发布后，JavaScript 引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。IE7 的起始阈值都与 IE6 的相同。如果垃圾回收程序回收的内存不到已分配的 15%，这些变量、字面量或数组槽位的阈值就会翻倍。如果有一次回收的内存达到已分配的 85%，则阈值重置为默认值。这么一个简单的修改，极大地提升了重度依赖 JavaScript 的网页在浏览器中的性能。</p><h4 id="警告-在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在-IE-中，window-CollectGarbage-方法会立即触发垃圾回收。在-Opera-7-及更高版本中，调用-window-opera-collect-也会启动垃圾回收程序。"><a href="#警告-在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在-IE-中，window-CollectGarbage-方法会立即触发垃圾回收。在-Opera-7-及更高版本中，调用-window-opera-collect-也会启动垃圾回收程序。" class="headerlink" title="警告 在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在 IE 中，window.CollectGarbage()方法会立即触发垃圾回收。在 Opera 7 及更高版本中，调用 window.opera.collect()也会启动垃圾回收程序。"></a>警告 在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在 IE 中，window.CollectGarbage()方法会立即触发垃圾回收。在 Opera 7 及更高版本中，调用 window.opera.collect()也会启动垃圾回收程序。</h4><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过，JavaScript 运行在一个内存管理与垃圾回收都很特殊的环境。分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运行大量 JavaScript 的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。 </p><p>将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">let</span> localPerson = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> localPerson.name = name;</span><br><span class="line"> <span class="keyword">return</span> localPerson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> globalPerson = createPerson(<span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="comment">// 解除 globalPerson 对值的引用</span></span><br><span class="line">globalPerson = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>在上面的代码中，变量 globalPerson 保存着 createPerson()函数调用返回的值。在 createPerson()内部，localPerson 创建了一个对象并给它添加了一个 name 属性。然后，localPerson 作为函数值被返回，并被赋值给 globalPerson。localPerson 在 createPerson()执行完成超出上下文后会自动被解除引用，不需要显式处理。但 globalPerson 是一个全局变量，应该在不再需要时手动解除其引用，最后一行就是这么做的。</p><p>不过要注意，解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。</p><h3 id="1-通过-const-和-let-声明提升性能"><a href="#1-通过-const-和-let-声明提升性能" class="headerlink" title="1.通过 const 和 let 声明提升性能"></a>1.通过 const 和 let 声明提升性能</h3><p>ES6 增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为 const和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生。</p><h3 id="2-隐藏类和删除操作"><a href="#2-隐藏类和删除操作" class="headerlink" title="2.隐藏类和删除操作"></a>2.隐藏类和删除操作</h3><p>根据 JavaScript 所在的运行环境，有时候需要根据浏览器使用的 JavaScript 引擎来采取不同的性能优化策略。截至 2017 年，Chrome 是最流行的浏览器，使用 V8 JavaScript 引擎。V8 在将解释后的 JavaScript代码编译为实际的机器码时会利用“隐藏类”。如果你的代码非常注重性能，那么这一点可能对你很重要。<br>运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类<br>的对象性能会更好，V8 会针对这种情况进行优化，但不一定总能够做到。比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br></pre></td></tr></table></figure><p>V8 会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。假设之后又添加了下面这行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2.author = <span class="string">&#x27;Jake&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此时两个 Article 实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能对性能产生明显影响。当然，解决方案就是避免 JavaScript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在构造函数中一次性声明所有属性，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">opt_author</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line"> <span class="built_in">this</span>.author = opt_author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article(<span class="string">&#x27;Jake&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这样，两个实例基本上就一样了（不考虑 hasOwnProperty 的返回值），因此可以共享一个隐藏类，从而带来潜在的性能提升。不过要记住，使用 delete 关键字会导致生成相同的隐藏类片段。看一下这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line"> <span class="built_in">this</span>.author = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">delete</span> a1.author;</span><br></pre></td></tr></table></figure><p>在代码结束后，即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为 null。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line"> <span class="built_in">this</span>.author = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line">a1.author = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure><h3 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3.内存泄漏"></a>3.内存泄漏</h3><p>写得不好的 JavaScript 可能出现难以察觉且有害的内存泄漏问题。在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由不合理的引用导致的。<br>意外声明全局变量是最常见但也最容易修复的内存泄漏问题。下面的代码没有使用任何关键字声明变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>此时，解释器会把变量 name 当作 window 的属性来创建（相当于 window.name = ‘Jake’）。可想而知，在 window 对象上创建的属性，只要 window 本身不被清理就不会消失。这个问题很容易解决，只要在变量声明前头加上 var、let 或 const 关键字即可，这样变量就会在函数执行完毕后离开作用域。</p><p>定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;, <span class="number">100</span>); </span><br></pre></td></tr></table></figure><p>只要定时器一直运行，回调函数中引用的 name 就会一直占用内存。垃圾回收程序当然知道这一点，因而就不会清理外部变量。</p><p>使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> name;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>调用 outer()会导致分配给 name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 name，因为闭包一直在引用着它。假如 name 的内容很大（不止是一个小字符串），那可能就是个大问题了。</p><h3 id="4-静态分配与对象池"><a href="#4-静态分配与对象池" class="headerlink" title="4. 静态分配与对象池"></a>4. 静态分配与对象池</h3><p>为了提升 JavaScript 性能，最后要考虑的一点往往就是压榨浏览器了。此时，一个关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。</p><p>浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。看一看下面的例子，这是一个计算二维矢量加法的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVector</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> resultant = <span class="keyword">new</span> Vector();</span><br><span class="line"> resultant.x = a.x + b.x;</span><br><span class="line"> resultant.y = a.y + b.y;</span><br><span class="line"> <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个函数时，会在堆上创建一个新对象，然后修改它，最后再把它返回给调用者。如果这个矢量对象的生命周期很短，那么它会很快失去所有对它的引用，成为可以被回收的值。假如这个矢量加法函数频繁被调用，那么垃圾回收调度程序会发现这里对象更替的速度很快，从而会更频繁地安排垃圾回收。该问题的解决方案是不要动态创建矢量对象，比如可以修改上面的函数，让它使用一个已有的矢量对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVector</span>(<span class="params">a, b, resultant</span>) </span>&#123;</span><br><span class="line"> resultant.x = a.x + b.x;</span><br><span class="line"> resultant.y = a.y + b.y;</span><br><span class="line"> <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这需要在其他地方实例化矢量参数 resultant，但这个函数的行为没有变。那么在哪里创建矢量可以不让垃圾回收调度程序盯上呢？</p><p>一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。下面是一个对象池的伪实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vectorPool 是已有的对象池</span></span><br><span class="line"><span class="keyword">let</span> v1 = vectorPool.allocate();</span><br><span class="line"><span class="keyword">let</span> v2 = vectorPool.allocate();</span><br><span class="line"><span class="keyword">let</span> v3 = vectorPool.allocate();</span><br><span class="line">v1.x = <span class="number">10</span>;</span><br><span class="line">v1.y = <span class="number">5</span>;</span><br><span class="line">v2.x = <span class="number">-3</span>;</span><br><span class="line">v2.y = <span class="number">-6</span>;</span><br><span class="line">addVector(v1, v2, v3);</span><br><span class="line"><span class="built_in">console</span>.log([v3.x, v3.y]); <span class="comment">// [7, -1]</span></span><br><span class="line">vectorPool.free(v1);</span><br><span class="line">vectorPool.free(v2);</span><br><span class="line">vectorPool.free(v3);</span><br><span class="line"><span class="comment">// 如果对象有属性引用了其他对象</span></span><br><span class="line"><span class="comment">// 则这里也需要把这些属性设置为 null</span></span><br><span class="line">v1 = <span class="literal">null</span>;</span><br><span class="line">v2 = <span class="literal">null</span>;</span><br><span class="line">v3 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。这个对象池必须使用某种结构维护所有对象，数组是比较好的选择。不过，使用数组来实现，必须留意不要招致额外的垃圾回收。比如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vectorList = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">let</span> vector = <span class="keyword">new</span> Vector();</span><br><span class="line">vectorList.push(vector);</span><br></pre></td></tr></table></figure><p>由于 JavaScript 数组的大小是动态可变的，引擎会删除大小为 100 的数组，再创建一个新的大小为200 的数组。垃圾回收程序会看到这个删除操作，说不定因此很快就会跑来收一次垃圾。要避免这种动态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。不过，必须事先想好这个数组有多大。</p><h5 id="注意-静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。"><a href="#注意-静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。" class="headerlink" title="注意 静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。"></a>注意 静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收&quot;&gt;&lt;a href=&quot;#垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收&quot;&gt;&lt;/a&gt;垃圾回收&lt;/h1&gt;&lt;p&gt; JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。&lt;br&gt;基本思路很简单：确定哪个变量</summary>
      
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="垃圾回收" scheme="http://example.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之变量、作用域</title>
    <link href="http://example.com/2020/10/22/%E7%BA%A2%E5%AE%9D%E4%B9%A66/"/>
    <id>http://example.com/2020/10/22/%E7%BA%A2%E5%AE%9D%E4%B9%A66/</id>
    <published>2020-10-22T05:06:43.000Z</published>
    <updated>2020-11-09T13:14:03.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量、作用域"><a href="#变量、作用域" class="headerlink" title="变量、作用域"></a>变量、作用域</h1><p>相比于其他语言，JavaScript 中的变量可谓独树一帜。正如 ECMA-262 所规定的，JavaScript 变量是松散类型的，而且变量不过就是特定时间点一个特定值的名称而已。由于没有规则定义变量必须包含什么数据类型，变量的值和数据类型在脚本生命期内可以改变。这样的变量很有意思，很强大，当然也有不少问题。</p><h2 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h2><p>ECMAScript 变量可以包含两种不同类型的数据：<br>原始值（primitive value）就是最简单的数据<br>引用值（reference value）则是由多个值构成的对象</p><h2 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h2><p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。对于引用值而言，可以随时添加、修改和删除其属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot; </span></span><br></pre></td></tr></table></figure><p>首先创建了一个对象，并把它保存在变量 person 中。然后，给这个对象添加了一个名为name 的属性，并给这个属性赋值了一个字符串”Nicholas”。在此之后，就可以访问这个新属性，直到对象被销毁或属性被显式地删除。<br>原始值不能有属性，尽管尝试给原始值添加属性不会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">name.age = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.age); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><p>在此，代码想给字符串 name 定义一个 age 属性并给该属性赋值 27。紧接着在下一行，属性不见了。记住，只有引用值可以动态添加后面可以使用的属性。<br>注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">name1.age = <span class="number">27</span>;</span><br><span class="line">name2.age = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1.age); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age); <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2); <span class="comment">// object </span></span><br></pre></td></tr></table></figure><h2 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h2><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num1; </span><br></pre></td></tr></table></figure><p>这里，num1 包含数值 5。当把 num2 初始化为 num1 时，num2 也会得到数值 5。这个值跟存储在num1 中的 5 是完全独立的，因为它是那个值的副本。</p><p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来，如下面的例子所示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// &quot;Nicholas&quot; </span></span><br></pre></td></tr></table></figure><p>变量 obj1 保存了一个新对象的实例。然后，这个值被复制到 obj2，此时两个变量都指向了同一个对象。在给 obj1 创建属性 name 并赋值后，通过 obj2 也可以访问这个属性，因为它们都指向同一个对象。图 4-2 展示了变量与堆内存中对象之间的关系。</p><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。</p><p>在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用 ECMAScript 的话说，就是 arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> num += <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>; </span><br><span class="line"><span class="keyword">let</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 20，没有变化</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 30 </span></span><br></pre></td></tr></table></figure><p>这里，函数 addTen()有一个参数 num，它其实是一个局部变量。在调用时，变量 count 作为参数传入。count 的值是 20，这个值被复制到参数 num 以便在 addTen()内部使用。在函数内部，参数 num的值被加上了 10，但这不会影响函数外部的原始变量 count。参数 num 和变量 count 互不干扰，它们只不过碰巧保存了一样的值。如果 num 是按引用传递的，那么 count 的值也会被修改为 30。这个事实在使用数值这样的原始值时是非常明显的。但是，如果变量中传递的是对象，就没那么清楚了。比如，再看这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"> obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>这一次，我们创建了一个对象并把它保存在变量 person 中。然后，这个对象被传给 setName()方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象。当函数内部给 obj 设置了 name 属性时，函数外部的对象也会反映这个变化，因为 obj 指向的对象保存在全局作用域的堆内存上。很多开发者错误地认为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"> obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> obj.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>这个例子前后唯一的变化就是 setName()中多了两行代码，将 obj 重新定义为一个有着不同 name的新对象。当 person 传入 setName()时，其 name 属性被设置为”Nicholas”。然后变量 obj 被设置为一个新对象且 name 属性被设置为”Greg”。如果 person 是按引用传递的，那么 person 应该自动将指针改为指向 name 为”Greg”的对象。可是，当我们再次访问 person.name 时，它的值是”Nicholas”，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</p><h2 id="确定类型"><a href="#确定类型" class="headerlink" title="确定类型"></a>确定类型</h2><p>前一章提到的 typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null，那么 typeof返回”object”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">let</span> u;</span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> u); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了instanceof 操作符，语法如下： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = variable <span class="keyword">instanceof</span> <span class="keyword">constructor</span></span><br></pre></td></tr></table></figure><p>如果变量是给定引用类型（由其原型链决定，将在第 8 章详细介绍）的实例，则 instanceof 操作符返回 true。来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// 变量 person 是 Object 吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// 变量 colors 是 Array 吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">// 变量 pattern 是 RegExp 吗？</span></span><br></pre></td></tr></table></figure><p>按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和Object 构造函数都会返回 true。类似地，如果用 instanceof 检测原始值，则始终会返回 false，因为原始值不是对象。</p><h3 id="注意-typeof-操作符在用于检测函数时也会返回”function”。当在-Safari（直到-Safari-5）和-Chrome（直到-Chrome-7）中用于检测正则表达式时，由于实现细节的原因，typeof也会返回”function”。ECMA-262-规定，任何实现内部-Call-方法的对象都应该在typeof-检测时返回”function”。因为上述浏览器中的正则表达式实现了这个方法，所以-typeof-对正则表达式也返回”function”。在-IE-和-Firefox-中，typeof-对正则表达式返回”object”。"><a href="#注意-typeof-操作符在用于检测函数时也会返回”function”。当在-Safari（直到-Safari-5）和-Chrome（直到-Chrome-7）中用于检测正则表达式时，由于实现细节的原因，typeof也会返回”function”。ECMA-262-规定，任何实现内部-Call-方法的对象都应该在typeof-检测时返回”function”。因为上述浏览器中的正则表达式实现了这个方法，所以-typeof-对正则表达式也返回”function”。在-IE-和-Firefox-中，typeof-对正则表达式返回”object”。" class="headerlink" title="注意  typeof 操作符在用于检测函数时也会返回”function”。当在 Safari（直到 Safari 5）和 Chrome（直到 Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof也会返回”function”。ECMA-262 规定，任何实现内部[[Call]]方法的对象都应该在typeof 检测时返回”function”。因为上述浏览器中的正则表达式实现了这个方法，所以 typeof 对正则表达式也返回”function”。在 IE 和 Firefox 中，typeof 对正则表达式返回”object”。"></a>注意  typeof 操作符在用于检测函数时也会返回”function”。当在 Safari（直到 Safari 5）和 Chrome（直到 Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof也会返回”function”。ECMA-262 规定，任何实现内部[[Call]]方法的对象都应该在typeof 检测时返回”function”。因为上述浏览器中的正则表达式实现了这个方法，所以 typeof 对正则表达式也返回”function”。在 IE 和 Firefox 中，typeof 对正则表达式返回”object”。</h3><h2 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h2><p>变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。</p><p>全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数。</p><p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。</p><p>上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终<br>是作用域链的最后一个变量对象。</p><p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (color === <span class="string">&quot;blue&quot;</span>) &#123;</span><br><span class="line"> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><p>对这个例子而言，函数 changeColor()的作用域链包含两个对象：一个是它自己的变量对象（就是定义 arguments 对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量color，就是因为可以在作用域链中找到它。</p><p>此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line"> anotherColor = color;</span><br><span class="line"> color = tempColor;</span><br><span class="line"> <span class="comment">// 这里可以访问 color、anotherColor 和 tempColor</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 这里可以访问 color 和 anotherColor，但访问不到 tempColor</span></span><br><span class="line"> swapColors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问 color</span></span><br><span class="line">changeColor(); </span><br></pre></td></tr></table></figure><p>以上代码涉及 3 个上下文：全局上下文、changeColor()的局部上下文和 swapColors()的局部上下文。全局上下文中有一个变量 color 和一个函数 changeColor()。changeColor()的局部上下文中有一个变量 anotherColor 和一个函数 swapColors()，但在这里可以访问全局上下文中的变量 color。swapColors()的局部上下文中有一个变量 tempColor，只能在这个上下文中访问到。全局上下文和changeColor()的局部上下文都无法访问到 tempColor。而在 swapColors()中则可以访问另外两个上下文中的变量，因为它们都是父上下文。<br><a href="https://imgchr.com/i/BbCQYV"><img src="https://s1.ax1x.com/2020/11/09/BbCQYV.png" alt="BbCQYV.png"></a></p><p>内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。swapColors()局部上下文的作用域链中有 3 个对象：swapColors()的变量对象、changeColor()的变量对象和全局变量对象。swapColors()的局部上下文首先从自己的变量对象开始搜索变量和函数，搜不到就去搜索上一级变量对象。changeColor()上下文的作用域链中只有 2 个对象：它自己的变量对象和全局变量对象。因此，它不能访问 swapColors()的上下文。</p><h3 id="注意-函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。"><a href="#注意-函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。" class="headerlink" title="注意 函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。"></a>注意 函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。</h3><h2 id="1-使用-var-的函数作用域声明"><a href="#1-使用-var-的函数作用域声明" class="headerlink" title="1. 使用 var 的函数作用域声明"></a>1. 使用 var 的函数作用域声明</h2><p>在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了那么它就会自动被添加到全局上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 报错：sum 在这里不是有效变量</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数 add()定义了一个局部变量 sum，保存加法操作的结果。这个值作为函数的值被返回，但变量 sum 在函数外部是访问不到的。如果省略上面例子中的关键字 var，那么 sum 在 add()被调用之后就变成可以访问的了，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> sum = num1 + num2;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 30 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一次，变量 sum 被用加法操作的结果初始化时并没有使用 var 声明。在调用 add()之后，sum被添加到了全局上下文，在函数退出之后依然存在，从而在后面可以访问到。</p><h3 id="注意-未经声明而初始化变量是-JavaScript-编程中一个非常常见的错误，会导致很多问题。为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。"><a href="#注意-未经声明而初始化变量是-JavaScript-编程中一个非常常见的错误，会导致很多问题。为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。" class="headerlink" title="注意 未经声明而初始化变量是 JavaScript 编程中一个非常常见的错误，会导致很多问题。为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。"></a>注意 未经声明而初始化变量是 JavaScript 编程中一个非常常见的错误，会导致很多问题。为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。</h3><p>var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line">下面是两个等价的函数：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> name;</span><br><span class="line"> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在声明之前打印变量，可以验证变量会被提升。声明的提升意味着会输出 undefined 而不是<br>Reference Error：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="2-使用-let-的块级作用域声明"><a href="#2-使用-let-的块级作用域声明" class="headerlink" title="2. 使用 let 的块级作用域声明"></a>2. 使用 let 的块级作用域声明</h2><p>ES6 新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是 JavaScript 中的新概念。块级作用域由最近的一对包含花括号{}界定。换句话说，if 块、while 块、function 块，甚至连单独的块也是 let 声明变量的作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a 没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b 没有定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// ReferenceError: c 没有定义</span></span><br><span class="line"> <span class="comment">// 这没什么可奇怪的</span></span><br><span class="line"> <span class="comment">// var 声明也会导致报错</span></span><br><span class="line"><span class="comment">// 这不是对象字面量，而是一个独立的块</span></span><br><span class="line"><span class="comment">// JavaScript 解释器会根据其中内容识别出它来</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">let</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// ReferenceError: d 没有定义</span></span><br></pre></td></tr></table></figure><p>let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">let</span> b;</span><br><span class="line"> <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: 标识符 b 已经声明过了</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部，这种情况应该避免。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// ReferenceError: j 没有定义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-使用-const-的常量声明"><a href="#3-使用-const-的常量声明" class="headerlink" title="3. 使用 const 的常量声明"></a>3. 使用 const 的常量声明</h2><p>除了 let，ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a; <span class="comment">// SyntaxError: 常量声明时没有初始化</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br><span class="line">b = <span class="number">4</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const 除了要遵循以上规则，其他方面与 let 声明是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a 没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b 没有定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// ReferenceError: c 没有定义</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">const</span> d = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// ReferenceError: d 没有定义</span></span><br></pre></td></tr></table></figure><p>const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1 = &#123;&#125;; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line">o2.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o2.name); <span class="comment">// &#x27;Jake&#x27; </span></span><br></pre></td></tr></table></figure><p>如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> o3 = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">o3.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o3.name); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><p>由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化。</p><h3 id="注意-开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用const-声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的-bug。"><a href="#注意-开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用const-声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的-bug。" class="headerlink" title="注意 开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用const 声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的 bug。"></a>注意 开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用const 声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的 bug。</h3><h2 id="4-标识符查找"><a href="#4-标识符查找" class="headerlink" title="4. 标识符查找"></a>4. 标识符查找</h2><p> 当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()); <span class="comment">// &#x27;blue&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 在这个例子中，调用函数 getColor()时会引用变量 color。为确定 color 的值会进行两步搜索。第一步，搜索 getColor()的变量对象，查找名为 color 的标识符。结果没找到，于是继续搜索下一个变量对象（来自全局上下文），然后就找到了名为 color 的标识符。因为全局变量对象上有 color的定义，所以搜索结束。对这个搜索过程而言，引用局部变量会让搜索自动停止，而不继续搜索下一级变量对象。也就是说，如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用父上下文中的同名标识符，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()); <span class="comment">// &#x27;red&#x27; </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用块级作用域声明并不会改变搜索流程，但可以给词法层级添加额外的层次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">let</span> color = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> color;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()); <span class="comment">// &#x27;green&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个修改后的例子中，getColor()内部声明了一个名为 color 的局部变量。在调用这个函数时，变量会被声明。在执行到函数返回语句时，代码引用了变量 color。于是开始在局部上下文中搜索这个标识符，结果找到了值为’green’的变量 color。因为变量已找到，搜索随即停止，所以就使用这个局部变量。这意味着函数会返回’green’。在局部变量 color 声明之后的任何代码都无法访问全局变量color，除非使用完全限定的写法 window.color</p><h3 id="注意-标识符查找并非没有代价。访问局部变量比访问全局变量要快，因为不用切换作用域。不过，JavaScript-引擎在优化标识符查找上做了很多工作，将来这个差异可能就微不足道了。"><a href="#注意-标识符查找并非没有代价。访问局部变量比访问全局变量要快，因为不用切换作用域。不过，JavaScript-引擎在优化标识符查找上做了很多工作，将来这个差异可能就微不足道了。" class="headerlink" title="注意 标识符查找并非没有代价。访问局部变量比访问全局变量要快，因为不用切换作用域。不过，JavaScript 引擎在优化标识符查找上做了很多工作，将来这个差异可能就微不足道了。"></a>注意 标识符查找并非没有代价。访问局部变量比访问全局变量要快，因为不用切换作用域。不过，JavaScript 引擎在优化标识符查找上做了很多工作，将来这个差异可能就微不足道了。</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;变量、作用域&quot;&gt;&lt;a href=&quot;#变量、作用域&quot; class=&quot;headerlink&quot; title=&quot;变量、作用域&quot;&gt;&lt;/a&gt;变量、作用域&lt;/h1&gt;&lt;p&gt;相比于其他语言，JavaScript 中的变量可谓独树一帜。正如 ECMA-262 所规定的，JavaScr</summary>
      
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="作用域" scheme="http://example.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>电商网站构图思想之其他</title>
    <link href="http://example.com/2020/10/21/%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E6%80%9D%E6%83%B32/"/>
    <id>http://example.com/2020/10/21/%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E6%80%9D%E6%83%B32/</id>
    <published>2020-10-21T05:06:43.000Z</published>
    <updated>2020-11-06T06:18:09.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="main模块制作"><a href="#main模块制作" class="headerlink" title="main模块制作"></a>main模块制作</h2><p><img src="https://s1.ax1x.com/2020/11/03/BsmHPI.png" alt="我是图片"></p><h3 id="焦点图focus"><a href="#焦点图focus" class="headerlink" title="焦点图focus"></a>焦点图focus</h3><h4 id="要知道轮播图的原理"><a href="#要知道轮播图的原理" class="headerlink" title="要知道轮播图的原理"></a>要知道轮播图的原理</h4><p><img src="https://s1.ax1x.com/2020/11/03/BsuFkd.png" alt="我是图片"><br><img src="https://s1.ax1x.com/2020/11/03/BsnHw4.png" alt="我是图片"></p><h3 id="快报模块"><a href="#快报模块" class="headerlink" title="快报模块"></a>快报模块</h3><h4 id="三个盒子-上中下-最后一个盒子做图片填充"><a href="#三个盒子-上中下-最后一个盒子做图片填充" class="headerlink" title="三个盒子  上中下 最后一个盒子做图片填充"></a>三个盒子  上中下 最后一个盒子做图片填充</h4><p><img src="https://s1.ax1x.com/2020/11/03/Bsud74.png" alt="我是图片"></p><h4 id="快报模块之上盒子篇"><a href="#快报模块之上盒子篇" class="headerlink" title="快报模块之上盒子篇"></a>快报模块之上盒子篇</h4><h5 id="上盒子分为两个盒-一个是头部-一个是身体"><a href="#上盒子分为两个盒-一个是头部-一个是身体" class="headerlink" title="上盒子分为两个盒 一个是头部 一个是身体"></a>上盒子分为两个盒 一个是头部 一个是身体</h5><h5 id="头部：左浮动-右边右浮动-记得还有伪类-after做三角"><a href="#头部：左浮动-右边右浮动-记得还有伪类-after做三角" class="headerlink" title="头部：左浮动  右边右浮动  记得还有伪类::after做三角"></a>头部：左浮动  右边右浮动  记得还有伪类::after做三角</h5><h5 id="身体：ul-gt-li-记得到时候用strong加粗"><a href="#身体：ul-gt-li-记得到时候用strong加粗" class="headerlink" title="身体：ul&gt;li 记得到时候用strong加粗"></a>身体：ul&gt;li 记得到时候用strong加粗</h5><p><img src="https://s1.ax1x.com/2020/11/03/BsK9g0.png" alt="我是图片"></p><h4 id="快报模块之中盒子篇"><a href="#快报模块之中盒子篇" class="headerlink" title="快报模块之中盒子篇"></a>快报模块之中盒子篇</h4><h5 id="形成之后ul和几个li-然后给一个宽度-盒子会自动挤到下面"><a href="#形成之后ul和几个li-然后给一个宽度-盒子会自动挤到下面" class="headerlink" title="形成之后ul和几个li  然后给一个宽度 盒子会自动挤到下面"></a>形成之后ul和几个li  然后给一个宽度 盒子会自动挤到下面</h5><p><img src="https://s1.ax1x.com/2020/11/03/BsKLxx.png" alt="我是图片"></p><h4 id="由于最低下盒子是一个图片填充"><a href="#由于最低下盒子是一个图片填充" class="headerlink" title="由于最低下盒子是一个图片填充"></a>由于最低下盒子是一个图片填充</h4><h4 id="所以只需要看自己的盒子距离底部和左边距离"><a href="#所以只需要看自己的盒子距离底部和左边距离" class="headerlink" title="所以只需要看自己的盒子距离底部和左边距离"></a>所以只需要看自己的盒子距离底部和左边距离</h4><h4 id="推荐模块制作"><a href="#推荐模块制作" class="headerlink" title="推荐模块制作"></a>推荐模块制作</h4><h5 id="第一个是一个图片填充-第二个是ul-gt-li-最后一个没有右边框"><a href="#第一个是一个图片填充-第二个是ul-gt-li-最后一个没有右边框" class="headerlink" title="第一个是一个图片填充 第二个是ul&gt;li 最后一个没有右边框"></a>第一个是一个图片填充 第二个是ul&gt;li 最后一个没有右边框</h5><p><img src="https://s1.ax1x.com/2020/11/03/BsQmX6.png" alt="我是图片"></p><h4 id="家用电器模块制作"><a href="#家用电器模块制作" class="headerlink" title="家用电器模块制作"></a>家用电器模块制作</h4><p><img src="https://s1.ax1x.com/2020/11/03/BsltPJ.png" alt="我是图片"><br><img src="https://s1.ax1x.com/2020/11/03/Bs1PJJ.png" alt="我是图片"></p><h4 id="第一个li样式红字"><a href="#第一个li样式红字" class="headerlink" title="第一个li样式红字"></a>第一个li样式红字</h4><p><img src="https://s1.ax1x.com/2020/11/03/Bs1mdO.png" alt="我是图片"></p><h4 id="tab布局样式注意"><a href="#tab布局样式注意" class="headerlink" title="tab布局样式注意"></a>tab布局样式注意</h4><p><img src="https://s1.ax1x.com/2020/11/03/Bs1Ote.png" alt="我是图片"></p><h4 id="以至于-tab-concent其实就是几个一个大盒子包含着几个小盒子"><a href="#以至于-tab-concent其实就是几个一个大盒子包含着几个小盒子" class="headerlink" title="以至于 tab-concent其实就是几个一个大盒子包含着几个小盒子"></a>以至于 tab-concent其实就是几个一个大盒子包含着几个小盒子</h4><p><img src="https://s1.ax1x.com/2020/11/03/Bs3YcR.png" alt="我是图片"></p><h2 id="注册页布局"><a href="#注册页布局" class="headerlink" title="注册页布局"></a>注册页布局</h2><h4 id="注册页面分3个部分"><a href="#注册页面分3个部分" class="headerlink" title="注册页面分3个部分"></a>注册页面分3个部分</h4><p><img src="https://s1.ax1x.com/2020/11/03/ByrfJA.png" alt="我是图片"></p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><h4 id="左浮动一个盒子-填充图片"><a href="#左浮动一个盒子-填充图片" class="headerlink" title="左浮动一个盒子  填充图片"></a>左浮动一个盒子  填充图片</h4><p><img src="https://s1.ax1x.com/2020/11/03/ByskFJ.png" alt="我是图片"></p><h3 id="registerarea布局"><a href="#registerarea布局" class="headerlink" title="registerarea布局"></a>registerarea布局</h3><h4 id="布局使用ul几个li"><a href="#布局使用ul几个li" class="headerlink" title="布局使用ul几个li"></a>布局使用ul几个li</h4><p><img src="https://s1.ax1x.com/2020/11/03/BysQTe.png" alt="我是图片"><br><img src="https://s1.ax1x.com/2020/11/03/Byyu3n.png" alt="我是图片"></p><h2 id="商品列表页"><a href="#商品列表页" class="headerlink" title="商品列表页"></a>商品列表页</h2><h3 id="1-列表页准备工作"><a href="#1-列表页准备工作" class="headerlink" title="1). 列表页准备工作"></a>1). 列表页准备工作</h3><ul><li><p>列表页面是新的页面，我们需要新建 list.html    </p></li><li><p>因为 列表页的 头部 和 底部 基本一致， 我们需要 把首页中的 头部  和 底部的  结构复制过去</p></li><li><p>头部和底部的 样式 ，列表也需要， 因此 list.html  也需要 引入   common.css  </p></li><li><p>同时 需要新的 list.css 文件   这个 样式文件，里面只写  list.html  结构里面的内容就好了</p><h3 id="2-列表页-header-和-nav-修改"><a href="#2-列表页-header-和-nav-修改" class="headerlink" title="2). 列表页 header 和  nav 修改"></a>2). 列表页 header 和  nav 修改</h3></li></ul><p><img src="https://s1.ax1x.com/2020/11/06/Bf8Roj.png" alt="我是图片"></p><ul><li>秒杀盒子 sk  定位 即可  second  kill </li><li>1 号 盒子 左侧浮动  sk_list   里面包含 ul  和  li </li><li>2 号盒子  左侧浮动   sk_con  里面 包含 ul  和  li</li></ul><h3 id="3-列表页主体盒子-sk-container"><a href="#3-列表页主体盒子-sk-container" class="headerlink" title="3). 列表页主体盒子 sk _container"></a>3). 列表页主体盒子 sk _container</h3><p>这个盒子里面包含了 所有的 列表页的所有主体内容<br><img src="https://s1.ax1x.com/2020/11/06/BfG2jK.png" alt="我是图片"></p><ul><li>1号盒子  sk _container    给宽度 1200  不要给高度 </li><li>2号盒子  sk_hd   插入图片即可  </li><li>3号盒子   sk_bd  里面包含 很多的 ul 和  li </li></ul><h3 id="4-sk-goods-布局"><a href="#4-sk-goods-布局" class="headerlink" title="4).  sk_goods  布局"></a>4).  sk_goods  布局</h3><p><img src="https://s1.ax1x.com/2020/11/06/BfGOu8.png" alt="我是图片"></p><ul><li>此li 我们命名为 sk_goods  </li><li>1号位置   有 a 包含 本图片 和下面的 标题    插入 图片即可   seckill_mod_goods_img  可以做一个 鼠标放入 图片 上滑动的效果</li><li>2号位置  标题  H5  命名为  sk_goods_title  </li><li>3号 位置 为 价格 div  命名为  sk_goods_price    </li><li>4号位置  为  div  命名为  sk_goods_progress    此处，我们 采取 代码的形式 写出 这个 导航条</li><li>5号位置  为 a  链接   命名为  sk_goods_buy   此处注意， 因为父盒子已经有左右padding   我们这里用定位合适。</li></ul><h3 id="5-分页制作-page"><a href="#5-分页制作-page" class="headerlink" title="5). 分页制作 page"></a>5). 分页制作 page</h3><p><img src="https://s1.ax1x.com/2020/11/06/BfJZE4.png" alt="我是图片"></p><ul><li>最大的盒子  我们div  命名为  page   注意里面的盒子 全部用 行内块 </li><li>1号盒子 用 span  命名为 page_num ( 页码的意思 )  里面 放 a      把a 转换为 行内块  设置样式 <ul><li>pn_prev  上一页     pn_next  下一页</li></ul></li><li>2号盒子 用 span 命名为  page_skip    ( skip 跳转 转移的意思 )    里面注意 有 input  和  button  </li></ul><h3 id="6-知识点-获得焦点元素"><a href="#6-知识点-获得焦点元素" class="headerlink" title="6). 知识点 -获得焦点元素"></a>6). 知识点 -获得焦点元素</h3><h4 id="focus-伪类-选择器用于选取获得焦点的元素-。-我们这里主要针对的是-表单元素"><a href="#focus-伪类-选择器用于选取获得焦点的元素-。-我们这里主要针对的是-表单元素" class="headerlink" title=":focus 伪类 选择器用于选取获得焦点的元素 。 我们这里主要针对的是 表单元素"></a>:focus 伪类 选择器用于选取获得焦点的元素 。 我们这里主要针对的是 表单元素</h4><h4 id="hover"><a href="#hover" class="headerlink" title=":hover"></a>:hover</h4><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.total</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这个input 获得了焦点*/</span></span><br><span class="line"><span class="selector-class">.total</span> <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;main模块制作&quot;&gt;&lt;a href=&quot;#main模块制作&quot; class=&quot;headerlink&quot; title=&quot;main模块制作&quot;&gt;&lt;/a&gt;main模块制作&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/03/BsmHP</summary>
      
    
    
    
    <category term="电商网站构图思想" scheme="http://example.com/categories/%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E6%9E%84%E5%9B%BE%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="项目" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>电商网站构图思想之公共样式</title>
    <link href="http://example.com/2020/10/20/%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E6%80%9D%E6%83%B3/"/>
    <id>http://example.com/2020/10/20/%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E6%80%9D%E6%83%B3/</id>
    <published>2020-10-20T05:06:43.000Z</published>
    <updated>2020-11-06T06:17:51.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="公共样式开始之前，就品优购网站思想来说-代码多的雅痞-但是只要思想在-所有都是浮云"><a href="#公共样式开始之前，就品优购网站思想来说-代码多的雅痞-但是只要思想在-所有都是浮云" class="headerlink" title="公共样式开始之前，就品优购网站思想来说  代码多的雅痞  但是只要思想在  所有都是浮云"></a>公共样式开始之前，就品优购网站思想来说  代码多的雅痞  但是只要思想在  所有都是浮云</h3><p><img src="https://s1.ax1x.com/2020/11/01/B0FJYQ.png" alt="我是图片"></p><hr><h3 id="我们先从头部说起网页的三大部件"><a href="#我们先从头部说起网页的三大部件" class="headerlink" title="我们先从头部说起网页的三大部件"></a>我们先从头部说起网页的三大部件</h3><p><img src="https://s1.ax1x.com/2020/11/01/B0F2lR.png" alt="我是图片"></p><h3 id="facicon-ico网页图标"><a href="#facicon-ico网页图标" class="headerlink" title="facicon.ico网页图标"></a>facicon.ico网页图标</h3><h4 id="这里需要注意的是rel-后面必须跟“shortcut-icon”"><a href="#这里需要注意的是rel-后面必须跟“shortcut-icon”" class="headerlink" title="这里需要注意的是rel  后面必须跟“shortcut icon”"></a>这里需要注意的是rel  后面必须跟“shortcut icon”</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="顶部最上面的快捷标签栏shortcut"><a href="#顶部最上面的快捷标签栏shortcut" class="headerlink" title="顶部最上面的快捷标签栏shortcut"></a>顶部最上面的快捷标签栏shortcut</h3><p><img src="https://s1.ax1x.com/2020/11/01/B0kw3d.png" alt="我是图片"></p><h4 id="左边两个盒子浮动"><a href="#左边两个盒子浮动" class="headerlink" title="左边两个盒子浮动"></a>左边两个盒子浮动</h4><p><img src="https://s1.ax1x.com/2020/11/01/B0EgpQ.png" alt="我是图片"></p><h4 id="右边成几个ul-gt-li-数字"><a href="#右边成几个ul-gt-li-数字" class="headerlink" title="右边成几个ul&gt;li*数字"></a>右边成几个ul&gt;li*数字</h4><h5 id="距离使用padding挤开"><a href="#距离使用padding挤开" class="headerlink" title="距离使用padding挤开"></a>距离使用padding挤开</h5><h5 id="使用nth：even偶数形成竖杠"><a href="#使用nth：even偶数形成竖杠" class="headerlink" title="使用nth：even偶数形成竖杠"></a>使用nth：even偶数形成竖杠</h5><p><img src="https://s1.ax1x.com/2020/11/01/B0Z1PO.png" alt="我是图片"><br><img src="https://s1.ax1x.com/2020/11/01/B0Z3GD.png" alt="我是图片"></p><h4 id="小三角通过字体图标"><a href="#小三角通过字体图标" class="headerlink" title="小三角通过字体图标"></a>小三角通过字体图标</h4><h5 id="现在需要倒三角的li加一个class"><a href="#现在需要倒三角的li加一个class" class="headerlink" title="现在需要倒三角的li加一个class"></a>现在需要倒三角的li加一个class</h5><h5 id="其次就是用伪类-after里面的content测试一下"><a href="#其次就是用伪类-after里面的content测试一下" class="headerlink" title="其次就是用伪类::after里面的content测试一下"></a>其次就是用伪类::after里面的content测试一下</h5><h5 id="最后在使用字体图标CSS样式修改就OK了"><a href="#最后在使用字体图标CSS样式修改就OK了" class="headerlink" title="最后在使用字体图标CSS样式修改就OK了"></a>最后在使用字体图标CSS样式修改就OK了</h5><p><img src="https://s1.ax1x.com/2020/11/01/B0n8RU.png" alt="我是图片"><br><img src="https://s1.ax1x.com/2020/11/01/B0nNL9.png" alt="我是图片"><br><img src="https://s1.ax1x.com/2020/11/01/B0u3TI.png" alt="我是图片"></p><hr><h3 id="header制作"><a href="#header制作" class="headerlink" title="header制作"></a>header制作</h3><p><img src="https://s1.ax1x.com/2020/11/01/B0K0gO.png" alt="我是图片"></p><h4 id="Logo-SEO优化"><a href="#Logo-SEO优化" class="headerlink" title="Logo SEO优化"></a>Logo SEO优化</h4><p><img src="https://s1.ax1x.com/2020/11/01/B0GbOf.png" alt="我是图片"></p><h4 id="搜索栏"><a href="#搜索栏" class="headerlink" title="搜索栏"></a>搜索栏</h4><h5 id="两个盒子-里面包含一个input-和一个button"><a href="#两个盒子-里面包含一个input-和一个button" class="headerlink" title="两个盒子 里面包含一个input 和一个button"></a>两个盒子 里面包含一个input 和一个button</h5><p><img src="https://s1.ax1x.com/2020/11/01/B0JJtH.png" alt="我是图片"></p><h4 id="购物车模块"><a href="#购物车模块" class="headerlink" title="购物车模块"></a>购物车模块</h4><h5 id="一个大盒子-首先给一个边框，然后中间放一个文字-利用中间文字的伪类-befor＆-after实现购物车图标和倒立三角"><a href="#一个大盒子-首先给一个边框，然后中间放一个文字-利用中间文字的伪类-befor＆-after实现购物车图标和倒立三角" class="headerlink" title="一个大盒子 首先给一个边框，然后中间放一个文字  利用中间文字的伪类::befor＆::after实现购物车图标和倒立三角"></a>一个大盒子 首先给一个边框，然后中间放一个文字  利用中间文字的伪类::befor＆::after实现购物车图标和倒立三角</h5><h5 id="然后上面的消息框用定位定上去"><a href="#然后上面的消息框用定位定上去" class="headerlink" title="然后上面的消息框用定位定上去"></a>然后上面的消息框用定位定上去</h5><p><img src="https://s1.ax1x.com/2020/11/01/B0NN9J.png" alt="我是图片"></p><hr><h3 id="nav导航制作"><a href="#nav导航制作" class="headerlink" title="nav导航制作"></a>nav导航制作</h3><h5 id="首先-画两个盒子-一个左浮动-一又浮动"><a href="#首先-画两个盒子-一个左浮动-一又浮动" class="headerlink" title="首先  画两个盒子 一个左浮动 一又浮动"></a>首先  画两个盒子 一个左浮动 一又浮动</h5><h5 id="其次-nav左浮动的盒子是一个无序列表-dt-dd"><a href="#其次-nav左浮动的盒子是一个无序列表-dt-dd" class="headerlink" title="其次  nav左浮动的盒子是一个无序列表 dt dd"></a>其次  nav左浮动的盒子是一个无序列表 dt dd</h5><h5 id="dd下面放个ul下的几个li-最后边用伪类-after完成"><a href="#dd下面放个ul下的几个li-最后边用伪类-after完成" class="headerlink" title="dd下面放个ul下的几个li  最后边用伪类::after完成"></a>dd下面放个ul下的几个li  最后边用伪类::after完成</h5><p><img src="https://s1.ax1x.com/2020/11/02/BDoPWF.png" alt="我是图片"><br><img src="https://s1.ax1x.com/2020/11/02/BDTUBR.png" alt="我是图片"><br><a href="https://imgchr.com/i/BDTv5V"><img src="https://s1.ax1x.com/2020/11/02/BDTv5V.png" alt="BDTv5V.png"></a></p><h4 id="navitems制作"><a href="#navitems制作" class="headerlink" title="navitems制作"></a>navitems制作</h4><h5 id="放一个盒子-靠右浮动-然后把li在浮动-padding撑开距离"><a href="#放一个盒子-靠右浮动-然后把li在浮动-padding撑开距离" class="headerlink" title="放一个盒子  靠右浮动 然后把li在浮动 padding撑开距离"></a>放一个盒子  靠右浮动 然后把li在浮动 padding撑开距离</h5><p><a href="https://imgchr.com/i/BD7WM4"><img src="https://s1.ax1x.com/2020/11/02/BD7WM4.png" alt="BD7WM4.png"></a></p><h3 id="footer制作"><a href="#footer制作" class="headerlink" title="footer制作"></a>footer制作</h3><h5 id="一个大盒子包含3个小盒子"><a href="#一个大盒子包含3个小盒子" class="headerlink" title="一个大盒子包含3个小盒子"></a>一个大盒子包含3个小盒子</h5><p><img src="https://s1.ax1x.com/2020/11/02/BDHuF0.png" alt="我是图片"></p><h4 id="footer-top盒子制作"><a href="#footer-top盒子制作" class="headerlink" title="footer_top盒子制作"></a>footer_top盒子制作</h4><h5 id="首先是一个ul包含四个li-其次就是给每个li放俩盒子"><a href="#首先是一个ul包含四个li-其次就是给每个li放俩盒子" class="headerlink" title="首先是一个ul包含四个li 其次就是给每个li放俩盒子"></a>首先是一个ul包含四个li 其次就是给每个li放俩盒子</h5><h5 id="左边是h5为图标-右边盒子h4是上面字体下面放一个p-然后左右浮动"><a href="#左边是h5为图标-右边盒子h4是上面字体下面放一个p-然后左右浮动" class="headerlink" title="左边是h5为图标 右边盒子h4是上面字体下面放一个p 然后左右浮动"></a>左边是h5为图标 右边盒子h4是上面字体下面放一个p 然后左右浮动</h5><p><img src="https://s1.ax1x.com/2020/11/02/BDbuBd.png" alt="我是图片"></p><p><img src="https://s1.ax1x.com/2020/11/02/BDb2DJ.png" alt="我是图片"></p><h4 id="footer-mid盒子制作"><a href="#footer-mid盒子制作" class="headerlink" title="footer_mid盒子制作"></a>footer_mid盒子制作</h4><h5 id="首先放一个dl-dl里有一个dd和dt"><a href="#首先放一个dl-dl里有一个dd和dt" class="headerlink" title="首先放一个dl  dl里有一个dd和dt"></a>首先放一个dl  dl里有一个dd和dt</h5><h5 id="然后整修饰玩样式之后-就开始复制粘贴5个-最后一个修成图片就行"><a href="#然后整修饰玩样式之后-就开始复制粘贴5个-最后一个修成图片就行" class="headerlink" title="然后整修饰玩样式之后  就开始复制粘贴5个 最后一个修成图片就行"></a>然后整修饰玩样式之后  就开始复制粘贴5个 最后一个修成图片就行</h5><p><img src="https://s1.ax1x.com/2020/11/02/BDqDZd.png" alt="我是图片"></p><h4 id="footer-bot盒子制作"><a href="#footer-bot盒子制作" class="headerlink" title="footer_bot盒子制作"></a>footer_bot盒子制作</h4><h5 id="放两个class-一上一下-最后都用css修饰text-aglin-center"><a href="#放两个class-一上一下-最后都用css修饰text-aglin-center" class="headerlink" title="放两个class  一上一下  最后都用css修饰text-aglin center"></a>放两个class  一上一下  最后都用css修饰text-aglin center</h5><p><img src="https://s1.ax1x.com/2020/11/02/BDLAyD.png" alt="我是图片"></p><h2 id="至此-公共样式已完结-接下来是分页样式"><a href="#至此-公共样式已完结-接下来是分页样式" class="headerlink" title="至此 公共样式已完结  接下来是分页样式"></a>至此 公共样式已完结  接下来是分页样式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;公共样式开始之前，就品优购网站思想来说-代码多的雅痞-但是只要思想在-所有都是浮云&quot;&gt;&lt;a href=&quot;#公共样式开始之前，就品优购网站思想来说-代码多的雅痞-但是只要思想在-所有都是浮云&quot; class=&quot;headerlink&quot; title=&quot;公共样式开始之前，就</summary>
      
    
    
    
    <category term="电商网站构图思想" scheme="http://example.com/categories/%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E6%9E%84%E5%9B%BE%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="项目" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之语句</title>
    <link href="http://example.com/2020/10/19/%E7%BA%A2%E5%AE%9D%E4%B9%A65/"/>
    <id>http://example.com/2020/10/19/%E7%BA%A2%E5%AE%9D%E4%B9%A65/</id>
    <published>2020-10-19T05:06:43.000Z</published>
    <updated>2020-11-09T12:27:11.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h4 id="ECMA-262-描述了一些语句（也称为流控制语句），而-ECMAScript-中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。"><a href="#ECMA-262-描述了一些语句（也称为流控制语句），而-ECMAScript-中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。" class="headerlink" title="ECMA-262 描述了一些语句（也称为流控制语句），而 ECMAScript 中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。"></a>ECMA-262 描述了一些语句（也称为流控制语句），而 ECMAScript 中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。</h4><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (任何表达式) statement1 </span><br><span class="line"><span class="keyword">else</span> statement2 </span><br></pre></td></tr></table></figure><h5 id="这里的条件（condition）可以是任何表达式，并且求值结果不一定是布尔值。"><a href="#这里的条件（condition）可以是任何表达式，并且求值结果不一定是布尔值。" class="headerlink" title="这里的条件（condition）可以是任何表达式，并且求值结果不一定是布尔值。"></a>这里的条件（condition）可以是任何表达式，并且求值结果不一定是布尔值。</h5><h5 id="ECMAScript-会自动调用-Boolean-函数将这个表达式的值转换为布尔值。如果条件求值为-true，则执行语句statement1；如果条件求值为-false，则执行语句-statement2。这里的语句可能是一行代码，也可能是一个代码块（即包含在一对花括号中的多行代码）。"><a href="#ECMAScript-会自动调用-Boolean-函数将这个表达式的值转换为布尔值。如果条件求值为-true，则执行语句statement1；如果条件求值为-false，则执行语句-statement2。这里的语句可能是一行代码，也可能是一个代码块（即包含在一对花括号中的多行代码）。" class="headerlink" title="ECMAScript 会自动调用 Boolean()函数将这个表达式的值转换为布尔值。如果条件求值为 true，则执行语句statement1；如果条件求值为 false，则执行语句 statement2。这里的语句可能是一行代码，也可能是一个代码块（即包含在一对花括号中的多行代码）。"></a>ECMAScript 会自动调用 Boolean()函数将这个表达式的值转换为布尔值。如果条件求值为 true，则执行语句statement1；如果条件求值为 false，则执行语句 statement2。这里的语句可能是一行代码，也可能是一个代码块（即包含在一对花括号中的多行代码）。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>)</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Greater than 25.&quot;</span>); <span class="comment">// 只有一行代码的语句</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Less than or equal to 25.&quot;</span>); <span class="comment">// 一个语句块</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="连续使用多个-if-语句"><a href="#连续使用多个-if-语句" class="headerlink" title="连续使用多个 if 语句"></a>连续使用多个 if 语句</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) statement1 <span class="keyword">else</span> <span class="keyword">if</span> (condition2) statement2 <span class="keyword">else</span> statement3 </span><br></pre></td></tr></table></figure><h2 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h2><h5 id="do-while-语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。"><a href="#do-while-语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。" class="headerlink" title="do-while 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。"></a>do-while 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.do while 循环 语法结构</span></span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="comment">// 循环体</span></span><br><span class="line">       &#125; <span class="keyword">while</span> (条件表达式)</span><br><span class="line">       <span class="comment">// 2.  执行思路 跟while不同的地方在于 do while 先执行一次循环体 在判断条件 如果条件表达式结果为真，则继续执行循环体，否则退出循环</span></span><br><span class="line">       <span class="comment">// 3. 代码验证</span></span><br><span class="line">       <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;how are you?&#x27;</span>);</span><br><span class="line">           i++;</span><br><span class="line">       &#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>)</span><br><span class="line">       <span class="comment">// 4. 我们的do while 循环体至少执行一次</span></span><br></pre></td></tr></table></figure><h5 id="在这个例子中，只要-i-小于-10，循环就会重复执行。i-从-0-开始，每次循环递增-2。"><a href="#在这个例子中，只要-i-小于-10，循环就会重复执行。i-从-0-开始，每次循环递增-2。" class="headerlink" title="在这个例子中，只要 i 小于 10，循环就会重复执行。i 从 0 开始，每次循环递增 2。"></a>在这个例子中，只要 i 小于 10，循环就会重复执行。i 从 0 开始，每次循环递增 2。</h5><h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><h2 id="while-语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，while-循环体内的代码有可能不会执行。"><a href="#while-语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，while-循环体内的代码有可能不会执行。" class="headerlink" title="while 语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，while 循环体内的代码有可能不会执行。"></a>while 语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，while 循环体内的代码有可能不会执行。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. while 循环语法结构  while 当...的时候</span></span><br><span class="line"><span class="comment">// while (条件表达式) &#123;</span></span><br><span class="line"><span class="comment">//     // 循环体</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 2. 执行思路  当条件表达式结果为true 则执行循环体 否则 退出循环</span></span><br><span class="line"><span class="comment">// 3. 代码验证</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;好啊有&#x27;</span>);</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 里面应该也有计数器 初始化变量</span></span><br><span class="line"><span class="comment">// 5. 里面应该也有操作表达式  完成计数器的更新 防止死循环</span></span><br></pre></td></tr></table></figure><h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><h5 id="for-语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式"><a href="#for-语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式" class="headerlink" title="for 语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式"></a>for 语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">##  双重for循环语句</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 双重for循环 语法结构</span></span><br><span class="line">        <span class="comment">// for (外层的初始化变量; 外层的条件表达式; 外层的操作表达式) &#123;</span></span><br><span class="line">        <span class="comment">//     for (里层的初始化变量; 里层的条件表达式; 里层的操作表达式) &#123;</span></span><br><span class="line">        <span class="comment">//         // 执行语句;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 2. 我们可以把里面的循环看做是外层循环的语句</span></span><br><span class="line">        <span class="comment">// 3. 外层循环循环一次， 里面的循环执行全部</span></span><br><span class="line">        <span class="comment">// 4. 代码验证</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;这是外层循环第&#x27;</span> + i + <span class="string">&#x27;次&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;这是里层的循环第&#x27;</span> + j + <span class="string">&#x27;次&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 九九乘法表</span></span><br><span class="line">       <span class="comment">// 一共有9行，但是每行的个数不一样，因此需要用到双重 for 循环</span></span><br><span class="line">       <span class="comment">// 外层的 for 循环控制行数 i ，循环9次 ，可以打印 9 行  </span></span><br><span class="line">       <span class="comment">// 内层的 for 循环控制每行公式  j  </span></span><br><span class="line">       <span class="comment">// 核心算法：每一行 公式的个数正好和行数一致， j &lt;= i;</span></span><br><span class="line">       <span class="comment">// 每行打印完毕，都需要重新换一行</span></span><br><span class="line">       <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123; <span class="comment">// 外层循环控制行数  </span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123; <span class="comment">// 里层循环控制每一行的个数  j &lt;= i</span></span><br><span class="line">               <span class="comment">// 1 × 2 = 2</span></span><br><span class="line">               <span class="comment">// str = str + &#x27;★&#x27;;</span></span><br><span class="line">               str += j + <span class="string">&#x27;×&#x27;</span> + i + <span class="string">&#x27;=&#x27;</span> + i * j + <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           str += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure><h2 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h2><h5 id="for-in-语句是一种严格的迭代语句，用于枚举对象中的非符号键属性"><a href="#for-in-语句是一种严格的迭代语句，用于枚举对象中的非符号键属性" class="headerlink" title="for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性"></a>for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(k); <span class="comment">// k 变量 输出  得到的是 属性名</span></span><br><span class="line">            <span class="built_in">console</span>.log(obj[k]); <span class="comment">// obj[k] 得到是 属性值</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 我们使用 for in 里面的变量 我们喜欢写 k  或者  key</span></span><br></pre></td></tr></table></figure><h5 id="ECMAScript-中对象的属性是无序的，因此-for-in-语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。"><a href="#ECMAScript-中对象的属性是无序的，因此-for-in-语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。" class="headerlink" title="ECMAScript 中对象的属性是无序的，因此 for-in 语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。"></a>ECMAScript 中对象的属性是无序的，因此 for-in 语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</h5><h5 id="如果-for-in-循环要迭代的变量是-null-或-undefined，则不执行循环体。"><a href="#如果-for-in-循环要迭代的变量是-null-或-undefined，则不执行循环体。" class="headerlink" title="如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体。"></a>如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体。</h5><h2 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for-of 语句"></a>for-of 语句</h2><h5 id="for-of-语句是一种严格的迭代语句，用于遍历可迭代对象的元素"><a href="#for-of-语句是一种严格的迭代语句，用于遍历可迭代对象的元素" class="headerlink" title="for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素"></a>for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]) &#123;</span><br><span class="line"> <span class="built_in">document</span>.write(el);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="我们使用-for-of-语句显示了一个包含-4-个元素的数组中的所有元素。循环会一直持续到将所有元素都迭代完。与-for-循环一样，这里控制语句中的-const-也不是必需的。但为了确保这个局部变量不被修改，推荐使用-const。"><a href="#我们使用-for-of-语句显示了一个包含-4-个元素的数组中的所有元素。循环会一直持续到将所有元素都迭代完。与-for-循环一样，这里控制语句中的-const-也不是必需的。但为了确保这个局部变量不被修改，推荐使用-const。" class="headerlink" title="我们使用 for-of 语句显示了一个包含 4 个元素的数组中的所有元素。循环会一直持续到将所有元素都迭代完。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用 const。"></a>我们使用 for-of 语句显示了一个包含 4 个元素的数组中的所有元素。循环会一直持续到将所有元素都迭代完。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用 const。</h5><h5 id="for-of-循环会按照可迭代对象的-next-方法产生值的顺序迭代元素。"><a href="#for-of-循环会按照可迭代对象的-next-方法产生值的顺序迭代元素。" class="headerlink" title="for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素。"></a>for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素。</h5><h2 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="在这个例子中，start-是一个标签，可以在后面通过-break-或-continue-语句引用。标签语句的典型应用场景是嵌套循环。"><a href="#在这个例子中，start-是一个标签，可以在后面通过-break-或-continue-语句引用。标签语句的典型应用场景是嵌套循环。" class="headerlink" title="在这个例子中，start 是一个标签，可以在后面通过 break 或 continue 语句引用。标签语句的典型应用场景是嵌套循环。"></a>在这个例子中，start 是一个标签，可以在后面通过 break 或 continue 语句引用。标签语句的典型应用场景是嵌套循环。</h5><h2 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h2><h5 id="break-和-continue-语句为执行循环代码提供了更严格的控制手段。"><a href="#break-和-continue-语句为执行循环代码提供了更严格的控制手段。" class="headerlink" title="break 和 continue 语句为执行循环代码提供了更严格的控制手段。"></a>break 和 continue 语句为执行循环代码提供了更严格的控制手段。</h5><h5 id="break-语句用于立即退出循环，强制执行循环后的下一条语句。"><a href="#break-语句用于立即退出循环，强制执行循环后的下一条语句。" class="headerlink" title="break 语句用于立即退出循环，强制执行循环后的下一条语句。"></a>break 语句用于立即退出循环，强制执行循环后的下一条语句。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// break 退出整个循环</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;我正在吃第&#x27;</span> + i + <span class="string">&#x27;个包子&#x27;</span>);</span><br><span class="line">           <span class="comment">//1、2</span></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="continue-语句也用于立即退出循环，但会再次从循环顶部开始执行。"><a href="#continue-语句也用于立即退出循环，但会再次从循环顶部开始执行。" class="headerlink" title="continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。"></a>continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。</h5> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// continue 关键字   退出本次（当前次的循环）  继续执行剩余次数循环</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">               <span class="keyword">continue</span>; <span class="comment">// 只要遇见 continue就退出本次循环 直接跳到 i++</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;我正在吃第&#x27;</span> + i + <span class="string">&#x27;个包子&#x27;</span>);</span><br><span class="line">            <span class="comment">//1、2、4、5</span></span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h2><h5 id="with-语句的用途是将代码作用域设置为特定的对象"><a href="#with-语句的用途是将代码作用域设置为特定的对象" class="headerlink" title="with 语句的用途是将代码作用域设置为特定的对象"></a>with 语句的用途是将代码作用域设置为特定的对象</h5> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> hostName = location.hostname;</span><br><span class="line"><span class="keyword">let</span> url = location.href;</span><br></pre></td></tr></table></figure><h5 id="上面代码中的每一行都用到了-location-对象。如果使用-with-语句，就可以少写一些代码："><a href="#上面代码中的每一行都用到了-location-对象。如果使用-with-语句，就可以少写一些代码：" class="headerlink" title="上面代码中的每一行都用到了 location 对象。如果使用 with 语句，就可以少写一些代码："></a>上面代码中的每一行都用到了 location 对象。如果使用 with 语句，就可以少写一些代码：</h5> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(location) &#123;</span><br><span class="line"> <span class="keyword">let</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">let</span> hostName = hostname;</span><br><span class="line"> <span class="keyword">let</span> url = href;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="警告-由于-with-语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用-with语句"><a href="#警告-由于-with-语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用-with语句" class="headerlink" title="警告 由于 with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 with语句"></a>警告 由于 with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 with语句</h3><h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><h5 id="switch-语句是与-if-语句紧密相关的一种流控制语句，从其他语言借鉴而来。ECMAScript中-switch语句跟-C-语言中-switch-语句的语法非常相似"><a href="#switch-语句是与-if-语句紧密相关的一种流控制语句，从其他语言借鉴而来。ECMAScript中-switch语句跟-C-语言中-switch-语句的语法非常相似" class="headerlink" title="switch 语句是与 if 语句紧密相关的一种流控制语句，从其他语言借鉴而来。ECMAScript中 switch语句跟 C 语言中 switch 语句的语法非常相似"></a>switch 语句是与 if 语句紧密相关的一种流控制语句，从其他语言借鉴而来。ECMAScript中 switch语句跟 C 语言中 switch 语句的语法非常相似</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">           <span class="keyword">case</span> value1:</span><br><span class="line">                执行语句<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> value2:</span><br><span class="line">               执行语句<span class="number">2</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">               ...</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   执行最后的语句;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="注意-switch-语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串”10”不等于数值-10）。"><a href="#注意-switch-语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串”10”不等于数值-10）。" class="headerlink" title="注意 switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串”10”不等于数值 10）。"></a>注意 switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串”10”不等于数值 10）。</h3><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h5 id="函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript-中的函数使用-function-关键字声明，后跟一组参数，然后是函数体。"><a href="#函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript-中的函数使用-function-关键字声明，后跟一组参数，然后是函数体。" class="headerlink" title="函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript 中的函数使用 function 关键字声明，后跟一组参数，然后是函数体。"></a>函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript 中的函数使用 function 关键字声明，后跟一组参数，然后是函数体。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//声明一个函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">myfun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             alert(<span class="string">&quot;我是一个函数&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//函数的调用</span></span><br><span class="line">         myfun();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个带有参数的函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sum = (num1 + num2);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(add(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(add(<span class="number">99</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(add(<span class="number">-15</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure><h3 id="注意-最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。"><a href="#注意-最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。" class="headerlink" title="注意 最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。"></a>注意 最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。</h3><h4 id="利用函数冒泡排序"><a href="#利用函数冒泡排序" class="headerlink" title="利用函数冒泡排序"></a>利用函数冒泡排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zeroone</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                       <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">                       arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                       arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> arr;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> arr1 = zeroone([<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>]);</span><br><span class="line">       <span class="built_in">console</span>.log(arr1);</span><br><span class="line">       <span class="keyword">var</span> arr2 = zeroone([<span class="number">11</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">999</span>]);</span><br><span class="line">       <span class="built_in">console</span>.log(arr2);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h1&gt;&lt;h4 id=&quot;ECMA-262-描述了一些语句（也称为流控制语句），而-ECMAScript-中的大部分语法都体现在语句中。语句通常使用一或多个</summary>
      
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="语句" scheme="http://example.com/tags/%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之操作符</title>
    <link href="http://example.com/2020/10/16/%E7%BA%A2%E5%AE%9D%E4%B9%A64/"/>
    <id>http://example.com/2020/10/16/%E7%BA%A2%E5%AE%9D%E4%B9%A64/</id>
    <published>2020-10-16T05:06:43.000Z</published>
    <updated>2020-11-09T12:27:20.336Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ECMA-262-描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript-中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用-valueOf-和-或-toString-方法来取得可以计算的值"><a href="#ECMA-262-描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript-中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用-valueOf-和-或-toString-方法来取得可以计算的值" class="headerlink" title="ECMA-262 描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值"></a>ECMA-262 描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值</h4><h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><h4 id="只操作一个值的操作符叫一元操作符（unary-operator）。一元操作符是-ECMAScript中最简单的操作符。"><a href="#只操作一个值的操作符叫一元操作符（unary-operator）。一元操作符是-ECMAScript中最简单的操作符。" class="headerlink" title="只操作一个值的操作符叫一元操作符（unary operator）。一元操作符是 ECMAScript中最简单的操作符。"></a>只操作一个值的操作符叫一元操作符（unary operator）。一元操作符是 ECMAScript中最简单的操作符。</h4><h3 id="1-递增-递减操作符"><a href="#1-递增-递减操作符" class="headerlink" title="1. 递增/递减操作符"></a>1. 递增/递减操作符</h3><h5 id="递增和递减操作符直接照搬自-C-语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。前缀递增操作符会给数值加-1，把两个加号（-）放到变量前头即可"><a href="#递增和递减操作符直接照搬自-C-语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。前缀递增操作符会给数值加-1，把两个加号（-）放到变量前头即可" class="headerlink" title="递增和递减操作符直接照搬自 C 语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。前缀递增操作符会给数值加 1，把两个加号（++）放到变量前头即可"></a>递增和递减操作符直接照搬自 C 语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。前缀递增操作符会给数值加 1，把两个加号（++）放到变量前头即可</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">：<span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">++age; </span><br></pre></td></tr></table></figure><h5 id="在这个例子中，前缀递增操作符把-age-的值变成了-30（给之前的值-29-加-1）。因此，它实际上等于如下表达式："><a href="#在这个例子中，前缀递增操作符把-age-的值变成了-30（给之前的值-29-加-1）。因此，它实际上等于如下表达式：" class="headerlink" title="在这个例子中，前缀递增操作符把 age 的值变成了 30（给之前的值 29 加 1）。因此，它实际上等于如下表达式："></a>在这个例子中，前缀递增操作符把 age 的值变成了 30（给之前的值 29 加 1）。因此，它实际上等于如下表达式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">age = age + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="前缀递减操作符也类似，只不过是从一个数值减-1。使用前缀递减操作符，只要把两个减号（–）放到变量前头即可："><a href="#前缀递减操作符也类似，只不过是从一个数值减-1。使用前缀递减操作符，只要把两个减号（–）放到变量前头即可：" class="headerlink" title="前缀递减操作符也类似，只不过是从一个数值减 1。使用前缀递减操作符，只要把两个减号（–）放到变量前头即可："></a>前缀递减操作符也类似，只不过是从一个数值减 1。使用前缀递减操作符，只要把两个减号（–）放到变量前头即可：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">--age;</span><br></pre></td></tr></table></figure><h5 id="执行操作后，变量-age-的值变成了-28（从-29-减-1）。"><a href="#执行操作后，变量-age-的值变成了-28（从-29-减-1）。" class="headerlink" title="执行操作后，变量 age 的值变成了 28（从 29 减 1）。"></a>执行操作后，变量 age 的值变成了 28（从 29 减 1）。</h5><h5 id="无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有副作用。）请看下面的例子："><a href="#无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有副作用。）请看下面的例子：" class="headerlink" title="无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有副作用。）请看下面的例子："></a>无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有副作用。）请看下面的例子：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">let</span> anotherAge = --age + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 28</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherAge); <span class="comment">// 30 </span></span><br></pre></td></tr></table></figure><h5 id="在这个例子中，变量-anotherAge-以-age-减-1-后的值再加-2-进行初始化。因为递减操作先发生，所以-age-的值先变成-28，然后再加-2，结果是-30。前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如："><a href="#在这个例子中，变量-anotherAge-以-age-减-1-后的值再加-2-进行初始化。因为递减操作先发生，所以-age-的值先变成-28，然后再加-2，结果是-30。前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如：" class="headerlink" title="在这个例子中，变量 anotherAge 以 age 减 1 后的值再加 2 进行初始化。因为递减操作先发生，所以 age 的值先变成 28，然后再加 2，结果是 30。前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如："></a>在这个例子中，变量 anotherAge 以 age 减 1 后的值再加 2 进行初始化。因为递减操作先发生，所以 age 的值先变成 28，然后再加 2，结果是 30。前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = --num1 + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(num3); <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">console</span>.log(num4); <span class="comment">// 21 </span></span><br></pre></td></tr></table></figure><h5 id="这里，num3-等于-21-是因为-num1-先减-1-之后才加-num2。变量-num4-也是-21，那是因为加法使用的也是递减后的值。"><a href="#这里，num3-等于-21-是因为-num1-先减-1-之后才加-num2。变量-num4-也是-21，那是因为加法使用的也是递减后的值。" class="headerlink" title="这里，num3 等于 21 是因为 num1 先减 1 之后才加 num2。变量 num4 也是 21，那是因为加法使用的也是递减后的值。"></a>这里，num3 等于 21 是因为 num1 先减 1 之后才加 num2。变量 num4 也是 21，那是因为加法使用的也是递减后的值。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">age++; </span><br></pre></td></tr></table></figure><h5 id="把递增操作符放到变量后面不会改变语句执行的结果，因为递增是唯一的操作。可是，在跟其他操作混合时，差异就会变明显，比如："><a href="#把递增操作符放到变量后面不会改变语句执行的结果，因为递增是唯一的操作。可是，在跟其他操作混合时，差异就会变明显，比如：" class="headerlink" title="把递增操作符放到变量后面不会改变语句执行的结果，因为递增是唯一的操作。可是，在跟其他操作混合时，差异就会变明显，比如："></a>把递增操作符放到变量后面不会改变语句执行的结果，因为递增是唯一的操作。可是，在跟其他操作混合时，差异就会变明显，比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = num1-- + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2; </span><br><span class="line"><span class="built_in">console</span>.log(num3); <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(num4); <span class="comment">// 21 </span></span><br></pre></td></tr></table></figure><h5 id="这个例子跟前面的那个一样，只是把前缀递减改成了后缀递减，区别很明显。在使用前缀版的例子中，num3-和-num4-的值都是-21。而在这个例子中，num3-的值是-22，num4-的值是-21。这里的不同之处在于，计算-num3-时使用的是-num1-的原始值（2），而计算-num4-时使用的是-num1-递减后的值"><a href="#这个例子跟前面的那个一样，只是把前缀递减改成了后缀递减，区别很明显。在使用前缀版的例子中，num3-和-num4-的值都是-21。而在这个例子中，num3-的值是-22，num4-的值是-21。这里的不同之处在于，计算-num3-时使用的是-num1-的原始值（2），而计算-num4-时使用的是-num1-递减后的值" class="headerlink" title="这个例子跟前面的那个一样，只是把前缀递减改成了后缀递减，区别很明显。在使用前缀版的例子中，num3 和 num4 的值都是 21。而在这个例子中，num3 的值是 22，num4 的值是 21。这里的不同之处在于，计算 num3 时使用的是 num1 的原始值（2），而计算 num4 时使用的是 num1 递减后的值"></a>这个例子跟前面的那个一样，只是把前缀递减改成了后缀递减，区别很明显。在使用前缀版的例子中，num3 和 num4 的值都是 21。而在这个例子中，num3 的值是 22，num4 的值是 21。这里的不同之处在于，计算 num3 时使用的是 num1 的原始值（2），而计算 num4 时使用的是 num1 递减后的值</h5><h4 id="这-4-个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。"><a href="#这-4-个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。" class="headerlink" title="这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。"></a>这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。</h4><ol><li>对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。</li><li>对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成<br>数值。</li><li>对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。</li><li>对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。</li><li>对于浮点值，加 1 或减 1。</li><li>如果是对象，则调用其（第 5 章会详细介绍的）valueOf()方法取得可以操作的值。对得到的<br>值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成<br>数值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> valueOf() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1++; <span class="comment">// 值变成数值 3</span></span><br><span class="line">s2++; <span class="comment">// 值变成 NaN</span></span><br><span class="line">b++; <span class="comment">// 值变成数值 1</span></span><br><span class="line">f--; <span class="comment">// 值变成 0.10000000000000009（因为浮点数不精确）</span></span><br><span class="line">o--; <span class="comment">// 值变成-2 </span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-一元加和减"><a href="#2-一元加和减" class="headerlink" title="2. 一元加和减"></a>2. 一元加和减</h3><h5 id="一元加和减操作符对大多数开发者来说并不陌生，它们在-ECMAScript-中跟在高中数学中的用途一样。一元加由一个加号（-）表示，放在变量前头，对数值没有任何影响："><a href="#一元加和减操作符对大多数开发者来说并不陌生，它们在-ECMAScript-中跟在高中数学中的用途一样。一元加由一个加号（-）表示，放在变量前头，对数值没有任何影响：" class="headerlink" title="一元加和减操作符对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响："></a>一元加和减操作符对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> valueOf() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = +s1; <span class="comment">// 值变成数值 1</span></span><br><span class="line">s2 = +s2; <span class="comment">// 值变成数值 1.1</span></span><br><span class="line">s3 = +s3; <span class="comment">// 值变成 NaN</span></span><br><span class="line">b = +b; <span class="comment">// 值变成数值 0</span></span><br><span class="line">f = +f; <span class="comment">// 不变，还是 1.1</span></span><br><span class="line">o = +o; <span class="comment">// 值变成数值-1 </span></span><br></pre></td></tr></table></figure><h5 id="对数值使用一元减会将其变成相应的负值（如上面的例子所示）。在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值："><a href="#对数值使用一元减会将其变成相应的负值（如上面的例子所示）。在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值：" class="headerlink" title="对数值使用一元减会将其变成相应的负值（如上面的例子所示）。在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值："></a>对数值使用一元减会将其变成相应的负值（如上面的例子所示）。在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> valueOf() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = -s1; <span class="comment">// 值变成数值-1</span></span><br><span class="line">s2 = -s2; <span class="comment">// 值变成数值-1.1</span></span><br><span class="line">s3 = -s3; <span class="comment">// 值变成 NaN</span></span><br><span class="line">b = -b; <span class="comment">// 值变成数值 0</span></span><br><span class="line">f = -f; <span class="comment">// 变成-1.1</span></span><br><span class="line">o = -o; <span class="comment">// 值变成数值 1 </span></span><br></pre></td></tr></table></figure><h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><h5 id="对于编程语言来说，布尔操作符跟相等操作符几乎同样重要。如果没有能力测试两个值的关系，那么像-if-else-和循环这样的语句也没什么用了。布尔操作符一共有-3-个：逻辑非、逻辑与和逻辑或。"><a href="#对于编程语言来说，布尔操作符跟相等操作符几乎同样重要。如果没有能力测试两个值的关系，那么像-if-else-和循环这样的语句也没什么用了。布尔操作符一共有-3-个：逻辑非、逻辑与和逻辑或。" class="headerlink" title="对于编程语言来说，布尔操作符跟相等操作符几乎同样重要。如果没有能力测试两个值的关系，那么像 if-else 和循环这样的语句也没什么用了。布尔操作符一共有 3 个：逻辑非、逻辑与和逻辑或。"></a>对于编程语言来说，布尔操作符跟相等操作符几乎同样重要。如果没有能力测试两个值的关系，那么像 if-else 和循环这样的语句也没什么用了。布尔操作符一共有 3 个：逻辑非、逻辑与和逻辑或。</h5><h4 id="1-逻辑非"><a href="#1-逻辑非" class="headerlink" title="1. 逻辑非"></a>1. 逻辑非</h4><h5 id="逻辑非操作符由一个叹号（-）表示，可应用给-ECMAScript-中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。"><a href="#逻辑非操作符由一个叹号（-）表示，可应用给-ECMAScript-中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。" class="headerlink" title="逻辑非操作符由一个叹号（!）表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。"></a>逻辑非操作符由一个叹号（!）表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。</h5><h4 id="2-逻辑与"><a href="#2-逻辑与" class="headerlink" title="2. 逻辑与"></a>2. 逻辑与</h4><h5 id="逻辑与操作逻辑与操作符由两个和号（-amp-amp-）表示，应用到两个值，逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是-false，那么无论第二个操作数是什么值，结果也不可能等于-true。"><a href="#逻辑与操作逻辑与操作符由两个和号（-amp-amp-）表示，应用到两个值，逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是-false，那么无论第二个操作数是什么值，结果也不可能等于-true。" class="headerlink" title="逻辑与操作逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值，逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结果也不可能等于 true。"></a>逻辑与操作逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值，逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结果也不可能等于 true。</h5><h4 id="3-逻辑或"><a href="#3-逻辑或" class="headerlink" title="3. 逻辑或"></a>3. 逻辑或</h4><h5 id="逻辑或操作符由两个管道符（-）表示，与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。"><a href="#逻辑或操作符由两个管道符（-）表示，与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。" class="headerlink" title="逻辑或操作符由两个管道符（||）表示，与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。"></a>逻辑或操作符由两个管道符（||）表示，与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。</h5><h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><h4 id="1-乘法操作符"><a href="#1-乘法操作符" class="headerlink" title="1. 乘法操作符"></a>1. 乘法操作符</h4><h5 id="乘法操作符由一个星号（-）表示，可以用于计算两个数值的乘积。其语法类似于-C-语言，比如："><a href="#乘法操作符由一个星号（-）表示，可以用于计算两个数值的乘积。其语法类似于-C-语言，比如：" class="headerlink" title="乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积。其语法类似于 C 语言，比如："></a>乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积。其语法类似于 C 语言，比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">34</span> * <span class="number">56</span>; </span><br></pre></td></tr></table></figure><h4 id="2-除法操作符"><a href="#2-除法操作符" class="headerlink" title="2. 除法操作符"></a>2. 除法操作符</h4><h5 id="除法操作符由一个斜杠（-）表示，用于计算第一个操作数除以第二个操作数的商，比如："><a href="#除法操作符由一个斜杠（-）表示，用于计算第一个操作数除以第二个操作数的商，比如：" class="headerlink" title="除法操作符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商，比如："></a>除法操作符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商，比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">66</span> / <span class="number">11</span>; </span><br></pre></td></tr></table></figure><h4 id="取模操作符"><a href="#取模操作符" class="headerlink" title="取模操作符"></a>取模操作符</h4><h5 id="取模（余数）操作符由一个百分比符号（-）表示，比如："><a href="#取模（余数）操作符由一个百分比符号（-）表示，比如：" class="headerlink" title="取模（余数）操作符由一个百分比符号（%）表示，比如："></a>取模（余数）操作符由一个百分比符号（%）表示，比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">26</span> % <span class="number">5</span>; <span class="comment">// 等于 1</span></span><br></pre></td></tr></table></figure><h4 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h4><h5 id="ECMAScript-7-新增了指数操作符，Math-pow-现在有了自己的操作符-，结果是一样的："><a href="#ECMAScript-7-新增了指数操作符，Math-pow-现在有了自己的操作符-，结果是一样的：" class="headerlink" title="ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**，结果是一样的："></a>ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**，结果是一样的：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> ** <span class="number">2</span>); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">16</span>, <span class="number">0.5</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">16</span>** <span class="number">0.5</span>); <span class="comment">// 4 </span></span><br></pre></td></tr></table></figure><h5 id="不仅如此，指数操作符也有自己的指数赋值操作符-，该操作符执行指数运算和结果的赋值操作："><a href="#不仅如此，指数操作符也有自己的指数赋值操作符-，该操作符执行指数运算和结果的赋值操作：" class="headerlink" title="不仅如此，指数操作符也有自己的指数赋值操作符**=，该操作符执行指数运算和结果的赋值操作："></a>不仅如此，指数操作符也有自己的指数赋值操作符**=，该操作符执行指数运算和结果的赋值操作：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>;</span><br><span class="line">squared **= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(squared); <span class="comment">// 9 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sqrt = <span class="number">16</span>;</span><br><span class="line">sqrt **= <span class="number">0.5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sqrt); <span class="comment">// 4 </span></span><br></pre></td></tr></table></figure><h4 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h4><h5 id="加法操作符（-）用于求两个数的和，比如："><a href="#加法操作符（-）用于求两个数的和，比如：" class="headerlink" title="加法操作符（+）用于求两个数的和，比如："></a>加法操作符（+）用于求两个数的和，比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">1</span> + <span class="number">2</span>; </span><br></pre></td></tr></table></figure><h4 id="减法操作符"><a href="#减法操作符" class="headerlink" title="减法操作符"></a>减法操作符</h4><h5 id="减法操作符（-）也是使用很频繁的一种操作符，比如："><a href="#减法操作符（-）也是使用很频繁的一种操作符，比如：" class="headerlink" title="减法操作符（-）也是使用很频繁的一种操作符，比如："></a>减法操作符（-）也是使用很频繁的一种操作符，比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">2</span> - <span class="number">1</span>; </span><br></pre></td></tr></table></figure><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><h5 id="关系操作符执行比较两个值的操作，包括小于（-lt-）、大于（-gt-）、小于等于（-lt-）和大于等于（-gt-），用法跟数学课上学的一样。这几个操作符都返回布尔值"><a href="#关系操作符执行比较两个值的操作，包括小于（-lt-）、大于（-gt-）、小于等于（-lt-）和大于等于（-gt-），用法跟数学课上学的一样。这几个操作符都返回布尔值" class="headerlink" title="关系操作符执行比较两个值的操作，包括小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=），用法跟数学课上学的一样。这几个操作符都返回布尔值"></a>关系操作符执行比较两个值的操作，包括小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=），用法跟数学课上学的一样。这几个操作符都返回布尔值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> &gt; <span class="number">3</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> &lt; <span class="number">3</span>; <span class="comment">// false </span></span><br></pre></td></tr></table></figure><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><h4 id="1-等于和不等于"><a href="#1-等于和不等于" class="headerlink" title="1. 等于和不等于"></a>1. 等于和不等于</h4><h5 id="ECMAScript-中的等于操作符用两个等于号（-）表示，如果操作数相等，则会返回-true。不等于操作符用叹号和等于号（-）表示，如果两个操作数不相等，则会返回-true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。"><a href="#ECMAScript-中的等于操作符用两个等于号（-）表示，如果操作数相等，则会返回-true。不等于操作符用叹号和等于号（-）表示，如果两个操作数不相等，则会返回-true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。" class="headerlink" title="ECMAScript 中的等于操作符用两个等于号（==）表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号（!=）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。"></a>ECMAScript 中的等于操作符用两个等于号（==）表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号（!=）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。</h5><h4 id="2-全等和不全等"><a href="#2-全等和不全等" class="headerlink" title="2. 全等和不全等"></a>2. 全等和不全等</h4><h5 id="全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由-3-个等于号（-）表示，只有两个操作数在不转换的前提下相等才返回-true，"><a href="#全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由-3-个等于号（-）表示，只有两个操作数在不转换的前提下相等才返回-true，" class="headerlink" title="全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 true，"></a>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 true，</h5><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><h5 id="条件操作符是-ECMAScript-中用途最为广泛的操作符之一，语法跟-Java-中一样："><a href="#条件操作符是-ECMAScript-中用途最为广泛的操作符之一，语法跟-Java-中一样：" class="headerlink" title="条件操作符是 ECMAScript 中用途最为广泛的操作符之一，语法跟 Java 中一样："></a>条件操作符是 ECMAScript 中用途最为广泛的操作符之一，语法跟 Java 中一样：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = boolean_expression ? true_value : false_value;</span><br></pre></td></tr></table></figure><h5 id="上面的代码执行了条件赋值操作，即根据条件表达式-boolean-expression-的值决定将哪个值赋"><a href="#上面的代码执行了条件赋值操作，即根据条件表达式-boolean-expression-的值决定将哪个值赋" class="headerlink" title="上面的代码执行了条件赋值操作，即根据条件表达式 boolean_expression 的值决定将哪个值赋"></a>上面的代码执行了条件赋值操作，即根据条件表达式 boolean_expression 的值决定将哪个值赋</h5><h5 id="给变量-variable-。如果-boolean-expression-是-true-，则赋值-true-value-；如果"><a href="#给变量-variable-。如果-boolean-expression-是-true-，则赋值-true-value-；如果" class="headerlink" title="给变量 variable 。如果 boolean_expression 是 true ，则赋值 true_value ；如果"></a>给变量 variable 。如果 boolean_expression 是 true ，则赋值 true_value ；如果</h5><h5 id="boolean-expression-是-false，则赋值-false-value。比如："><a href="#boolean-expression-是-false，则赋值-false-value。比如：" class="headerlink" title="boolean_expression 是 false，则赋值 false_value。比如："></a>boolean_expression 是 false，则赋值 false_value。比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = (num1 &gt; num2) ? num1 : num2;</span><br></pre></td></tr></table></figure><h5 id="在这个例子中，max-将被赋予一个最大值。这个表达式的意思是，如果-num1-大于-num2（条件表达式为-true），则将-num1-赋给-max。否则，将-num2-赋给-max。"><a href="#在这个例子中，max-将被赋予一个最大值。这个表达式的意思是，如果-num1-大于-num2（条件表达式为-true），则将-num1-赋给-max。否则，将-num2-赋给-max。" class="headerlink" title="在这个例子中，max 将被赋予一个最大值。这个表达式的意思是，如果 num1 大于 num2（条件表达式为 true），则将 num1 赋给 max。否则，将 num2 赋给 max。"></a>在这个例子中，max 将被赋予一个最大值。这个表达式的意思是，如果 num1 大于 num2（条件表达式为 true），则将 num1 赋给 max。否则，将 num2 赋给 max。</h5><h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><h4 id="简单赋值用等于号（-）表示，将右手边的值赋给左手边的变量，如下所示："><a href="#简单赋值用等于号（-）表示，将右手边的值赋给左手边的变量，如下所示：" class="headerlink" title="简单赋值用等于号（=）表示，将右手边的值赋给左手边的变量，如下所示："></a>简单赋值用等于号（=）表示，将右手边的值赋给左手边的变量，如下所示：</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="每个数学操作符以及其他一些操作符都有对应的复合赋值操作符："><a href="#每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：" class="headerlink" title="每个数学操作符以及其他一些操作符都有对应的复合赋值操作符："></a>每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：</h4><ol><li><p>乘后赋值（*=）</p></li><li><p>除后赋值（/=）</p></li><li><p>取模后赋值（%=）</p></li><li><p>加后赋值（+=）</p></li><li><p>减后赋值（-=）</p></li><li><p>左移后赋值（&lt;&lt;=）</p></li><li><p>右移后赋值（&gt;&gt;=）</p></li><li><p>无符号右移后赋值（&gt;&gt;&gt;=）</p><h4 id="这些操作符仅仅是简写语法，使用它们不会提升性能。"><a href="#这些操作符仅仅是简写语法，使用它们不会提升性能。" class="headerlink" title="这些操作符仅仅是简写语法，使用它们不会提升性能。"></a>这些操作符仅仅是简写语法，使用它们不会提升性能。</h4><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><h4 id="逗号操作符可以用来在一条语句中执行多个操作，"><a href="#逗号操作符可以用来在一条语句中执行多个操作，" class="headerlink" title="逗号操作符可以用来在一条语句中执行多个操作，"></a>逗号操作符可以用来在一条语句中执行多个操作，</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>; </span><br></pre></td></tr></table></figure><h5 id="在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值"><a href="#在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值" class="headerlink" title="在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值"></a>在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">// num 的值为 0 </span></span><br></pre></td></tr></table></figure><h5 id="在这个例子中，num-将被赋值为-0，因为-0-是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在。"><a href="#在这个例子中，num-将被赋值为-0，因为-0-是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在。" class="headerlink" title="在这个例子中，num 将被赋值为 0，因为 0 是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在。"></a>在这个例子中，num 将被赋值为 0，因为 0 是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在。</h5></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;ECMA-262-描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript-中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用-valu</summary>
      
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="操作符" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之数据类型</title>
    <link href="http://example.com/2020/10/15/%E7%BA%A2%E5%AE%9D%E4%B9%A63/"/>
    <id>http://example.com/2020/10/15/%E7%BA%A2%E5%AE%9D%E4%B9%A63/</id>
    <published>2020-10-15T05:06:43.000Z</published>
    <updated>2020-11-09T12:47:54.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h5 id="ECMAScript-有-6-种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String-和-Symbol。Symbol（符号）是-ECMAScript-6-新增的。还有一种复杂数据类型叫-Object（对象）。Object-是一种无序名值对的集合。因为在-ECMAScript-中不能定义自己的数据类型，所有值都可以用上述-7-种数据类型之一来表示。只有-7-种数据类型似乎不足以表示全部数据。但-ECMAScript-的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。"><a href="#ECMAScript-有-6-种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String-和-Symbol。Symbol（符号）是-ECMAScript-6-新增的。还有一种复杂数据类型叫-Object（对象）。Object-是一种无序名值对的集合。因为在-ECMAScript-中不能定义自己的数据类型，所有值都可以用上述-7-种数据类型之一来表示。只有-7-种数据类型似乎不足以表示全部数据。但-ECMAScript-的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。" class="headerlink" title="ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。只有 7 种数据类型似乎不足以表示全部数据。但 ECMAScript 的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。"></a>ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。只有 7 种数据类型似乎不足以表示全部数据。但 ECMAScript 的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。</h5><h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p>因为 ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof操作符就是为此而生的。对一个值使用 typeof 操作符会返回下列字符串之一：</p><ul><li>“undefined”表示值未定义；</li><li>“boolean”表示值为布尔值；</li><li>“string”表示值为字符串；</li><li>“number”表示值为数值；</li><li>“object”表示值为对象（而不是函数）或 null；</li><li>“function”表示值为函数；</li><li>“symbol”表示值为符号。<br>下面是使用 typeof 操作符的例子：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(message)); <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">95</span>); <span class="comment">// &quot;number&quot; </span></span><br></pre></td></tr></table></figure>我们把一个变量（message）和一个数值字面量传给了 typeof 操作符。注意，因为 typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。</li></ul><h4 id="注意，因为-typeof-是一个操作符而不是函数，所以不需要参数（但可以使用参数）。"><a href="#注意，因为-typeof-是一个操作符而不是函数，所以不需要参数（但可以使用参数）。" class="headerlink" title="注意，因为 typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。"></a>注意，因为 typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。</h4><h4 id="注意-严格来讲，函数在-ECMAScript-中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过-typeof-操作符来区分函数和其他对象。"><a href="#注意-严格来讲，函数在-ECMAScript-中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过-typeof-操作符来区分函数和其他对象。" class="headerlink" title="注意 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。"></a>注意 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。</h4><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p>Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="built_in">console</span>.log(message == <span class="literal">undefined</span>); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">let</span> message = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message == <span class="literal">undefined</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>这里，变量 message 显式地以 undefined 来初始化。但这是不必要的，因为默认情况下，任何未经初始化的变量都会取得 undefined 值。<br>注意，包含 undefined 值的变量跟未定义变量是有区别的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为 undefined</span></span><br><span class="line"><span class="comment">// 确保没有声明过这个变量</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>第一个 console.log 会指出变量 message 的值，即”undefined”。而第二个console.log 要输出一个未声明的变量 age 的值，因此会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用 typeof。（对未声明的变量调用 delete 也不会报错，但这个操作没什么用，实际上在严格模式下会抛出错误。）<br>在对未初始化的变量调用 typeof 时，返回的结果是”undefined”，但对未声明的变量调用它时，返回的结果还是”undefined”，这就有点让人看不懂了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为 undefined</span></span><br><span class="line"><span class="comment">// 确保没有声明过这个变量</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age); <span class="comment">// &quot;undefined</span></span><br></pre></td></tr></table></figure><p>无论是声明还是未声明，typeof 返回的都是字符串”undefined”。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。<br>undefined 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是 undefined 这个字面值，而不仅仅是假值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为 undefined</span></span><br><span class="line"><span class="comment">// age 没有声明</span></span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line"> <span class="comment">// 这个块不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!message) &#123;</span><br><span class="line"> <span class="comment">// 这个块会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (age) &#123;</span><br><span class="line"> <span class="comment">// 这里会报错</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="注意-即使未初始化的变量会被自动赋予-undefined-值，但我们仍然建议在声明变量的同时进行初始化。这样，当-typeof-返回”undefined”时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。"><a href="#注意-即使未初始化的变量会被自动赋予-undefined-值，但我们仍然建议在声明变量的同时进行初始化。这样，当-typeof-返回”undefined”时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。" class="headerlink" title="注意 即使未初始化的变量会被自动赋予 undefined 值，但我们仍然建议在声明变量的同时进行初始化。这样，当 typeof 返回”undefined”时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。"></a>注意 即使未初始化的变量会被自动赋予 undefined 值，但我们仍然建议在声明变量的同时进行初始化。这样，当 typeof 返回”undefined”时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</h4><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p>Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> car); <span class="comment">// &quot;object&quot; </span></span><br></pre></td></tr></table></figure><p>undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>用等于操作符（==）比较 null 和 undefined 始终返回 true。但要注意，这个操作符会为了比较而转换它的操作数</p><p>即使 null 和 undefined 有关系，它们的用途也是完全不一样的。<br>null 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是 null 这个字面值，而不仅仅是假值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line"> <span class="comment">// 这个块不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!message) &#123;</span><br><span class="line"> <span class="comment">// 这个块会执行</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (age) &#123;</span><br><span class="line"> <span class="comment">// 这个块不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!age) &#123;</span><br><span class="line"> <span class="comment">// 这个块会执行</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>Boolean（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true 和 false。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。下面是给变量赋布尔值的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> lost = <span class="literal">false</span>; </span><br></pre></td></tr></table></figure><p>注意，布尔值字面量 true 和 false 是区分大小写的，因此 True 和 False（及其他大小混写形式）是有效的标识符，但不是布尔值。</p><p>虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> messageAsBoolean = <span class="built_in">Boolean</span>(message); </span><br></pre></td></tr></table></figure><p>字符串 message 会被转换为布尔值并保存在变量 messageAsBoolean 中。Boolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为 true或 false 的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则。</p><p>理解以上转换非常重要，因为像 if 等流控制语句会自动执行其他类型值到布尔值的转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Value is true&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在这个例子中，console.log 会输出字符串”Value is true”，因为字符串 message 会被自动转换为等价的布尔值 true。由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。错误地使用对象而不是布尔值会明显改变应用程序的执行流。</p><table><thead><tr><th align="center">数据类型</th><th align="center">转换为 true 的值</th><th align="center">转换为 false 的值</th></tr></thead><tbody><tr><td align="center">Boolean</td><td align="center">true</td><td align="center">false</td></tr><tr><td align="center">String</td><td align="center">非空字符串</td><td align="center">“”（空字符串）</td></tr><tr><td align="center">Number</td><td align="center">非零数值（包括无穷值）</td><td align="center">0、NaN（参见后面的相关内容）</td></tr><tr><td align="center">Object</td><td align="center">任意对象</td><td align="center">null</td></tr><tr><td align="center">Undefined</td><td align="center">N/A（不存在）</td><td align="center">undefined</td></tr></tbody></table><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>ECMAScript 中最有意思的数据类型或许就是 Number 了。Number 类型使用 IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。</p><p> 最基本的数值字面量格式是十进制整数，直接写出来即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span>; <span class="comment">// 整数</span></span><br></pre></td></tr></table></figure><p> 八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。①</p><h4 id="1-浮点值"><a href="#1-浮点值" class="headerlink" title="1. 浮点值"></a>1. 浮点值</h4><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。下面是几个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 有效，但不推荐</span></span><br></pre></td></tr></table></figure><h4 id="2-值的范围"><a href="#2-值的范围" class="headerlink" title="2. 值的范围"></a>2. 值的范围</h4><p>由于内存的限制，ECMAScript 并不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e324；可以表示的最大数值保存在Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正无穷大）表示。</p><h4 id="3-NaN"><a href="#3-NaN" class="headerlink" title="3. NaN"></a>3. NaN</h4><p>有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执。但在 ECMAScript 中，0、+0 或0 相除会返回 NaN：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-0</span>/+<span class="number">0</span>); <span class="comment">// NaN </span></span><br></pre></td></tr></table></figure><p>NaN 有几个独特的属性。首先，任何涉及 NaN 的操作始终返回 NaN（如 NaN/10），在连续多步计算时这可能是个问题。其次，NaN 不等于包括 NaN 在内的任何值。例如，下面的比较操作会返回 false：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>为此，ECMAScript 提供了 isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给 isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串”10”或布尔值。任何不能转换为数值的值都会导致这个函数返回true。举例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">// false，10 是数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>)); <span class="comment">// false，可以转换为数值 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>)); <span class="comment">// true，不可以转换为数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">// false，可以转换为数值 1</span></span><br></pre></td></tr></table></figure><h4 id="4-数值转换"><a href="#4-数值转换" class="headerlink" title="4.数值转换"></a>4.数值转换</h4><p>有3 个函数可以将非数值转换为数值：Number()、parseInt()和 parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这 3 个函数执行的操作也不同</p><h5 id="Number-、"><a href="#Number-、" class="headerlink" title="Number()、"></a>Number()、</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">Number</span>(<span class="string">&quot;Hello world!&quot;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">Number</span>(<span class="string">&quot;000011&quot;</span>); <span class="comment">// 11</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">// 1 </span></span><br></pre></td></tr></table></figure><h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">// 1234</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">// 10，解释为十六进制整数</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>); <span class="comment">// 22</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;70&quot;</span>); <span class="comment">// 70，解释为十进制值</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xf&quot;</span>); <span class="comment">// 15，解释为十六进制整数</span></span><br></pre></td></tr></table></figure><h5 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">// 1234，按整数解析</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>); <span class="comment">// 22.5</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>); <span class="comment">// 22.34</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0908.5&quot;</span>); <span class="comment">// 908.5</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">&quot;3.125e7&quot;</span>); <span class="comment">// 31250000 </span></span><br></pre></td></tr></table></figure><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）标示，因此下面的代码都是合法的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Jacob&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">`Jingleheimerschmid`</span>;</span><br></pre></td></tr></table></figure><h5 id="不过要注意的是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。比如，下面的写法会导致语法错误："><a href="#不过要注意的是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。比如，下面的写法会导致语法错误：" class="headerlink" title="不过要注意的是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。比如，下面的写法会导致语法错误："></a>不过要注意的是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。比如，下面的写法会导致语法错误：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&#x27;Nicholas&quot;; // 语法错误：开头和结尾的引号必须是同一种</span></span><br></pre></td></tr></table></figure><h4 id="1-字符字面量"><a href="#1-字符字面量" class="headerlink" title="1. 字符字面量"></a>1. 字符字面量</h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p><table><thead><tr><th align="center">字 面 量</th><th align="center">含 义</th></tr></thead><tbody><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">制表</td></tr><tr><td align="center">\b</td><td align="center">退格</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\f</td><td align="center">换页</td></tr><tr><td align="center">\</td><td align="center">反斜杠（\）</td></tr><tr><td align="center">&#39;</td><td align="center">单引号（’），在字符串以单引号标示时使用，例如’He said, &#39;hey.&#39;‘</td></tr><tr><td align="center">&quot;</td><td align="center">双引号（”），在字符串以双引号标示时使用，例如”He said, &quot;hey.&quot;“</td></tr><tr><td align="center">`</td><td align="center">反引号（<code>），在字符串以反引号标示时使用，例如</code>He said, `hey.``</td></tr><tr><td align="center">\xnn</td><td align="center">以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如\x41 等于”A”</td></tr><tr><td align="center">\unnnn</td><td align="center">以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F），例如\u03a3 等于希腊字符”Σ”</td></tr></tbody></table><h4 id="2-字符串的特点"><a href="#2-字符串的特点" class="headerlink" title="2. 字符串的特点"></a>2. 字符串的特点</h4><p>CMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>; </span><br></pre></td></tr></table></figure><h4 id="3-转换为字符串"><a href="#3-转换为字符串" class="headerlink" title="3. 转换为字符串"></a>3. 转换为字符串</h4><p> 有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的 toString()方法。这个方法唯一的用途就是返回当前值的字符串等价物。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> ageAsString = age.toString(); <span class="comment">// 字符串&quot;11&quot;</span></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> foundAsString = found.toString(); <span class="comment">// 字符串&quot;true&quot; </span></span><br></pre></td></tr></table></figure><h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h4><p>可见于数值、布尔值、对象和字符串值。（没错，字符串值也有 toString()方法，该方法只是简单地返回自身的一个副本。）null 和 undefined 值没有 toString()方法。多数情况下，toString()不接收任何参数。不过，在对数值调用这个方法时，toString()可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，toString()返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString()); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)); <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>)); <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">10</span>)); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>)); <span class="comment">// &quot;a&quot; </span></span><br></pre></td></tr></table></figure><h4 id="4-模板字面量"><a href="#4-模板字面量" class="headerlink" title="4. 模板字面量"></a>4. 模板字面量</h4><p>ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myMultiLineString = <span class="string">&#x27;first line\nsecond line&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> myMultiLineTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineString);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineTemplateLiteral);</span><br><span class="line"><span class="comment">// first line </span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineString === myMultiLinetemplateLiteral); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>顾名思义，模板字面量在定义模板时特别有用，比如下面这个 HTML 模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let pageHTML = `</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Jake<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`; </span><br></pre></td></tr></table></figure><h4 id="5-字符串插值"><a href="#5-字符串插值" class="headerlink" title="5. 字符串插值"></a>5. 字符串插值</h4><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> exponent = <span class="string">&#x27;second&#x27;</span>;</span><br><span class="line"><span class="comment">// 以前，字符串插值是这样实现的：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedString =</span><br><span class="line"> value + <span class="string">&#x27; to the &#x27;</span> + exponent + <span class="string">&#x27; power is &#x27;</span> + (value * value);</span><br><span class="line"><span class="comment">// 现在，可以用模板字面量这样实现：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedTemplateLiteral =</span><br><span class="line"> <span class="string">`<span class="subst">$&#123; value &#125;</span> to the <span class="subst">$&#123; exponent &#125;</span> power is <span class="subst">$&#123; value * value &#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(interpolatedString); <span class="comment">// 5 to the second power is 25</span></span><br><span class="line"><span class="built_in">console</span>.log(interpolatedTemplateLiteral); <span class="comment">// 5 to the second power is 25 </span></span><br></pre></td></tr></table></figure><p>所有插入的值都会使用 toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。嵌套的模板字符串无须转义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; <span class="string">`World`</span> &#125;</span>!`</span>); <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure><p>将表达式转换为字符串时会调用 toString()：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">toString</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;World&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; foo &#125;</span>!`</span>); <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure><p>在插值表达式中可以调用函数和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalize</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123; word[<span class="number">0</span>].toUpperCase() &#125;</span><span class="subst">$&#123; word.slice(<span class="number">1</span>) &#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; capitalize(<span class="string">&#x27;hello&#x27;</span>) &#125;</span>, <span class="subst">$&#123; capitalize(<span class="string">&#x27;world&#x27;</span>) &#125;</span>!`</span>); <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure><p>此外，模板也可以插入自己之前的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> value = <span class="string">`<span class="subst">$&#123;value&#125;</span>abc`</span></span><br><span class="line"> <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">append(); <span class="comment">// abc</span></span><br><span class="line">append(); <span class="comment">// abcabc</span></span><br><span class="line">append(); <span class="comment">// abcabcabc</span></span><br></pre></td></tr></table></figure><h4 id="6-模板字面量标签函数"><a href="#6-模板字面量标签函数" class="headerlink" title="6. 模板字面量标签函数"></a>6. 模板字面量标签函数</h4><p>模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, aValExpression, bValExpression, sumExpression</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(strings);</span><br><span class="line">    <span class="built_in">console</span>.log(aValExpression);</span><br><span class="line">    <span class="built_in">console</span>.log(bValExpression);</span><br><span class="line">    <span class="built_in">console</span>.log(sumExpression);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> untaggedResult = <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult); <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult); <span class="comment">// &quot;foobar&quot; </span></span><br></pre></td></tr></table></figure><p>因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个数组中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(strings);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">const</span> expression <span class="keyword">of</span> expressions) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(expression);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult); <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure><p>对于有 n 个插值的模板字面量，传给标签函数的表达式参数的个数始终是 n，而传给标签函数的第一个参数所包含的字符串个数则始终是 n+1。因此，如果你想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zipTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> strings[<span class="number">0</span>] +</span><br><span class="line"> expressions.map(<span class="function">(<span class="params">e, i</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;e&#125;</span><span class="subst">$&#123;strings[i + <span class="number">1</span>]&#125;</span>`</span>)</span><br><span class="line"> .join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> untaggedResult = <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = zipTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult); <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult); <span class="comment">// &quot;6 + 9 = 15&quot; </span></span><br></pre></td></tr></table></figure><h4 id="7-原始字符串"><a href="#7-原始字符串" class="headerlink" title="7. 原始字符串"></a>7. 原始字符串</h4><p>使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示。为此，可以使用默认的 String.raw 标签函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode 示例</span></span><br><span class="line"><span class="comment">// \u00A9 是版权符号</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`\u00A9`</span>); <span class="comment">// ©</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`\u00A9`</span>); <span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// 换行符示例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`first line\nsecond line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line\nsecond line`</span>); <span class="comment">// &quot;first line\nsecond line&quot; </span></span><br></pre></td></tr></table></figure><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><p>Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。<br>尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的（尤其是因为Object API 提供了方法，可以更方便地发现符号属性）。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。</p><h4 id="1-符号的基本用法"><a href="#1-符号的基本用法" class="headerlink" title="1. 符号的基本用法"></a>1. 符号的基本用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym); <span class="comment">// symbol </span></span><br></pre></td></tr></table></figure><p>调用 Symbol()函数时，也可以传入一个字符串参数作为对符号的描述（description），将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(genericSymbol == otherGenericSymbol); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol == otherFooSymbol); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>符号没有字面量语法，这也是它们发挥作用的关键。按照规范，你只要创建 Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(genericSymbol); <span class="comment">// Symbol()</span></span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol); <span class="comment">// Symbol(foo);</span></span><br></pre></td></tr></table></figure><p> 最重要的是，Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，像使用 Boolean、String 或 Number 那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> myBoolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myBoolean); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myString = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myString); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myNumber = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myNumber); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor </span></span><br></pre></td></tr></table></figure><p>如果你确实想使用符号包装对象，可以借用 Object()函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> myWrappedSymbol = <span class="built_in">Object</span>(mySymbol);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myWrappedSymbol); <span class="comment">// &quot;object&quot; </span></span><br></pre></td></tr></table></figure><h4 id="2-使用全局符号注册表"><a href="#2-使用全局符号注册表" class="headerlink" title="2. 使用全局符号注册表"></a>2. 使用全局符号注册表</h4><p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。<br>为此，需要使用 Symbol.for()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fooGlobalSymbol); <span class="comment">// symbol </span></span><br></pre></td></tr></table></figure><p>Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 重用已有符号</span></span><br><span class="line"><span class="built_in">console</span>.log(fooGlobalSymbol === otherFooGlobalSymbol); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol()定义的符号也并不等同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> localSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(localSymbol === globalSymbol); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给 Symbol.for()的任何值都会被转换为字符串。此外，注册表中使用的键同时也会被用作符号描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyGlobalSymbol = <span class="built_in">Symbol</span>.for();</span><br><span class="line"><span class="built_in">console</span>.log(emptyGlobalSymbol); <span class="comment">// Symbol(undefined) </span></span><br></pre></td></tr></table></figure><p>还可以使用 Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回 undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建全局符号</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s)); <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 创建普通符号</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2)); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><p>如果传给 Symbol.keyFor()的不是符号，则该方法抛出 TypeError：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.keyFor(<span class="number">123</span>); <span class="comment">// TypeError: 123 is not a symbol</span></span><br></pre></td></tr></table></figure><h4 id="3-使用符号作为属性"><a href="#3-使用符号作为属性" class="headerlink" title="3. 使用符号作为属性"></a>3. 使用符号作为属性</h4><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()/Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line"> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line"> s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>),</span><br><span class="line"> s4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> [s1]: <span class="string">&#x27;foo val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这样也可以：o[s1] = &#x27;foo val&#x27;;</span></span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, s2, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar val&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(o, &#123;</span><br><span class="line"> [s3]: &#123;<span class="attr">value</span>: <span class="string">&#x27;baz val&#x27;</span>&#125;,</span><br><span class="line"> [s4]: &#123;<span class="attr">value</span>: <span class="string">&#x27;qux val&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val,</span></span><br><span class="line"><span class="comment">// Symbol(baz): baz val, Symbol(qux): qux val&#125;</span></span><br></pre></td></tr></table></figure><p>类似于 Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnPropertySymbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型的键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line"> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> [s1]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line"> [s2]: <span class="string">&#x27;bar val&#x27;</span>,</span><br><span class="line"> baz: <span class="string">&#x27;baz val&#x27;</span>,</span><br><span class="line"> qux: <span class="string">&#x27;qux val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(foo), Symbol(bar)]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));</span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(o));</span><br><span class="line"><span class="comment">// &#123;baz: &#123;...&#125;, qux: &#123;...&#125;, Symbol(foo): &#123;...&#125;, Symbol(bar): &#123;...&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(o));</span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)] </span></span><br></pre></td></tr></table></figure><p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> [<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line"> [<span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>)]: <span class="string">&#x27;bar val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): &quot;foo val&quot;, Symbol(bar): &quot;bar val&quot;&#125;</span></span><br><span class="line"><span class="keyword">let</span> barSymbol = <span class="built_in">Object</span>.getOwnPropertySymbols(o)</span><br><span class="line"> .find(<span class="function">(<span class="params">symbol</span>) =&gt;</span> symbol.toString().match(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="built_in">console</span>.log(barSymbol);</span><br><span class="line"><span class="comment">// Symbol(bar) </span></span><br></pre></td></tr></table></figure><h4 id="4-常用内置符号"><a href="#4-常用内置符号" class="headerlink" title="4. 常用内置符号"></a>4. 常用内置符号</h4><p>ECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。</p><p>这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道for-of 循环会在相关对象上使用 Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。这些内置符号也没有什么特别之处，它们就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p><h4 id="5-Symbol-asyncIterator"><a href="#5-Symbol-asyncIterator" class="headerlink" title="5. Symbol.asyncIterator"></a>5. Symbol.asyncIterator</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的 AsyncIterator。由 for-await-of 语句使用”。换句话说，这个符号表示实现异步迭代器 API 的函数。</p><p>for-await-of 循环会利用这个函数执行异步迭代操作。循环时，它们会调用以 Symbol.asyncIterator为键的函数，并期望这个函数会返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API的 AsyncGenerator：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"> <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.asyncIterator]());</span><br><span class="line"><span class="comment">// AsyncGenerator &#123;&lt;suspended&gt;&#125; </span></span><br></pre></td></tr></table></figure><p>技术上，这个由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回Promise 实例。可以通过显式地调用 next()方法返回，也可以隐式地通过异步生成器函数返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(max) &#123;</span><br><span class="line"> <span class="built_in">this</span>.max = max;</span><br><span class="line"> <span class="built_in">this</span>.asyncIdx = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">this</span>.asyncIdx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line"> <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="built_in">this</span>.asyncIdx++));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line"> <span class="keyword">for</span> <span class="keyword">await</span>(<span class="keyword">const</span> x <span class="keyword">of</span> emitter) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(x);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="注意-Symbol-asyncIterator-是-ES2018-规范定义的，因此只有版本非常新的浏览器支持它。"><a href="#注意-Symbol-asyncIterator-是-ES2018-规范定义的，因此只有版本非常新的浏览器支持它。" class="headerlink" title="注意 Symbol.asyncIterator 是 ES2018 规范定义的，因此只有版本非常新的浏览器支持它。"></a>注意 Symbol.asyncIterator 是 ES2018 规范定义的，因此只有版本非常新的浏览器支持它。</h4><h4 id="6-Symbol-hasInstance"><a href="#6-Symbol-hasInstance" class="headerlink" title="6. Symbol.hasInstance"></a>6. Symbol.hasInstance</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由 instanceof 操作符使用”。instanceof 操作符可以用来确定一个对象实例的原型链上是否有原型。instanceof 的典型使用场景如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bar); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>在 ES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系。以 Symbol.hasInstance 为键的函数会执行同样的操作，只是操作数对调了一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(Foo[<span class="built_in">Symbol</span>.hasInstance](f)); <span class="comment">// true</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>这个属性定义在 Function 的原型上，因此默认在所有函数和类上都可以调用。由于 instanceof操作符会在原型链上寻找这个属性定义，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance]() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bar); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Baz[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Baz); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="7-Symbol-isConcatSpreadable"><a href="#7-Symbol-isConcatSpreadable" class="headerlink" title="7. Symbol.isConcatSpreadable"></a>7. Symbol.isConcatSpreadable</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个布尔值，如果是 true，则意味着对象应该用 Array.prototype.concat()打平其数组元素”。ES6 中的 Array.prototype.concat()方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖 Symbol.isConcatSpreadable 的值可以修改这个行为。<br>数组对象默认情况下会被打平到已有的数组，false 或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾，true 或真值会导致这个类数组对象被打平到数组实例。其他不是类数组对象的对象在 Symbol.isConcatSpreadable 被设置为 true 的情况下将被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initial = [<span class="string">&#x27;foo&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="built_in">Symbol</span>.isConcatSpreadable]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array)); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line">array[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array)); <span class="comment">// [&#x27;foo&#x27;, Array(1)] </span></span><br><span class="line"><span class="keyword">let</span> arrayLikeObject = &#123; <span class="attr">length</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="string">&#x27;baz&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject)); <span class="comment">// [&#x27;foo&#x27;, &#123;...&#125;]</span></span><br><span class="line">arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject)); <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"><span class="keyword">let</span> otherObject = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject)); <span class="comment">// [&#x27;foo&#x27;, Set(1)]</span></span><br><span class="line">otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject)); <span class="comment">// [&#x27;foo&#x27;] </span></span><br></pre></td></tr></table></figure><h4 id="8-Symbol-iterator"><a href="#8-Symbol-iterator" class="headerlink" title="8. Symbol.iterator"></a>8. Symbol.iterator</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用”。换句话说，这个符号表示实现迭代器 API 的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"> *[<span class="built_in">Symbol</span>.iterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.iterator]());</span><br><span class="line"><span class="comment">// Generator &#123;&lt;suspended&gt;&#125; </span></span><br></pre></td></tr></table></figure><p> 技术上，这个由 Symbol.iterator 函数生成的对象应该通过其 next()方法陆续返回值。可以通过显式地调用 next()方法返回，也可以隐式地通过生成器函数返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(max) &#123;</span><br><span class="line"> <span class="built_in">this</span>.max = max;</span><br><span class="line"> <span class="built_in">this</span>.idx = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">this</span>.idx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line"> <span class="keyword">yield</span> <span class="built_in">this</span>.idx++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> emitter) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(x);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">count();</span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="9-Symbol-match"><a href="#9-Symbol-match" class="headerlink" title="9. Symbol.match"></a>9. Symbol.match</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由 String.prototype.match()方法使用”。String.prototype.match()方法会使用以 Symbol.match 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.match]);</span><br><span class="line"><span class="comment">// ƒ [Symbol.match]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]</span></span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10. Symbol.replace</span><br><span class="line">根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 <span class="built_in">String</span>.prototype.replace()方法使用”。<span class="built_in">String</span>.prototype.replace()方法会使用以 <span class="built_in">Symbol</span>.replace 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 <span class="built_in">String</span> 方法的有效参数：</span><br><span class="line">~~~JavaScript</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.replace]);</span><br><span class="line"><span class="comment">// ƒ [Symbol.replace]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.replace(<span class="regexp">/bar/</span>, <span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// &#x27;fooquxbaz&#x27; </span></span><br></pre></td></tr></table></figure><h4 id="11-Symbol-search"><a href="#11-Symbol-search" class="headerlink" title="11. Symbol.search"></a>11. Symbol.search</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由 String.prototype.search()方法使用”。String.prototype.search()方法会使用以 Symbol.search 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.search]);</span><br><span class="line"><span class="comment">// ƒ [Symbol.search]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><h4 id="12-Symbol-species"><a href="#12-Symbol-species" class="headerlink" title="12. Symbol.species"></a>12. Symbol.species</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用 Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar); <span class="comment">// true</span></span><br><span class="line">bar = bar.concat(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz); <span class="comment">// true</span></span><br><span class="line">baz = baz.concat(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="13-Symbol-split"><a href="#13-Symbol-split" class="headerlink" title="13. Symbol.split"></a>13. Symbol.split</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用”。String.prototype.split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.split]);</span><br><span class="line"><span class="comment">// ƒ [Symbol.split]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.split(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;] </span></span><br></pre></td></tr></table></figure><h4 id="14-Symbol-toPrimitive"><a href="#14-Symbol-toPrimitive" class="headerlink" title="14. Symbol.toPrimitive"></a>14. Symbol.toPrimitive</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的 Symbol.toPrimitive 属性上定义一个函数可以改变默认行为。根据提供给这个函数的参数（string、number 或 default），可以控制返回的原始值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + foo); <span class="comment">// &quot;3[object Object]&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - foo); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(foo)); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line"> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;string bar&#x27;</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;default bar&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + bar); <span class="comment">// &quot;3default bar&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - bar); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(bar)); <span class="comment">// &quot;string bar&quot; </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="15-Symbol-toStringTag"><a href="#15-Symbol-toStringTag" class="headerlink" title="15. Symbol.toStringTag"></a>15. Symbol.toStringTag</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法 Object.prototype.toString()使用”。通过 toString()方法获取对象标识时，会检索由 Symbol.toStringTag 指定的实例标识符，默认为”Object”。内置类型已经指定了这个值，但自定义类实例还需要明确定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Set(0) &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.toString()); <span class="comment">// [object Set]</span></span><br><span class="line"><span class="built_in">console</span>.log(s[<span class="built_in">Symbol</span>.toStringTag]); <span class="comment">// Set</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// Foo &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="built_in">Symbol</span>.toStringTag]); <span class="comment">// undefined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// Bar &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.toString()); <span class="comment">// [object Bar]</span></span><br><span class="line"><span class="built_in">console</span>.log(bar[<span class="built_in">Symbol</span>.toStringTag]); <span class="comment">// Bar </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="16-Symbol-unscopables"><a href="#16-Symbol-unscopables" class="headerlink" title="16. Symbol.unscopables"></a>16. Symbol.unscopables</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的 with 环境绑定中排除”。设置这个符号并让其映射对应属性的键值为 true，就可以阻止该属性出现在 with 环境绑定中，如下例所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(foo); <span class="comment">// bar</span></span><br><span class="line">&#125;</span><br><span class="line">o[<span class="built_in">Symbol</span>.unscopables] = &#123;</span><br><span class="line"> foo: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><p> ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br></pre></td></tr></table></figure><p>这个语法类似 Java，但 ECMAScript 只要求在给构造函数提供参数时使用括号。如果没有参数，如上面的例子所示，那么完全可以省略括号（不推荐）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure><p>每个 Object 实例都有如下属性和方法。</p><ul><li><p>1.constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object()函数。</p></li><li><ol start="2"><li>hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如 o.hasOwnProperty(“name”)）或符号。</li></ol></li><li><ol start="3"><li>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。（第 8 章将详细介绍原型。）</li></ol></li><li><ol start="4"><li>propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用（本章稍后讨论的）for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。</li></ol></li><li><ol start="5"><li>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li></ol></li><li><ol start="6"><li>toString()：返回对象的字符串表示。</li></ol></li><li><ol start="7"><li>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。因为在 ECMAScript 中 Object 是所有对象的基类，所以任何对象都有这些属性和方法。第 8 章将介绍对象间的继承机制。</li></ol></li></ul><h4 id="注意-严格来讲，ECMA-262-中对象的行为不一定适合-JavaScript-中的其他对象。比如浏览器环境中的-BOM-和-DOM-对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受-ECMA-262-约束，所以它们可能会也可能不会继承-Object。"><a href="#注意-严格来讲，ECMA-262-中对象的行为不一定适合-JavaScript-中的其他对象。比如浏览器环境中的-BOM-和-DOM-对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受-ECMA-262-约束，所以它们可能会也可能不会继承-Object。" class="headerlink" title="注意 严格来讲，ECMA-262 中对象的行为不一定适合 JavaScript 中的其他对象。比如浏览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受 ECMA-262 约束，所以它们可能会也可能不会继承 Object。"></a>注意 严格来讲，ECMA-262 中对象的行为不一定适合 JavaScript 中的其他对象。比如浏览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受 ECMA-262 约束，所以它们可能会也可能不会继承 Object。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;h5 id=&quot;ECMAScript-有-6-种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Nu</summary>
      
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="数据类型" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之变量</title>
    <link href="http://example.com/2020/10/14/%E7%BA%A2%E5%AE%9D%E4%B9%A62/"/>
    <id>http://example.com/2020/10/14/%E7%BA%A2%E5%AE%9D%E4%B9%A62/</id>
    <published>2020-10-14T05:06:43.000Z</published>
    <updated>2020-11-09T12:27:38.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h3 id="ECMAScript-变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有-3-个关键字可以声明变量：var、const-和-let。其中，var-在"><a href="#ECMAScript-变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有-3-个关键字可以声明变量：var、const-和-let。其中，var-在" class="headerlink" title="ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量：var、const 和 let。其中，var 在"></a>ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量：var、const 和 let。其中，var 在</h3><h3 id="ECMAScript-的所有版本中都可以使用，而-const-和-let-只能在-ECMAScript-6-及更晚的版本中使用。"><a href="#ECMAScript-的所有版本中都可以使用，而-const-和-let-只能在-ECMAScript-6-及更晚的版本中使用。" class="headerlink" title="ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。"></a>ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。</h3><hr><h2 id="var-关键字"><a href="#var-关键字" class="headerlink" title="var 关键字"></a>var 关键字</h2><h4 id="要定义变量，可以使用-var-操作符（注意-var-是一个关键字），后跟变量名（即标识符，如前所述）："><a href="#要定义变量，可以使用-var-操作符（注意-var-是一个关键字），后跟变量名（即标识符，如前所述）：" class="headerlink" title="要定义变量，可以使用 var 操作符（注意 var 是一个关键字），后跟变量名（即标识符，如前所述）："></a>要定义变量，可以使用 var 操作符（注意 var 是一个关键字），后跟变量名（即标识符，如前所述）：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message; </span><br></pre></td></tr></table></figure><h3 id="var-声明作用域"><a href="#var-声明作用域" class="headerlink" title="var 声明作用域"></a>var 声明作用域</h3><h4 id="关键的问题在于，使用-var-操作符定义的变量会成为包含它的函数的局部变量。比如，使用-var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁："><a href="#关键的问题在于，使用-var-操作符定义的变量会成为包含它的函数的局部变量。比如，使用-var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：" class="headerlink" title="关键的问题在于，使用 var 操作符定义的变量会成为包含它的函数的局部变量。比如，使用 var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁："></a>关键的问题在于，使用 var 操作符定义的变量会成为包含它的函数的局部变量。比如，使用 var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 全局变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;hi&quot; </span></span><br></pre></td></tr></table></figure><h3 id="var-声明提升"><a href="#var-声明提升" class="headerlink" title="var 声明提升"></a>var 声明提升</h3><h4 id="使用-var-时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部："><a href="#使用-var-时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部：" class="headerlink" title="使用 var 时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部："></a>使用 var 时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(age);</span><br><span class="line"> <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><h4 id="之所以不会报错，是因为-ECMAScript-运行时把它看成等价于如下代码："><a href="#之所以不会报错，是因为-ECMAScript-运行时把它看成等价于如下代码：" class="headerlink" title="之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码："></a>之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> age;</span><br><span class="line"> <span class="built_in">console</span>.log(age);</span><br><span class="line"> age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><h4 id="这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用-var-声明同一个变量也没有问题："><a href="#这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用-var-声明同一个变量也没有问题：" class="headerlink" title="这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用 var 声明同一个变量也没有问题："></a>这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用 var 声明同一个变量也没有问题：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> age = <span class="number">16</span>;</span><br><span class="line"> <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line"> <span class="keyword">var</span> age = <span class="number">36</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 36</span></span><br></pre></td></tr></table></figure><h2 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h2><h4 id="let-跟-var-的作用差不多，但有着非常重要的区别。最明显的区别是，let-声明的范围是块作用域，而-var-声明的范围是函数作用域。"><a href="#let-跟-var-的作用差不多，但有着非常重要的区别。最明显的区别是，let-声明的范围是块作用域，而-var-声明的范围是函数作用域。" class="headerlink" title="let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是，let 声明的范围是块作用域，而 var 声明的范围是函数作用域。"></a>let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是，let 声明的范围是块作用域，而 var 声明的范围是函数作用域。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// ReferenceError: age 没有定义</span></span><br></pre></td></tr></table></figure><h3 id="var-和-let区别"><a href="#var-和-let区别" class="headerlink" title="var 和 let区别"></a>var 和 let区别</h3><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><h5 id="let-与-var-的另一个重要的区别，就是-let-声明的变量不会在作用域中被提升。"><a href="#let-与-var-的另一个重要的区别，就是-let-声明的变量不会在作用域中被提升。" class="headerlink" title="let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。"></a>let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name 会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="comment">// age 不会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// ReferenceError：age 没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>; </span><br></pre></td></tr></table></figure><h4 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h4><h5 id="与-var-关键字不同，使用-let-在全局作用域中声明的变量不会成为-window-对象的属性（var-声明的变量则会）。"><a href="#与-var-关键字不同，使用-let-在全局作用域中声明的变量不会成为-window-对象的属性（var-声明的变量则会）。" class="headerlink" title="与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）。"></a>与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="条件声明"><a href="#条件声明" class="headerlink" title="条件声明"></a>条件声明</h4><h5 id="在使用-var-声明变量时，由于声明会被提升，JavaScript-引擎会自动将多余的声明在作用域顶部合并为一个声明。因为-let-的作用域是块，所以不可能检查前面是否已经使用-let-声明过同名变量，同时也就不可能在没有声明的情况下声明它。"><a href="#在使用-var-声明变量时，由于声明会被提升，JavaScript-引擎会自动将多余的声明在作用域顶部合并为一个声明。因为-let-的作用域是块，所以不可能检查前面是否已经使用-let-声明过同名变量，同时也就不可能在没有声明的情况下声明它。" class="headerlink" title="在使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。"></a>在使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line"> <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量</span></span><br><span class="line"> <span class="comment">// 那它可以假设还没有声明过</span></span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"> <span class="comment">// 这里没问题，因为可以被作为一个提升声明来处理</span></span><br><span class="line"> <span class="comment">// 不需要检查之前是否声明过同名变量</span></span><br><span class="line"> <span class="keyword">let</span> age = <span class="number">36</span>;</span><br><span class="line"> <span class="comment">// 如果 age 之前声明过，这里会报错</span></span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure><h4 id="for-循环中的-let-声明"><a href="#for-循环中的-let-声明" class="headerlink" title="for 循环中的 let 声明"></a>for 循环中的 let 声明</h4><h5 id="在-let-出现之前，for-循环定义的迭代变量会渗透到循环体外部："><a href="#在-let-出现之前，for-循环定义的迭代变量会渗透到循环体外部：" class="headerlink" title="在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部："></a>在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"> <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5 </span></span><br></pre></td></tr></table></figure><h5 id="改成使用-let-之后，这个问题就消失了，因为迭代变量的作用域仅限于-for-循环块内部："><a href="#改成使用-let-之后，这个问题就消失了，因为迭代变量的作用域仅限于-for-循环块内部：" class="headerlink" title="改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部："></a>改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"> <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i 没有定义</span></span><br></pre></td></tr></table></figure><h5 id="在使用-var-的时候，最常见的问题就是对迭代变量的奇特声明和修改："><a href="#在使用-var-的时候，最常见的问题就是对迭代变量的奇特声明和修改：" class="headerlink" title="在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改："></a>在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 你可能以为会输出 0、1、2、3、4</span></span><br><span class="line"><span class="comment">// 实际上会输出 5、5、5、5、5 </span></span><br></pre></td></tr></table></figure><h5 id="之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的-i-都是同一个变量，因而输出的都是同一个最终值。而在使用-let-声明迭代变量时，JavaScript-引擎在后台会为每个迭代循环声明一个新的迭代变量。每个-setTimeout-引用的都是不同的变量实例，所以-console-log-输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。"><a href="#之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的-i-都是同一个变量，因而输出的都是同一个最终值。而在使用-let-声明迭代变量时，JavaScript-引擎在后台会为每个迭代循环声明一个新的迭代变量。每个-setTimeout-引用的都是不同的变量实例，所以-console-log-输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。" class="headerlink" title="之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。"></a>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会输出 0、1、2、3、4</span></span><br></pre></td></tr></table></figure><h5 id="这种每次迭代声明一个独立变量实例的行为适用于所有风格的-for-循环，包括-for-in-和-for-of循环。"><a href="#这种每次迭代声明一个独立变量实例的行为适用于所有风格的-for-循环，包括-for-in-和-for-of循环。" class="headerlink" title="这种每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括 for-in 和 for-of循环。"></a>这种每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括 for-in 和 for-of循环。</h5><hr><h2 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a>const 声明</h2><h4 id="const-的行为与-let-基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改-const-声明的变量会导致运行时错误。"><a href="#const-的行为与-let-基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改-const-声明的变量会导致运行时错误。" class="headerlink" title="const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。"></a>const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">26</span>;</span><br><span class="line">age = <span class="number">36</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="comment">// const 也不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="comment">// const 声明的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure><h4 id="const-声明的限制只适用于它指向的变量的引用。换句话说，如果-const-变量引用的是一个对象，那么修改这个对象内部的属性并不违反-const-的限制。"><a href="#const-声明的限制只适用于它指向的变量的引用。换句话说，如果-const-变量引用的是一个对象，那么修改这个对象内部的属性并不违反-const-的限制。" class="headerlink" title="const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。"></a>const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>; <span class="comment">// ok </span></span><br></pre></td></tr></table></figure><h4 id="JavaScript-引擎会为-for-循环中的-let-声明分别创建独立的变量实例，虽然-const-变量跟-let-变量很相似，但是不能用-const-来声明迭代变量（因为迭代变量会自增）："><a href="#JavaScript-引擎会为-for-循环中的-let-声明分别创建独立的变量实例，虽然-const-变量跟-let-变量很相似，但是不能用-const-来声明迭代变量（因为迭代变量会自增）：" class="headerlink" title="JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例，虽然 const 变量跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）："></a>JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例，虽然 const 变量跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125; <span class="comment">// TypeError：给常量赋值</span></span><br></pre></td></tr></table></figure><h4 id="不过，如果你只想用-const-声明一个不会被修改的-for-循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对-for-of-和-for-in-循环特别有意义"><a href="#不过，如果你只想用-const-声明一个不会被修改的-for-循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对-for-of-和-for-in-循环特别有意义" class="headerlink" title="不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 for-of 和 for-in 循环特别有意义"></a>不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 for-of 和 for-in 循环特别有意义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> j = <span class="number">7</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7, 7, 7, 7, 7</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a, b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5 </span></span><br></pre></td></tr></table></figure><h2 id="声明风格及最佳实践"><a href="#声明风格及最佳实践" class="headerlink" title="声明风格及最佳实践"></a>声明风格及最佳实践</h2><h3 id="1-不使用-var"><a href="#1-不使用-var" class="headerlink" title="1.不使用 var"></a>1.不使用 var</h3><h4 id="有了-let-和-const，大多数开发者会发现自己不再需要-var-了。限制自己只使用-let-和-const有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。"><a href="#有了-let-和-const，大多数开发者会发现自己不再需要-var-了。限制自己只使用-let-和-const有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。" class="headerlink" title="有了 let 和 const，大多数开发者会发现自己不再需要 var 了。限制自己只使用 let 和 const有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。"></a>有了 let 和 const，大多数开发者会发现自己不再需要 var 了。限制自己只使用 let 和 const有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</h4><h3 id="2-const-优先，let-次之"><a href="#2-const-优先，let-次之" class="headerlink" title="2.const 优先，let 次之"></a>2.const 优先，let 次之</h3><h4 id="使用-const-声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用-const-来声明变量，只在提前知道未来会有修改时，再使用-let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。"><a href="#使用-const-声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用-const-来声明变量，只在提前知道未来会有修改时，再使用-let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。" class="headerlink" title="使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只在提前知道未来会有修改时，再使用 let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。"></a>使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只在提前知道未来会有修改时，再使用 let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h1&gt;&lt;h3 id=&quot;ECMAScript-变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有-</summary>
      
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="变量" scheme="http://example.com/tags/%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS红宝书之简介</title>
    <link href="http://example.com/2020/10/13/%E7%BA%A2%E5%AE%9D%E4%B9%A61/"/>
    <id>http://example.com/2020/10/13/%E7%BA%A2%E5%AE%9D%E4%B9%A61/</id>
    <published>2020-10-13T05:06:43.000Z</published>
    <updated>2020-11-09T12:27:45.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="虽然-JavaScript和-ECMAScript-基本上是同义词，但-JavaScript远远不限于-ECMA-262-所定义的那样。没错，完整的-JavaScript"><a href="#虽然-JavaScript和-ECMAScript-基本上是同义词，但-JavaScript远远不限于-ECMA-262-所定义的那样。没错，完整的-JavaScript" class="headerlink" title="虽然 JavaScript和 ECMAScript 基本上是同义词，但 JavaScript远远不限于 ECMA-262 所定义的那样。没错，完整的 JavaScript"></a>虽然 JavaScript和 ECMAScript 基本上是同义词，但 JavaScript远远不限于 ECMA-262 所定义的那样。没错，完整的 JavaScript</h2><h5 id="1-核心（ECMAScript）"><a href="#1-核心（ECMAScript）" class="headerlink" title="1. 核心（ECMAScript）"></a>1. 核心（ECMAScript）</h5><h5 id="2-文档对象模型（DOM）"><a href="#2-文档对象模型（DOM）" class="headerlink" title="2. 文档对象模型（DOM）"></a>2. 文档对象模型（DOM）</h5><h5 id="3-浏览器对象模型（BOM）"><a href="#3-浏览器对象模型（BOM）" class="headerlink" title="3. 浏览器对象模型（BOM）"></a>3. 浏览器对象模型（BOM）</h5><hr><h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><h4 id="ECMAScript，即-ECMA-262-定义的语言，并不局限于-Web-浏览器。"><a href="#ECMAScript，即-ECMA-262-定义的语言，并不局限于-Web-浏览器。" class="headerlink" title="ECMAScript，即 ECMA-262 定义的语言，并不局限于 Web 浏览器。"></a>ECMAScript，即 ECMA-262 定义的语言，并不局限于 Web 浏览器。</h4><h4 id="ECMA-262-将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。"><a href="#ECMA-262-将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。" class="headerlink" title="ECMA-262 将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。"></a>ECMA-262 将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。</h4><h4 id="Web-浏览器只是-ECMAScript-实现可能存在的一种宿主环境（host-environment）。宿主环境提供"><a href="#Web-浏览器只是-ECMAScript-实现可能存在的一种宿主环境（host-environment）。宿主环境提供" class="headerlink" title="Web 浏览器只是 ECMAScript 实现可能存在的一种宿主环境（host environment）。宿主环境提供"></a>Web 浏览器只是 ECMAScript 实现可能存在的一种宿主环境（host environment）。宿主环境提供</h4><h4 id="ECMAScript-的基准实现和与环境自身交互必需的扩展。"><a href="#ECMAScript-的基准实现和与环境自身交互必需的扩展。" class="headerlink" title="ECMAScript 的基准实现和与环境自身交互必需的扩展。"></a>ECMAScript 的基准实现和与环境自身交互必需的扩展。</h4><hr><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h4 id="文档对象模型（DOM，Document-Object-Model）是一个应用编程接口（API），用于在-HTML-中使"><a href="#文档对象模型（DOM，Document-Object-Model）是一个应用编程接口（API），用于在-HTML-中使" class="headerlink" title="文档对象模型（DOM，Document Object Model）是一个应用编程接口（API），用于在 HTML 中使"></a>文档对象模型（DOM，Document Object Model）是一个应用编程接口（API），用于在 HTML 中使</h4><h4 id="用扩展的-XML。DOM-将整个页面抽象为一组分层节点。"><a href="#用扩展的-XML。DOM-将整个页面抽象为一组分层节点。" class="headerlink" title="用扩展的 XML。DOM 将整个页面抽象为一组分层节点。"></a>用扩展的 XML。DOM 将整个页面抽象为一组分层节点。</h4><hr><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h4 id="浏览器对象模型（BOM）-API，用于支持访问和操作浏览器的窗口。"><a href="#浏览器对象模型（BOM）-API，用于支持访问和操作浏览器的窗口。" class="headerlink" title="浏览器对象模型（BOM） API，用于支持访问和操作浏览器的窗口。"></a>浏览器对象模型（BOM） API，用于支持访问和操作浏览器的窗口。</h4><h4 id="使用-BOM，开发者可以操控浏览器显示页面之外的部分。而-BOM-真正独一无二的地方，当然也是"><a href="#使用-BOM，开发者可以操控浏览器显示页面之外的部分。而-BOM-真正独一无二的地方，当然也是" class="headerlink" title="使用 BOM，开发者可以操控浏览器显示页面之外的部分。而 BOM 真正独一无二的地方，当然也是"></a>使用 BOM，开发者可以操控浏览器显示页面之外的部分。而 BOM 真正独一无二的地方，当然也是</h4><h4 id="问题最多的地方，就是它是唯一一个没有相关标准的-JavaScript-实现。"><a href="#问题最多的地方，就是它是唯一一个没有相关标准的-JavaScript-实现。" class="headerlink" title="问题最多的地方，就是它是唯一一个没有相关标准的 JavaScript 实现。"></a>问题最多的地方，就是它是唯一一个没有相关标准的 JavaScript 实现。</h4><hr><h1 id="HTML-中的-JavaScript"><a href="#HTML-中的-JavaScript" class="headerlink" title="HTML 中的 JavaScript"></a>HTML 中的 JavaScript</h1><h2 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h2><h4 id="将JavaScript-插入-HTML-的主要方法是使用script元素。这个元素是由网景公司创造出来，并最早在-Netscape-Navigator-2-中实现的。后来，这个元素被正式加入到-HTML-规范。script元素有下列-8-个属性。"><a href="#将JavaScript-插入-HTML-的主要方法是使用script元素。这个元素是由网景公司创造出来，并最早在-Netscape-Navigator-2-中实现的。后来，这个元素被正式加入到-HTML-规范。script元素有下列-8-个属性。" class="headerlink" title="将JavaScript 插入 HTML 的主要方法是使用script元素。这个元素是由网景公司创造出来，并最早在 Netscape Navigator 2 中实现的。后来，这个元素被正式加入到 HTML 规范。script元素有下列 8 个属性。"></a>将JavaScript 插入 HTML 的主要方法是使用script元素。这个元素是由网景公司创造出来，并最早在 Netscape Navigator 2 中实现的。后来，这个元素被正式加入到 HTML 规范。script元素有下列 8 个属性。</h4><h5 id="1-async：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。"><a href="#1-async：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。" class="headerlink" title="1. async：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。"></a>1. async：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。</h5><h5 id="2-charset：可选。使用-src-属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。"><a href="#2-charset：可选。使用-src-属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。" class="headerlink" title="2. charset：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。"></a>2. charset：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。</h5><h5 id="3-crossorigin：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin-”anonymous”配置文件请求不必设置凭据标志。crossorigin-”use-credentials”设置凭据标志，意味着出站请求会包含凭据。"><a href="#3-crossorigin：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin-”anonymous”配置文件请求不必设置凭据标志。crossorigin-”use-credentials”设置凭据标志，意味着出站请求会包含凭据。" class="headerlink" title="3. crossorigin：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin=”anonymous”配置文件请求不必设置凭据标志。crossorigin=”use-credentials”设置凭据标志，意味着出站请求会包含凭据。"></a>3. crossorigin：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin=”anonymous”配置文件请求不必设置凭据标志。crossorigin=”use-credentials”设置凭据标志，意味着出站请求会包含凭据。</h5><h5 id="4-defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在-IE7-及更早的版本中，对行内脚本也可以指定这个属性。"><a href="#4-defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在-IE7-及更早的版本中，对行内脚本也可以指定这个属性。" class="headerlink" title="4. defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。"></a>4. defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。</h5><h5 id="5-integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource-Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content-Delivery-Network）不会提供恶意内容。"><a href="#5-integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource-Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content-Delivery-Network）不会提供恶意内容。" class="headerlink" title="5. integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。"></a>5. integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。</h5><h5 id="6-language：废弃。最初用于表示代码块中的脚本语言（如”JavaScript”、”JavaScript-1-2”或”VBScript”）。大多数浏览器都会忽略这个属性，不应该再使用它。"><a href="#6-language：废弃。最初用于表示代码块中的脚本语言（如”JavaScript”、”JavaScript-1-2”或”VBScript”）。大多数浏览器都会忽略这个属性，不应该再使用它。" class="headerlink" title="6. language：废弃。最初用于表示代码块中的脚本语言（如”JavaScript”、”JavaScript 1.2”或”VBScript”）。大多数浏览器都会忽略这个属性，不应该再使用它。"></a>6. language：废弃。最初用于表示代码块中的脚本语言（如”JavaScript”、”JavaScript 1.2”或”VBScript”）。大多数浏览器都会忽略这个属性，不应该再使用它。</h5><h5 id="7-src：可选。表示包含要执行的代码的外部文件。"><a href="#7-src：可选。表示包含要执行的代码的外部文件。" class="headerlink" title="7. src：可选。表示包含要执行的代码的外部文件。"></a>7. src：可选。表示包含要执行的代码的外部文件。</h5><h5 id="8-type：可选。代替-language，表示代码块中脚本语言的内容类型（也称-MIME-类型）。按照惯例，这个值始终都是”text-javascript”，尽管”text-javascript”和”text-ecmascript”都已经废弃了。JavaScript-文件的-MIME-类型通常是”application-x-javascript”，不过给type-属性这个值有可能导致脚本被忽略。在非-IE-的浏览器中有效的其他值还有”application-javascript”和”application-ecmascript”。如果这个值是-module，则代码会被当成-ES6-模块，而且只有这时候代码中才能出现-import-和-export-关键字。使用script的方式有两种：通过它直接在网页中嵌入-JavaScript-代码，以及通过它在网页中包含外部-JavaScript-文件。"><a href="#8-type：可选。代替-language，表示代码块中脚本语言的内容类型（也称-MIME-类型）。按照惯例，这个值始终都是”text-javascript”，尽管”text-javascript”和”text-ecmascript”都已经废弃了。JavaScript-文件的-MIME-类型通常是”application-x-javascript”，不过给type-属性这个值有可能导致脚本被忽略。在非-IE-的浏览器中有效的其他值还有”application-javascript”和”application-ecmascript”。如果这个值是-module，则代码会被当成-ES6-模块，而且只有这时候代码中才能出现-import-和-export-关键字。使用script的方式有两种：通过它直接在网页中嵌入-JavaScript-代码，以及通过它在网页中包含外部-JavaScript-文件。" class="headerlink" title="8. type：可选。代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型）。按照惯例，这个值始终都是”text/javascript”，尽管”text/javascript”和”text/ecmascript”都已经废弃了。JavaScript 文件的 MIME 类型通常是”application/x-javascript”，不过给type 属性这个值有可能导致脚本被忽略。在非 IE 的浏览器中有效的其他值还有”application/javascript”和”application/ecmascript”。如果这个值是 module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。使用script的方式有两种：通过它直接在网页中嵌入 JavaScript 代码，以及通过它在网页中包含外部 JavaScript 文件。"></a>8. type：可选。代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型）。按照惯例，这个值始终都是”text/javascript”，尽管”text/javascript”和”text/ecmascript”都已经废弃了。JavaScript 文件的 MIME 类型通常是”application/x-javascript”，不过给type 属性这个值有可能导致脚本被忽略。在非 IE 的浏览器中有效的其他值还有”application/javascript”和”application/ecmascript”。如果这个值是 module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。使用script的方式有两种：通过它直接在网页中嵌入 JavaScript 代码，以及通过它在网页中包含外部 JavaScript 文件。</h5><hr><h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h5 id="ECMAScript-的语法很大程度上借鉴了-C-语言和其他类-C-语言，如-Java-和-Perl。熟悉这些语言的开发者，应该很容易理解-ECMAScript-宽松的语法"><a href="#ECMAScript-的语法很大程度上借鉴了-C-语言和其他类-C-语言，如-Java-和-Perl。熟悉这些语言的开发者，应该很容易理解-ECMAScript-宽松的语法" class="headerlink" title="ECMAScript 的语法很大程度上借鉴了 C 语言和其他类 C 语言，如 Java 和 Perl。熟悉这些语言的开发者，应该很容易理解 ECMAScript 宽松的语法"></a>ECMAScript 的语法很大程度上借鉴了 C 语言和其他类 C 语言，如 Java 和 Perl。熟悉这些语言的开发者，应该很容易理解 ECMAScript 宽松的语法</h5><h3 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h3><h5 id="首先要知道的是，ECMAScript-中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量-test-和变量-Test-是两个不同的变量。类似地，typeof-不能作为函数名，因为它是一个关键字（后面会介绍）。但-Typeof-是一个完全有效的函数名。"><a href="#首先要知道的是，ECMAScript-中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量-test-和变量-Test-是两个不同的变量。类似地，typeof-不能作为函数名，因为它是一个关键字（后面会介绍）。但-Typeof-是一个完全有效的函数名。" class="headerlink" title="首先要知道的是，ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量 test 和变量 Test 是两个不同的变量。类似地，typeof 不能作为函数名，因为它是一个关键字（后面会介绍）。但 Typeof 是一个完全有效的函数名。"></a>首先要知道的是，ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量 test 和变量 Test 是两个不同的变量。类似地，typeof 不能作为函数名，因为它是一个关键字（后面会介绍）。但 Typeof 是一个完全有效的函数名。</h5><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><h5 id="第一个字符必须是一个字母、下划线（-）或美元符号（-）；"><a href="#第一个字符必须是一个字母、下划线（-）或美元符号（-）；" class="headerlink" title="第一个字符必须是一个字母、下划线（_）或美元符号（$）；"></a>第一个字符必须是一个字母、下划线（_）或美元符号（$）；</h5><h5 id="剩下的其他字符可以是字母、下划线、美元符号或数字。"><a href="#剩下的其他字符可以是字母、下划线、美元符号或数字。" class="headerlink" title="剩下的其他字符可以是字母、下划线、美元符号或数字。"></a>剩下的其他字符可以是字母、下划线、美元符号或数字。</h5><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h5 id="ECMAScript-采用-C-语言风格的注释，包括单行注释和块注释。单行注释以两个斜杠字符开头，如：-单行注释"><a href="#ECMAScript-采用-C-语言风格的注释，包括单行注释和块注释。单行注释以两个斜杠字符开头，如：-单行注释" class="headerlink" title="ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。单行注释以两个斜杠字符开头，如：// 单行注释"></a>ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。单行注释以两个斜杠字符开头，如：// 单行注释</h5><h5 id="块注释以一个斜杠和一个星号（-）开头，以它们的反向组合（-）结尾，如：-这是多行注释"><a href="#块注释以一个斜杠和一个星号（-）开头，以它们的反向组合（-）结尾，如：-这是多行注释" class="headerlink" title="块注释以一个斜杠和一个星号（/）开头，以它们的反向组合（/）结尾，如：/* 这是多行注释 */"></a>块注释以一个斜杠和一个星号（/<em>）开头，以它们的反向组合（</em>/）结尾，如：/* 这是多行注释 */</h5><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><h5 id="ECMAScript-5-增加了严格模式（strict-mode）的概念。严格模式是一种不同的-JavaScript-解析和执行模型，ECMAScript-3-的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。"><a href="#ECMAScript-5-增加了严格模式（strict-mode）的概念。严格模式是一种不同的-JavaScript-解析和执行模型，ECMAScript-3-的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。" class="headerlink" title="ECMAScript 5 增加了严格模式（strict mode）的概念。严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。"></a>ECMAScript 5 增加了严格模式（strict mode）的概念。严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。</h5><h5 id="严格模式会影响-JavaScript-执行的很多方面，因此本书在用到它时会明确指出来。所有现代浏览器都支持严格模式。"><a href="#严格模式会影响-JavaScript-执行的很多方面，因此本书在用到它时会明确指出来。所有现代浏览器都支持严格模式。" class="headerlink" title="严格模式会影响 JavaScript 执行的很多方面，因此本书在用到它时会明确指出来。所有现代浏览器都支持严格模式。"></a>严格模式会影响 JavaScript 执行的很多方面，因此本书在用到它时会明确指出来。所有现代浏览器都支持严格模式。</h5><h3 id="noscript元素"><a href="#noscript元素" class="headerlink" title="noscript元素"></a>noscript元素</h3><h5 id="针对早期浏览器不支持-JavaScript-的问题，需要一个页面优雅降级的处理方案。最终，noscript元素出现，被用于给不支持-JavaScript-的浏览器提供替代内容。虽然如今的浏览器已经-100-支持JavaScript，但对于禁用-JavaScript-的浏览器来说，这个元素仍然有它的用处。"><a href="#针对早期浏览器不支持-JavaScript-的问题，需要一个页面优雅降级的处理方案。最终，noscript元素出现，被用于给不支持-JavaScript-的浏览器提供替代内容。虽然如今的浏览器已经-100-支持JavaScript，但对于禁用-JavaScript-的浏览器来说，这个元素仍然有它的用处。" class="headerlink" title="针对早期浏览器不支持 JavaScript 的问题，需要一个页面优雅降级的处理方案。最终，noscript元素出现，被用于给不支持 JavaScript 的浏览器提供替代内容。虽然如今的浏览器已经 100%支持JavaScript，但对于禁用 JavaScript 的浏览器来说，这个元素仍然有它的用处。"></a>针对早期浏览器不支持 JavaScript 的问题，需要一个页面优雅降级的处理方案。最终，noscript元素出现，被用于给不支持 JavaScript 的浏览器提供替代内容。虽然如今的浏览器已经 100%支持JavaScript，但对于禁用 JavaScript 的浏览器来说，这个元素仍然有它的用处。</h5><h5 id="noscript元素可以包含任何可以出现在body中的-HTML-元素，script除外。在下列两种情况下，浏览器将显示包含在noscript中的内容："><a href="#noscript元素可以包含任何可以出现在body中的-HTML-元素，script除外。在下列两种情况下，浏览器将显示包含在noscript中的内容：" class="headerlink" title="noscript元素可以包含任何可以出现在body中的 HTML 元素，script除外。在下列两种情况下，浏览器将显示包含在noscript中的内容："></a>noscript元素可以包含任何可以出现在body中的 HTML 元素，script除外。在下列两种情况下，浏览器将显示包含在noscript中的内容：</h5><h6 id="-浏览器不支持脚本；"><a href="#-浏览器不支持脚本；" class="headerlink" title=" 浏览器不支持脚本；"></a> 浏览器不支持脚本；</h6><h6 id="-浏览器对脚本的支持被关闭。"><a href="#-浏览器对脚本的支持被关闭。" class="headerlink" title=" 浏览器对脚本的支持被关闭。"></a> 浏览器对脚本的支持被关闭。</h6><h5 id="任何一个条件被满足，包含在noscript中的内容就会被渲染。否则，浏览器不会渲染noscript中的内容。"><a href="#任何一个条件被满足，包含在noscript中的内容就会被渲染。否则，浏览器不会渲染noscript中的内容。" class="headerlink" title="任何一个条件被满足，包含在noscript中的内容就会被渲染。否则，浏览器不会渲染noscript中的内容。"></a>任何一个条件被满足，包含在noscript中的内容就会被渲染。否则，浏览器不会渲染noscript中的内容。</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This page requires a JavaScript-enabled browser.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。"><a href="#这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。" class="headerlink" title="这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。"></a>这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h1&gt;&lt;h2 id=&quot;虽然-JavaScript和-ECMAScript-基本上是同义词</summary>
      
    
    
    
    <category term="JavaScript红宝书" scheme="http://example.com/categories/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6/"/>
    
    
    <category term="JavaScript简介" scheme="http://example.com/tags/JavaScript%E7%AE%80%E4%BB%8B/"/>
    
  </entry>
  
</feed>
